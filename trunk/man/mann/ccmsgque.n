.TH "ccmsgque" n "3 Jan 2010" "Version 4.1" "ccmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ccmsgque \- The \fBC++\fP Application-Server Project
.SH "SYNOPSIS"
.PP
\fB#include 'ccmsgque.h'
.br
using namespace \fBccmsgque\fP;\fP
.SH "INDEX"
.PP
\fBOBJECT CREATION AND DELETION\fP
.br
 \fBOBJECT CONFIGURATION\fP
.br
 \fBLINK CREATION AND DELETION\fP
.br
 \fBADDING SERVICES\fP
.br
 \fBSEND DATA\fP
.br
 \fBREAD DATA\fP
.br
 \fBSLAVE OBJECT\fP
.br
 \fBBUFFER OBJECT\fP
.br
 \fBEXCEPTION OBJECT\fP
.br
.SH "INTRODUCTION"
.PP
The msgque project is an infrastructure to link software together to act like a single software. To link mean distributing work from one software to an other software an wait or not wait for an answer. The linking is done using unix or inet domain sockets and is based on packages send from one software to an other software and back. The msgque project is used to handle all the different aspects for setup and maintain the link and is responsible for:
.IP "\(bu" 2
starting and stopping the server application
.IP "\(bu" 2
starting and stopping the communication interface
.IP "\(bu" 2
sending and receiving package data
.IP "\(bu" 2
reading and writing data from or into a package
.IP "\(bu" 2
setup and maintain the event-handling for an asynchronous transfer
.IP "\(bu" 2
propagate the error messages from the server to the client
.PP
.SH "OBJECT CREATION AND DELETION"
.PP
.SS "MqC*"
The \fIobject\fP is the user visible part of a \fBccmsgque\fP application link.
.SS "ctx = new MqC()"
Create an object ready to be used with \fBLinkCreate\fP to setup an application link. Use the \fBisConnected\fP to check if a link is already available.
.PP
.PP
.nf
class MyClass : public MqC ... { ... }
int main (int argc, MQ_CST argv[]) {
  MyClass ctx; ...
}
.fi
.PP
.SS "delete(ctx)"
Delete the entire object including the application link using \fBLinkDelete\fP. The object can \fBnot\fP be reused.
.SH "OBJECT CONFIGURATION"
.PP
The configuration of an object is done using the functions starting with \fCMqConfig\fP... or by using command-line arguments.
.SS "static: struct MqBufferLS * init = MqInitCreate()"
Initialize the process startup argument prefix. The startup-prefix have to be the name of the executable found in the \fCPATH\fP and additional arguments like a script name or required startup options. The startup-prefix is used for two different purpose:
.IP "\(bu" 2
To start a new entity using the \fBstartAs\fP '--spawn' command-line option
.IP "\(bu" 2
To replace the \fBLinkCreate\fP 'SELF' argument after the \fI'@'\fP command-line argument
.PP
.PP
The startup-prefix is initially set by \fBccmsgque\fP during package loading. 
.PP
.nf
struct MqBufferLS * init = MqInitCreate();
MqBufferLAppendC(init, 'myExecutable');
MqBufferLAppendC(init, 'myFirstArgument');

.fi
.PP
 
.PP
\fBAttention:\fP
.RS 4
the memory is owned by \fBccmsgque\fP -> do \fInot\fP free the memory
.RE
.PP
.SS "command-line:  --buffersize"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBConfigGetBuffersize\fP\fP , \fBset:\fP \fC\fBConfigSetBuffersize\fP\fP
.PP
The send and receive buffersize in bytes (default: 4KB)
.SS "command-line:  --debug"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBConfigGetDebug\fP\fP , \fBset:\fP \fC\fBConfigSetDebug\fP\fP
.PP
Debug a message-queue application. Valid values are 0 <= \fINUM\fP <= 9 using 0 for 'no debugging' and 9 for 'maximum debugging'. (default: 0)
.SS "command-line:  --timeout"
\fBtype:\fP \fC\fBMQ_TIME_T\fP\fP, \fBget:\fP \fC\fBConfigGetTimeout\fP\fP , \fBset:\fP \fC\fBConfigSetTimeout\fP\fP
.PP
User defined timeout used for connection setup and data sending (default: 90 seconds)
.SS "command-line:  --name"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBConfigGetName\fP\fP , \fBset:\fP \fC\fBConfigSetName\fP\fP
.PP
Use \fISTRING\fP as basename of the new message-queue object. The name shows up in the debugging output and is used as prefix for the new created command. (default: the name of the executable)
.SS "command-line:  --srvname"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBConfigGetSrvName\fP\fP , \fBset:\fP \fC\fBConfigSetSrvName\fP\fP
.PP
Use \fISTRING\fP as a client specific prefix in the server debugging output. This is used to link debugging and error messages on the server to a specific client connection. (default: empty)
.SS "ident"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBConfigGetIdent\fP\fP , \fBset:\fP \fC\fBConfigSetIdent\fP\fP
.PP
Use \fBMQ_CST\fP as an application specific identifier set by the programmer and checked with \fC\fBConfigCheckIdent\fP\fP against the \fIidentifier\fP of the link target. The goal is to change the behavior of the application depending on the result. (default: empty)
.SS "command-line: --silent"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsSilent\fP\fP , \fBset:\fP \fC\fBConfigSetIsSilent\fP\fP
.PP
Write (\fIMQ_NO\fP) or don't write (\fIMQ_YES\fP) any output to stdout or stderr. (default: write to stdout or stderr)
.SS "command-line: --string"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsString\fP\fP , \fBset:\fP \fC\fBConfigSetIsString\fP\fP
.PP
Use (\fIMQ_YES\fP), as much as possible, strings in the data-package. Convert any native data-type, like integer or double, into a string (sending) and back to native (receiving). (default: use binary)
.SS "ignoreExit"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBConfigSetIgnoreExit\fP\fP
.PP
By default the \fIserver\fP exit if the \fIclient\fP close the connection. If the boolean value is \fIMQ_YES\fP the \fIserver\fP will continue to work. Without \fIclient\fP connection only the internal event function (set with \fBIEvent\fP) is available to work on tasks. if \fIall\fP (parent and child) event functions return with \fBErrorSetCONTINUE\fP (nothing to do) the process exit. 
.SS "command-line: --thread --spawn --fork"
\fBtype:\fP \fCenum MqStartE\fP, \fBget:\fP \fC\fBConfigGetStartAs\fP\fP , \fBset:\fP \fC\fBConfigSetStartAs\fP (startAs)\fP
.PP
Start a new server as \fIthread\fP or \fIspawn\fP a new process or \fIfork\fP a new process. This arguments are used with:
.IP "\(bu" 2
a server-context to start a new instance after a client connection request
.IP "\(bu" 2
on a server to create a worker with: \fBSlaveWorker\fP
.IP "\(bu" 2
on a client/server together with the \fB'SELF'\fP command-line argument: \fBLinkCreate\fP
.PP
\fBParameters:\fP
.RS 4
\fIstartAs\fP 0=default, 1=fork, 2=thread and 3=spawn
.RE
.PP
.SS "command-line:  --daemon"
\fBtype:\fP \fCMQ_CST\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBConfigSetDaemon\fP (pidfile)\fP
.PP
Close all default IO (e.g stdout, stdin, stderr) and fork the server into the background. (default: no daemon) 
.PP
\fBAttention:\fP
.RS 4
this option require the \fBfork\fP system-call and is \fBnot\fP compatible with threads. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpidfile\fP the name of the file to write the PID into
.RE
.PP
.SS "command-line: --tcp --host --port --myhost --myport"
\fBtype:\fP \fCMQ_CST\fP, \fBget:\fP \fC\fBConfigGetIoTcpHost\fP/Port/MyHost/MyPort\fP , \fBset:\fP \fC\fBConfigSetIoTcp\fP (host, port, myhost, myport)\fP
.PP
Configure a \fItcp\fP socket link. 
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP client: name of the remote host (default: localhost)
.br
 server: name of the local interface (default: listen on \fIall\fP interfaces) 
.br
\fIport\fP client: name of the remote port
.br
 server: name of the local port 
.br
\fImyhost\fP client: name of the local interface 
.br
\fImyport\fP client: name of the local port 
.RE
.PP
\fBAttention:\fP
.RS 4
named ports are supported as well
.RE
.PP
.SS "command-line: --uds --file"
\fBtype:\fP \fCMQ_CST\fP, \fBget:\fP \fC\fBConfigGetIoUdsFile\fP\fP , \fBset:\fP \fC\fBConfigSetIoUds\fP (file)\fP
.PP
Use a \fIuds\fP (http://en.wikipedia.org/wiki/Unix_domain_socket) socket link. The uds communication is usually 50% faster than a local tcp communication but only available on UNIX. 
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP the name of the \fIuds\fP file
.RE
.PP
.SS "command-line: --pipe --socket"
\fBtype:\fP \fCMQ_SOCK\fP, \fBget:\fP \fC\fBConfigGetIoPipeSocket\fP\fP , \fBset:\fP \fC\fBConfigSetIoPipe\fP (socket)\fP
.PP
Start a \fIpipe\fP server to listen on \fIsocket\fP. This is the \fBdefault\fP mode to start a server. The \fIsocket\fP option is special because it is used for internal purpose to submit the socket from the client to the server started as pipe by the client. 
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the file-descriptor number. The only public usage for this option is to serve as interface for an existing tool like (x)inetd. The (x)inetd tool is a \fIUNIX\fP service to listen on a tcp/ip port and start for every connection the proper entry from the file \fI/etc/\fP(x)inetd.conf with the file-descriptor \fI0\fP as send/recv socket handle.
.RE
.PP
.SS "master"
\fBtype:\fP \fCMqC\fP, \fBget:\fP \fC\fBConfigGetMaster\fP\fP , \fBset:\fP \fC\fBSLAVE OBJECT\fP\fP
.PP
return the \fImaster\fP if \fIctx\fP is a slave-context or \fINULL\fP if \fIctx\fP is not a slave-context. !Only a SLAVE has a master!
.SS "filter"
\fBtype:\fP \fCMqC\fP, \fBget:\fP \fC\fBConfigGetFilter\fP\fP , \fBset:\fP \fCNO\fP
.PP
Get the \fIfilter\fP object from a filter pipeline using the following order: (on error return an \fBEXCEPTION OBJECT\fP)
.IP "1." 4
return the \fI\fBMqConfigS::master\fP\fP if non NULL
.IP "2." 4
return the \fI\fBMqSlaveGet\fP\fP with \fIid\fP if non NULL
.IP "3." 4
return a 'filter not available' error
.PP
.SS "ctxId"
\fBtype:\fP \fC\fBMQ_SIZE\fP\fP, \fBget:\fP \fC\fBConfigGetCtxId\fP\fP , \fBset:\fP \fCNO\fP
.PP
return an identifier as integer and is \fIunique\fP per parent-context. The \fIparent-context\fP is always \fC0\fP and every new \fIchild-context\fP get a new identifier by adding 1.
.SS "token"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBConfigGetToken\fP\fP , \fBset:\fP \fCNO\fP
.PP
return the current \fBTOKEN IDENTIFIER\fP and is only useful in a service callback. This command is needed on the server to implement a generic service (A \fBServiceCreate\fP with different \fBTOKEN IDENTIFIER\fP but with the same \fIservice\fP callback).
.SS "isConnected"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsConnected\fP\fP , \fBset:\fP \fCNO\fP
.PP
Is the \fBccmsgque\fP context connected ? A context is connected if the \fBLinkCreate\fP command was successful and a context is NOT connected if a) the object has just been created or b) the link was deleted with \fBLinkDelete\fP
.SS "isTransaction"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsTransaction\fP\fP , \fBset:\fP \fCNO\fP
.PP
Return \fIMQ_YES\fP if a transaction is ongoing. This function is only usefull in a service, read more in \fBFILTER MODE\fP.
.SS "isServer"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsServer\fP\fP , \fBset:\fP \fC\fBConfigSetIsServer\fP\fP
.PP
True if object is a \fIserver\fP object (default: \fIMQ_NO\fP, be a client)
.SS "isParent"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsParent\fP\fP , \fBset:\fP \fCNO\fP
.PP
True if object is a \fIparent\fP object (default: \fIMQ_YES\fP, be a parent)
.SS "isSlave"
\fBtype:\fP \fCbool\fP, \fBget:\fP \fC\fBConfigGetIsSlave\fP\fP , \fBset:\fP \fCNO\fP
.PP
True if object is a \fIslave\fP object (default: \fIMQ_NO\fP, not be a slave)
.SS "interface: \\config_IServerSetup"
Interface to define a \fIserver\fP \fBccmsgque\fP object. This Interface define the ServerSetup callback called at \fBLinkCreate\fP to define the services or to initialize context specific variables. This interface set the \fBisServer\fP configuration value to \fIMQ_YES\fP.
.SS "interface: \\config_IServerCleanup"
Interface to define a \fIserver\fP \fBccmsgque\fP object. This Interface define the ServerCleanup callback called at \fBLinkDelete\fP to free context specific variables. This interface set the \fBisServer\fP configuration value to \fIMQ_YES\fP.
.SS "interface: \\config_IFactory"
The factory pattern is used to create a new application object (read more at: \fBMqSetupS::Factory\fP) Without the \fIFactory\fP pattern only the initial startup context is available to serve incoming requests. In general every server need to provide a \fIFactory\fP pattern.
.PP
.PP
.nf
class Server: public MqC, public IFactory, ... {
  private:
    MqC* Factory() const { return new Server(); }
  ...
}
.fi
.PP
.SS "interface: \\config_IBgError"
Define an asynchronous error handler. This handler is used for handle errors send with \fBSendERROR\fP. Use \fBErrorGetNum\fP and \fBErrorGetText\fP to access the error.
.SS "interface: \\config_IEvent"
Event-Handling is used to process instructions in the \fIbackground\fP to give the tool-user the feeling of a non-blocking application. For example Tcl using the event-handling to update the Tk user-interface while the application is waiting for data. The event handling function is called on idle and is designed for a very \fBshort\fP function execution time. Do only \fIone\fP action per function call. This function will be called with a ~10000 usec intervall to garantee a parallel like execution. 
.PP
\fBAttention:\fP
.RS 4
Together with \fBignoreExit\fP the Event-Handler is used to start background prcessing of tasks. Return the Event-Handler with \fBErrorSetCONTINUE\fP to signal that all tasks are finished and the process/thread is ready to exit. If \fBall\fP \fIchild\fP context Event-Handler return with \fBErrorSetCONTINUE\fP too and the client/server links is already shutdown the process/thread will \fBexit\fP. example: \fCtheLink/example/C++/Filter4\fP.C++ 
.RE
.PP
.SH "LINK CREATION AND DELETION"
.PP
To create and to destroy a link is the main purpose of the \fBccmsgque\fP library. A link is a client/server connection used to perform various tasks.
.SS "ctx.LinkCreate(struct MqBufferLS * args)"
.SS "ctx.LinkCreateVA(va_list args)"
.SS "ctx.LinkCreateV(MQ_CST ..., NULL)"
.SS "ctx.LinkCreateVT(const std::vector<MQ_CST>& args)"
.SS "ctx.LinkCreateVC(int const argc, MQ_CST *args)"
Create a \fIparent-context\fP using the \fBOBJECT CONFIGURATION\fP. A parent-context is responsible to setup the client/server link:
.IP "\(bu" 2
the \fIclient-parent-context\fP create the \fIserver-parent-context\fP 
.IP "\(bu" 2
the \fIserver-parent-context\fP wait for a \fIclient-parent-context\fP connection request
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the object from \fBOBJECT CREATION AND DELETION\fP 
.br
\fIargs\fP command-line arguments including the \fB'@'\fP item for the \fI--pipe\fP setup 
.RE
.PP
\fBAttention:\fP
.RS 4
if the first argument after the \fB'@'\fP item is the string \fB'SELF'\fP an independent server of the current server is started. This is not a \fBSLAVE OBJECT\fP. The 'SELF' argument is replaced by an application default setting (if available) or by arguments set with \fBInit\fP.
.RE
.PP
.SS "ctx.LinkCreateChild(const MqC& parent, struct MqBufferLS * args)"
.SS "ctx.LinkCreateChildVA(const MqC& parent, va_list args)"
.SS "ctx.LinkCreateChildV(const MqC& parent, MQ_CST ..., NULL)"
.SS "ctx.LinkCreateChildVT(const MqC& parent, const std::vector<MQ_CST>& args)"
.SS "ctx.LinkCreateChildVS(const MqC& parent, int const argc, MQ_CST *args)"
Create a \fIchild-context\fP from a \fBccmsgque\fP \fIparent-context\fP and command-line arguments. A child is using the same process or thread as the parent but a different namespace. With a different namespace a child is able to act on different services on the shared server. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the object from \fBOBJECT CREATION AND DELETION\fP 
.br
\fIparent\fP the parent object 
.br
\fIargs\fP all command-line arguments including the \fB'@'\fP token
.RE
.PP
.SS "ctx.LinkDelete()"
Close the client/server link and delete the underlying communication object. All depending objects will be deleted as well like depending \fIchild-context\fP and \fIslave-context\fP local and on the remote site of the link.
.SS "ctx.Exit()"
Shutdown the entire communication and exit the current process or thread.
.SH "ADDING SERVICES"
.PP
To provide a \fIservice\fP is the main purpose of a server. The \fI\fBctx.ServiceCreate(MQ_CST token, IService * service)\fP\fP method is usually added in the \fIServerSetup\fP method of the \fIIServerSetup\fP.
.PP
.PP
.nf
public void ServerSetup() {
  ServiceCreate ('SRV1', CallbackF(&MyServer::SRV1));
}
.fi
.PP
.SS "TOKEN IDENTIFIER"
The \fItoken\fP identifier is a 4 byte string and identifies the service. The \fItoken\fP is set by the programmer to identify different services. \fBccmsgque\fP is using some special \fItoken\fP for \fIinternal\fP or \fIcommon\fP usage:
.IP "\(bu" 2
\fB_\fP??? - all \fItoken\fP starting with a \fB'_'\fP are for \fBinternal\fP usage only
.IP "\(bu" 2
\fB+ALL\fP - used in \fBServiceCreate\fP and \fBServiceDelete\fP to listen on \fBall\fP token not handled by other \fItoken\fP more precise
.IP "\(bu" 2
\fB-ALL\fP - used in \fBServiceDelete\fP to delete \fBall\fP token
.IP "\(bu" 2
\fB+FTR\fP - used for \fBONE-DIRECTIONAL FILTER\fP
.IP "\(bu" 2
\fB+EOF\fP - used for \fBONE-DIRECTIONAL FILTER\fP
.PP
.SS "SERVICE CALLBACK"
A service is using a callback to act on an incoming service request. The callback is used on a \fIserver\fP using \fBServiceCreate\fP or on a \fIclient\fP using \fBSendEND_AND_CALLBACK\fP.
.PP
The callback is implemented using Interface: IService method \fIService(MqS ctx)\fP or using t type \fIvoid CallbackF()\fP.
.SS "ctx.ServiceCreate(MQ_CST token, IService * service)"
.SS "ctx.ServiceCreate(MQ_CST token, CallbackF service)"
Create a new service listen on \fBTOKEN IDENTIFIER\fP and start for every incoming request a \fIservice\fP. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.ServiceProxy(MQ_CST token, MQ_SIZE id=0 )"
Create a new service listen on \fBTOKEN IDENTIFIER\fP and link the incoming package to the outgoing package of slave with \fIid\fP. Use \fIid=0\fP to link a filter.
.SS "ctx.ServiceDelete(MQ_CST token)"
Delete a new service listen on \fBTOKEN IDENTIFIER\fP . (on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.ProcessEvent([int timeout], [MQ_WAIT_(NO|ONCE|FOREVER)])"
Start the Event-Loop and check for the next event. In \fIclient\fP mode this command is usually used together with \fBSendEND_AND_CALLBACK\fP to process the results. (on error return an \fBEXCEPTION OBJECT\fP) 
.PP
\fBParameters:\fP
.RS 4
\fItimeout\fP don't wait more than TIMEOUT seconds to get an answer from the server. If no answer is available an error is raised. (default: \fBcommand-line: --timeout\fP) 
.br
\fIMqC.WAIT\fP use flag value to define the action (default: NO)
.IP "\(bu" 2
\fBNO\fP, don't wait for an event do just the check
.IP "\(bu" 2
\fBONCE\fP, use \fItimeout\fP seconds to wait for exact \fIone\fP event
.IP "\(bu" 2
\fBFOREVER\fP, wait forever and only come back on \fIerror\fP or on \fIexit\fP 
.PP
.RE
.PP
.SH "SEND DATA"
.PP
The \fISend\fP style methods are used to build and send data using the \fBccmsgque\fP send data package. The data is typed using the \fBTYPE IDENTIFIER\fP and the methods can wait or not for an answer. During waiting the the application is still able to work on events like other \fBccmsgque\fP client/server links.
.PP
.PP
.nf
ctx.SendSTART();
ctx.SendI(num);
ctx.SendL_START();
 ctx.SendD(balance);
 ctx.SendC('name of the owner');
 ctx.SendB(signature);
ctx.SendL_END();
ctx.SendEND_AND_WAIT('SRV1')
.fi
.PP
.SS "ctx.SendSTART()"
Initialize a \fBccmsgque\fP send data package. This method is required.
.SS "ctx.SendEND(MQ_CST const token)"
Send the package using \fBTOKEN IDENTIFIER\fP without expecting an answer (FireAndForget). (on error return an \fBEXCEPTION OBJECT\fP) 
.PP
\fBAttention:\fP
.RS 4
if an \fBerror\fP is raised on the server during service-processing the error is send back as \fBasynchronous event\fP and can be raised sometime in the future. To be sure to get the error immediately use \fBSendEND_AND_WAIT\fP. (on error return an \fBEXCEPTION OBJECT\fP)
.RE
.PP
.SS "ctx.SendEND_AND_WAIT(MQ_CST const token, MQ_TIME_T timeout=MQ_TIMEOUT_USER)"
Send the package using \fBTOKEN IDENTIFIER\fP and wait \fItimeout\fP seconds for an answer. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.SendEND_AND_CALLBACK(MQ_CST const token, IService * const callback)"
.SS "ctx.SendEND_AND_CALLBACK(MQ_CST const token, CallbackF const callback)"
Send the package using \fBTOKEN IDENTIFIER\fP and \fBdon't\fP wait for an answer. The answer will be handled by the \fBSERVICE CALLBACK\fP. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.SendRETURN()"
Finish a service-handler and return the data if required:
.IP "\(bu" 2
if a transaction is ongoing this function return the answer.
.IP "\(bu" 2
if the answer is an empty package no previous \fBMqSendSTART\fP is required.
.IP "\(bu" 2
if no transaction is ongoing this function does just return the error code.
.PP
(on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.SendERROR()"
Send an asynchronous error to the link target. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "ctx.Send[TYPE](TYPE value)"
Add an item using \fBTYPE IDENTIFIER\fP to the \fBccmsgque\fP send data package. (example: \fISendY\fP)
.SS "ctx.SendB(MQ_BIN value, MQ_SIZE len)"
Add a \fBccmsgque\fP body \fIitem\fP to the package. A \fIitem\fP is a binary array with a defined \fIlength\fP and including the \fIsize\fP, \fIdata-type\fP and the \fInative\fP data object as information. The \fIitem\fP is usually read with \fBReadN\fP and can be used to save the item into an external storage.
.SS "ctx.SendBDY(MQ_BIN value, MQ_SIZE len)"
Create the entire package \fIbody\fP from a binary array. A package \fIbody\fP include information about the number of items and the native data items. The \fIbody\fP package is usually read with \fBReadBDY\fP and is used to \fItunnel\fP the entire package data. (example: \fIagurad\fP tool)
.SS "ctx.SendL_START()"
Start to send an embedded list item.
.SS "ctx.SendL_END()"
Finish to send an embedded list item.
.SH "READ DATA"
.PP
read data from an incoming \fIread-data-package\fP. 
.PP
\fIReading\fP data is a passive task and the opposite of \fIsending\fP data which is an active task. Passive mean that the \fIread\fP is triggered by an incoming data-package and not by the software-work-flow or the user. There is one \fIread\fP function for every basic type defined in \fBTYPE IDENTIFIER\fP plus help functions. 
.PP
\fBAttention:\fP
.RS 4
Reading data is an atomic task and should not be split. Only one read-package is always in duty. As basic rule read first all data and start the processing afterwards. 
.RE
.PP
 \fBExample:\fP read an integer and a list of double, string and a binary array: 
.PP
.nf
num = ctx.ReadI();
 ctx.ReadL_START();
   balance = ctx.ReadD();
   owner = ctx.ReadC();
   signature = ctx.ReadB();
 ctx.ReadL_END();
.fi
.PP
.SS "TYPE val = ctx.Read[TYPE]()"
read a \fBTYPE IDENTIFIER\fP from the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.br
\fIval\fP the value to read 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "ctx.ReadN(MQ_BIN &value, MQ_SIZE &len)"
extract a \fIbody-item\fP from the \fIread-data-package\fP 
.PP
A \fIbody-item\fP is a binary array with a defined \fIlength\fP and including the \fIsize\fP, \fIdata-type\fP and the \fInative\fP data object as information. The \fIitem\fP extracted can be saved into an external storage and be send later using \fBSendN\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.br
\fIval\fP the \fIbody-item\fP as binary-array 
.br
\fIlen\fP the binary-array-length of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "ctx.ReadBDY(MQ_BIN &value, MQ_SIZE &len)"
extract the entire \fIbody-package\fP from the \fIread-data-package\fP 
.PP
A \fIbody\fP is a binary array with a defined \fIlength\fP and including the \fInumber-of-items\fP and the \fIbody-items\fP as information. The \fIbody\fP extracted can be saved into an external storage or be used in a software tunnel (example: the \fIagurad\fP tool) and be send later using \fBSendBDY\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.br
\fIval\fP the \fIbody\fP as binary-array 
.br
\fIlen\fP the binary-array-length of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqBufferS val = ctx.ReadU()"
extract a \fBtemporary\fP \fBBUFFER OBJECT\fP from the \fIread-data-package\fP 
.PP
The object returned is owned by the \fIread-data-package\fP and is \fBonly\fP valid up to the next call of any \fBREAD DATA\fP function. If a long-term object is required use the C-API function: \fBMqBufferDup\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.br
\fIval\fP the buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "ctx.ReadProxy(MqC otherCtx)"
link two \fIcontext-objects\fP to direct pass a data item from one object to the other. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP and the source of the copy 
.br
\fIotherCtx\fP the \fIother-context-object\fP and the target of the copy 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MQ_SIZE val = ctx.ReadGetNumItems()"
get the number of items left in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of items as integer 
.RE
.PP
.SS "MQ_BOL ctx.ReadItemExists()"
check if an item exists in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
boolean, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SS "ctx.ReadUndo()"
undo the last \fBREAD DATA\fP function call 
.PP
Put the internal position-pointer to the start of the last read \fIbody-item\fP. The next read function call will extract the same item again. Only \fBone\fP undo level is supported. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "ctx.ReadL_START(MQ_BUF buffer=NULL)"
.SS "ctx.ReadL_START(const MqBufferC& buffer)"
.SS "ctx.ReadL_START(MqBufferC * const buffer)"
start to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
Itialize the read with the current \fIbody-item\fP or an optional \fIbuffer-object\fP. This command requires a final \fBctx.ReadL_END()\fP to finish the read. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.br
\fIbuffer\fP an optional \fIbuffer-object\fP as result from a previous \fBMqBufferS val = ctx.ReadU()\fP call or  to use the next item from the \fIread-data-package\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "ctx.ReadL_END()"
finish start to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBctx = new MqC()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SH "SLAVE OBJECT"
.PP
The master/slave link is used to create a mesh of nodes and to link different \fIPARENT\fP context objects together. \fBThe master control the slave.\fP
.PP
The \fIlink\fP is used to perform the following tasks:
.IP "\(bu" 2
report error messages from the \fIslave\fP to the \fImaster\fP 
.IP "\(bu" 2
to create a \fIslave-child-context\fP if a \fImaster-child-context\fP is created
.IP "\(bu" 2
to delete a \fIslave-context\fP if a \fImaster-context\fP is deleted
.PP
In difference to the \fIclient/server\fP link the \fImaster/slave\fP link connect two independent msgque-context in the same process or thread (e.g. node). This leads to the restriction that only the \fImaster-msgque-context\fP can be a \fIserver\fP because only \fIon\fP server per node is possible.
.PP
.PP
.nf

    node-0   |           node-1          |   node-2
===================================================================

| <- client/server link -> | <- client/server link -> |

             | <-- master/slave link --> |

                           |- client1-0 -|- server2-0 ...
                           |
             |- server1-0 -|             |- server2-1 ...
             |             |- client1-1 -|- server2-2 ...
  client0-0 -|                           |- server2-3
             |
             |- server1-1 -|- client1-2 -|- server2-4 ...
.fi
.PP
 
.SS "ctx.SlaveWorker(const int id, struct MqBufferLS * args = NULL)"
.SS "ctx.SlaveWorkerVA(const int id, va_list args)"
.SS "ctx.SlaveWorkerV(const int id, MQ_CST ... , NULL)"
.SS "ctx.SlaveWorkerVT(const int id, vector<MQ_CST>& args)"
.SS "ctx.SlaveWorkerVC(const int id, int const argc, MQ_CST args[])"
create a \fImaster/slave\fP link using the image of the \fIctx\fP object self. 
.PP
The slave-context is started as an independent process or thread based on the \fBstartAs\fP argument. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIargs\fP command-line arguments passed to the \fIworker-client\fP or the \fIworker-server\fP. all arguments prior the first \fB@\fP token are added to the \fIworker-client\fP and the other arguments to the \fIworker-server\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.PP
\fBexample\fP create a worker with id 7 and name 'MyWorker' as thread. 
.PP
.nf
 ctx.SlaveWorkerV (7, '--thread', '--silent', '@', 'WORKER', '--name', 'MyWorker', NULL); 

.fi
.PP
.SS "ctx.SlaveCreate(const int id, MqC *const slave)"
create a \fImaster/slave\fP link between the master-context object and the slave-context object 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIslave\fP the \fIslave\fP context object as CLIENT-PARENT without a CHILD 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
The \fIslave-context\fP is owned by the \fImaster-context\fP. This mean that no other external references should be used and the \fIslave-context\fP will be deleted if the \fImaster-context\fP is be deleted. 
.RE
.PP
.SS "ctx.SlaveDelete(const int id)"
Delete a \fIslave\fP object from a \fImaster/slave\fP link identified by \fIid\fP. 
.PP
By default the \fIslave-context\fP object will be deleted if the \fImaster-context\fP is deleted. Use this functionto delete the \fIparent-slave-context\fP explicit and brake the \fImaster/slave\fP link. If \fIid\fP is invalid nothing will happen. It is an \fIerror\fP to delete a \fIchild-slave-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
it is still possible to delete a \fIchild-slave-context\fP using \fBLinkDelete\fP but this will break the internal master/slave order. 
.RE
.PP
.SS "MqC ctx.SlaveGet(const int id)"
get the slave context 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIslave-context\fP or \fCNULL\fP if \fIid\fP is not valid or \fIctx\fP is not a \fImaster-context\fP. 
.RE
.PP
.SH "BUFFER OBJECT"
.PP
The \fIclass MqBufferC\fP object is created by \fBReadU\fP and id used to save a \fBtypeless temporary data item\fP from the \fBccmsgque\fP data package. The lifetime of the \fIclass MqBufferC\fP is only the current callback up to the next read operation of the same context.
.PP
\fBccmsgque\fP support 2 different buffer objects:
.IP "1." 4
the \fIlibmsgque\fP original buffer called \fBMQ_BUF\fP or \fBMqBufferS\fP
.IP "2." 4
a \fBccmsgque\fP wrapper called \fCMqBufferC\fP 
.PP
Both objects are linked: 
.PP
.nf
MqBufferC buf = ctx.ReadU();
MQ_BUF buf2 = buf.GetU();

.fi
.PP
 1. Example: 
.PP
.nf
MqBufferC buf = ctx.ReadU();
if (buf.GetType() == MQ_STRT)
  printf(buf.GetC());

.fi
.PP
 2. Example: 
.PP
.nf
MQ_BUF buf = ctx.ReadU();
if (buf->type == MQ_STRT)
  printf(buf->cur.C);

.fi
.PP
.SS "TYPE IDENTIFIER"
A \fBccmsgque\fP buffer data package is type safe, this mean that every item has a type prefix and every \fBTYPE val = ctx.Read[TYPE]()\fP or \fBTYPE val=buffer.Get[TYPE](\fP have to match the previous \fBctx.Send[TYPE](TYPE value)\fP with the same \fITYPE\fP. One exception, the cast from and to string (TYPE=C) is allowed. The following type identifier's are available:
.IP "\(bu" 2
\fCY\fP : 1 byte signed character
.IP "\(bu" 2
\fCO\fP : 1 byte boolean character using \fIMQ_YES\fP for yes or true or \fIMQ_NO\fP for no or wrong
.IP "\(bu" 2
\fCS\fP : 2 byte signed short
.IP "\(bu" 2
\fCI\fP : 4 byte signed integer
.IP "\(bu" 2
\fCW\fP : 8 byte signed long long integer
.IP "\(bu" 2
\fCF\fP : 4 byte float
.IP "\(bu" 2
\fCD\fP : 8 byte double
.IP "\(bu" 2
\fCB\fP : unsigned char array used for binary data
.IP "\(bu" 2
\fCC\fP : string data using a \fC\\0\fP at the end
.IP "\(bu" 2
\fCL\fP : list type able to hold a list of all items from above
.IP "\(bu" 2
\fCU\fP : typeless buffer able to hold a single item from above
.PP
.SS "TYPE val=buffer.Get[TYPE]("
return the data form the buffer using the \fBTYPE IDENTIFIER\fP. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "enum MqTypeE buffer.GetType()"
return the type as single character of the item stored in the buffer object.
.SH "EXCEPTION OBJECT"
.PP
The exception object is used to transport a \fBccmsgque\fP error using the \fIclass MqCException ex\fP.
.PP
.PP
.nf
try {
 i = ctx.ReadI();
} catch (const exception& ex) {
 ctx.ErrorSet(ex);
 cout << ctx.ErrorGetText() << endl;
 ctx.ErrorReset();
}
.fi
.PP
.SS "string ex.what() or ctx.ErrorGetText()"
return the error message from the error object.
.SS "int ex.num() or ctx.ErrorGetNum()"
return the error number from the error object. The number can be used as exit-code.
.SS "ctx.ErrorC(string prefix, int num, string what)"
create a \fBccmsgque\fP error object but do \fBnot\fP raise the \fBEXCEPTION OBJECT\fP
.SS "ctx.ErrorSet(const exception& ex)"
convert a \fIclass MqCException ex\fP into a \fBccmsgque\fP conform error using the \fIctx\fP object. This method is used to enable additional error processing capabilities from \fBLinkDelete\fP or \fBExit\fP after the exception was caught and before the application exit or the object is deleted.
.SS "\\ErrorSetCONTINUE"
set \fBMqErrorS::code\fP to \fBMQ_CONTINUE\fP and return the value 
.SS "ctx.ErrorReset()"
clear the \fBccmsgque\fP error object.
.SS "ctx.ErrorRaise()"
convert and raise an \fBccmsgque\fP error object into a C++ \fBEXCEPTION OBJECT\fP.
.SS "ctx.ErrorPrint()"
print an \fBccmsgque\fP error object to stderr and \fIclear\fP the \fBccmsgque\fP error
.SH "FILTER MODE"
.PP
The filter mode is related to a special usage of the \fBccmsgque\fP software called a command pipeline. To define a filter create a \fIserver\fP with \fBisServer\fP or use \fBIServerSetup\fP and add the required services.
.SS "ONE-DIRECTIONAL FILTER"
A one-directional filter has a \fIdata-flow\fP from the \fIleft\fP to the \fIright\fP and is well known from the \fBunix\fP shell to link different commands together: 
.PP
.nf

    command1 | command2 | command3

.fi
.PP
 A \fBccmsgque\fP command pipeline is created with the special character \fB@\fP instead of \fB\fP| : 
.PP
.nf

    msgcmd1 @ msgcmd2 @ msgcmd3

.fi
.PP
 with every command have to use \fBlibmsgque\fP. To define a \fBccmsgque\fP filter create a service handle with \fBServiceCreate\fP or \fBServiceProxy\fP for the both special token:
.IP "\(bu" 2
\fB+FTR\fP : required to act on filter data rows. Every filter input data is a list of filter data rows and every row is a list of filter data columns. Every row is send to the following filter-command as \fB+FTR\fP service request.
.IP "\(bu" 2
\fB+EOF\fP : required to act on End-Of-Filter data and is called after all \fB+FTR\fP data was send. Sometimes the filter data can not be served as \fB+FTR\fP data (example: sorting of the input rows need to read all rows before the data can be send to the next filter command) and the \fB+EOF\fP token is used to continue send \fB+FTR\fP data rows.
.PP
and send every data item with \fBSendEND_AND_WAIT\fP.
.SS "BI-DIRECTIONAL FILTER"
A bi-directional filter has a \fIdata-flow\fP in both directions and is used in a \fIclassical\fP client/server application: 
.PP
.nf

    client ... <--> ... server

.fi
.PP
 to add an additional feature like a protocol-tunnelling: 
.PP
.nf

    client @ mq2tunnel ... <--> ... tunnel2mq @ server

.fi
.PP
 or to convert the protocol into an other protocol: 
.PP
.nf

    client @ mq2soap ... <--> ... soap-server

.fi
.PP
 To define a \fIbi-directional\fP filter a couple of commands provide support:
.IP "\(bu" 2
\fBServiceCreate\fP : use the token \fB+ALL\fP to act on \fIall\fP services
.IP "\(bu" 2
\fBConfigGetFilter\fP: to get the filter context (other site)
.IP "\(bu" 2
\fBConfigGetToken\fP: to get the current token
.IP "\(bu" 2
\fBConfigGetIsTransaction\fP : to check if a transaction is ongoing
.IP "\(bu" 2
\fBReadBDY\fP : to read the entire body as binary array
.IP "\(bu" 2
\fBSendBDY\fP : to send the entire body
.PP
.SH "PORTABILITY ISSUES"
.PP
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc processor or i686 processor from the VritualBox emulator.
.SH "EXAMPLES"
.PP
.SS "1. create a server to multiplicate 2 double values and return the result"
.PP
.nf

#include 'ccmsgque.h'

using namespace ccmsgque;

class mulserver : public MqC, public IServerSetup, public IFactory {
  private:
    MqC* Factory() const {
      return new mulserver();
    }
    void ServerSetup () {
      ServiceCreate('MMUL', CallbackF(&mulserver::MMUL));
    }
    void MMUL () {
      SendSTART();
      SendD(ReadD() * ReadD());
      SendRETURN();
    }
};

int MQ_CDECL main (int argc, MQ_CST argv[])
{
  mulserver ctx;
  try {
    ctx.ConfigSetName ('MyMulServer');
    ctx.LinkCreateVC (argc, argv);
    ctx.ProcessEvent ();
  } catch (const exception& e) {
    ctx.ErrorSet(e);
  }
  ctx.Exit ();
}
.fi
.PP
 Start \fImulserver.cc\fP using \fITCP\fP port \fI7777\fP and create a \fIthread\fP for every incoming connection 
.PP
.nf

> mulserver --tcp --port 7777 --thread

.fi
.PP
.SS "2. in a client call the service from 1."
.PP
.nf

#include <iostream>
#include 'ccmsgque.h'

using namespace std;
using namespace ccmsgque;

int MQ_CDECL main (int argc, MQ_CST argv[])
{
  MqC ctx;
  try {
    ctx.ConfigSetName ('MyMulClient');
    ctx.LinkCreateVC (argc, argv);
    ctx.SendSTART();
    ctx.SendD(3.67);
    ctx.SendD(22.3);
    ctx.SendEND_AND_WAIT('MMUL', 5);
    cout << ctx.ReadD() << endl;
  } catch (const exception& e) {
    ctx.ErrorSet(e);
  }
  ctx.Exit();
}
.fi
.PP
 Use \fImulclient.cc\fP to connect to \fImulserver.cc\fP using \fITCP\fP port \fI7777\fP: 
.PP
.nf

> mulclient --tcp --port 7777

.fi
.PP
.SS "3. create a filter to wrap every column in a '<>' pair"
.PP
.nf

#include 'ccmsgque.h'

using namespace std;
using namespace ccmsgque;

class manfilter : public MqC, public IFactory {
    MqC* Factory() const { 
      return new manfilter(); 
    }
  public:
    void fFTR () {
      MqC *ftr = ConfigGetFilter();
      MQ_BUF temp = GetTempBuffer();
      ftr->SendSTART();
      while (ReadItemExists()) {
        ftr->SendU(MqBufferSetV(temp, '<%s>', ReadC()));
      }
      ftr->SendEND_AND_WAIT('+FTR');
      return SendRETURN();
    }
};

int MQ_CDECL main (int argc, MQ_CST argv[])
{
  manfilter filter;
  try {
    filter.ConfigSetName ('manfilter');
    filter.ConfigSetIsServer (MQ_YES);
    filter.LinkCreateVC(argc, argv);
    filter.ServiceCreate('+FTR', MqC::CallbackF(&manfilter::fFTR));
    filter.ServiceProxy ('+EOF');
    filter.ProcessEvent ();
  } catch (const exception& e) {
    filter.ErrorSet(e);
  }
  filter.Exit();
}
.fi
.PP
 Use \fImanfilter.cc\fP in a LibMsgque command pipeline: 
.PP
.nf

> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :

.fi
.PP
.SH "SEE ALSO"
.PP
C++, C: libmsgque(n), C++: ccmsgque(n), C#: csmsgque(n), JAVA: javamsgque(n), PYTHON: pymsgque(n), TCL: tclmsgque(n), PERL: perlmsgque(n)
.SH "KEYWORDS"
.PP
C++, unix, socket, message, msgque 
.SH "Author"
.PP 
Generated automatically by Doxygen for ccmsgque from the source code.
