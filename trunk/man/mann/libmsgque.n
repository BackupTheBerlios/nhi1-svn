.TH "libmsgque" n "11 Jan 2010" "Version 4.1" "libmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libmsgque \- The \fBC\fP \fBApplication-Server\fP and \fBProgramming-Language-Micro-Kernel\fP Project
.SH "SYNOPSIS"
.PP
\fB#include 'msgque.h'\fP
.SH "INDEX"
.PP
\fBCONTEXT API\fP
.br
 \fBCONFIG API\fP
.br
 \fBLINK API\fP
.br
 \fBSERVICE API\fP
.br
 \fBSEND API\fP
.br
 \fBREAD API\fP
.br
 \fBSLAVE API\fP
.br
 \fBBUFFER API\fP
.br
 \fBEXCEPTION OBJECT\fP
.br
.SH "INTRODUCTION"
.PP
public libmsgque API 
.PP
The msgque project is an infrastructure to link software together to act like a single software. To link mean distributing work from one software to an other software an wait or not wait for an answer. The linking is done using unix or inet domain sockets and is based on packages send from one software to an other software and back. The msgque project is used to handle all the different aspects for setup and maintain the link and is responsible for:
.IP "\(bu" 2
starting and stopping the server application
.IP "\(bu" 2
starting and stopping the communication interface
.IP "\(bu" 2
sending and receiving package data
.IP "\(bu" 2
reading and writing data from or into a package
.IP "\(bu" 2
setup and maintain the event-handling for an asynchronous transfer
.IP "\(bu" 2
propagate the error messages from the server to the client
.PP
.SH "CONTEXT API"
.PP
\fBContextCreate\fP
.br
 \fBContextDelete\fP
.br
 \fBExit\fP
.br
.PP
\fIcontext\fP, the top-level data structure and \fIapplication-handle\fP 
.PP
The \fIcontext-data-structure\fP has a \fIlibmsgque-specific-part\fP and an \fIapplication-specific-part\fP. Both parts are linked together. The \fIlibmsgque-specific-part\fP has all data required to manage a \fIclient-server-link\fP. The \fIapplication-specific-part\fP as all data required by the application. The following C-API example demonstrate the layout of the \fIcontext-data-structure\fP. 
.PP
.nf
 struct MyCtxDataS {
   struct MqS  mqctx;   // libmsgque-specific-data
   int         mydata;  // application-specific-data
   ...                  // application-specific-data
 };

.fi
.PP
 The \fIlibmsgque-specific-data\fP have to be the \fIfirst\fP data entry in the structure.
.br
 A \fIhigh-level-programming-language\fP like JAVA, C#, C++, Perl, Python, Tcl or VB-NET is using a wrapper arround this \fIdata-structure\fP as \fIapplication-handle\fP.
.PP
The \fIprogramming-language\fP JAVA, C#, C++, Python or VB-NET does providing a concept for the \fIapplication-specific-data\fP defined as \fIclass-member-data\fP. 
.SS "struct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)"
create a new context and initialize the default configuration data 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP (C-API) the number of bytes in the \fIcontext-data-structure\fP as returned by \fCsizeof(struct MyCtxDataS)\fP (default: \fI0\fP, use only \fIlibmsgque-specific-data\fP and no \fIapplication-specific-data\fP) 
.br
\fItmpl\fP (C-API) an other \fIcontext-data-structure\fP used as template to initialize the configuration data. This template is used for a \fIchild\fP to get the configuration data from the \fIparent\fP. (default: \fINULL\fP, create an initial context) 
.RE
.PP
\fBReturns:\fP
.RS 4
the new \fIcontext\fP, no error return because this function \fIpanic\fP on \fIout-of-memory-error\fP 
.RE
.PP
.PP
\fBExample:\fP create an \fIapplication-context\fP with \fImydata\fP as \fIapplication-specific-data\fP: 
.PP
.nf
 struct MyCtxDataS { 
   struct MqS mqctx; 
   int mydata; 
 }; 
 struct MqS * const ctx = MqContextCreate(sizeof(struct MyCtxDataS), NULL); 

.fi
.PP
.SS "MqContextDelete(struct MqS ** ctx)"
delete the \fIcontext\fP 
.PP
Shutdown the \fIclient-server-link\fP, free the memory and set the \fIctx\fP to \fINULL\fP. The \fIcontext\fP can \fBnot\fP be reused. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
.SS "MqExit(struct MqS* ctx)"
delete the \fIcontext\fP and exit the current process or thread 
.PP
This function will never return.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
.SH "CONFIG API"
.PP
\fBInit\fP
.br
 \fBbuffersize\fP, \fBdebug\fP, \fBtimeout\fP
.br
 \fBname\fP, \fBsrvname\fP, \fBident\fP
.br
 \fBisSilent\fP, \fBisString\fP, \fBisServer\fP
.br
 \fBtcp\fP, \fBuds\fP, \fBpipe\fP
.br
 \fBstartAs\fP, \fBdaemon\fP, \fBignoreExit\fP
.br
 \fBIServerSetup\fP, \fBIServerCleanup\fP
.br
 \fBIFactory\fP, \fBIBgError\fP, \fBIEvent\fP
.br
.PP
The configuration of an object is done using the functions starting with \fCMqConfig\fP... or by using command-line arguments.
.SS "static: struct MqBufferLS * init = MqInitCreate()"
Initialize the process \fIstartup-prefix\fP argument. 
.PP
The \fIstartup-prefix\fP have to be the name of the executablei, found in the \fCPATH\fP environment variable, and additional arguments like the script name or the required startup options. The \fIstartup-prefix\fP is used for two different purpose:
.IP "\(bu" 2
To start a new entity using the \fBstartAs\fP '--spawn' command-line option.
.IP "\(bu" 2
To replace the \fIcommand-line-argument\fP \fC'... @ SELF ...'\fP with \fC'... @ startup-prefix ...'\fP at \fBLinkCreate\fP.
.PP
Every use of this function will free the data of the previous \fIstartup-prefix\fP. By default the \fIstartup-prefix\fP is set during package loading or during \fBLinkCreate\fP and have \fBnot\fP to be initialized again. 
.PP
\fBExample:\fP initialize the \fIstratup-prefix\fP with \fImyExecutable\fP and \fImyFirstArgument\fP 
.PP
.nf
 struct MqBufferLS * init = MqInitCreate(); 
 MqBufferLAppendC(init, 'myExecutable'); 
 MqBufferLAppendC(init, 'myFirstArgument'); 

.fi
.PP
 The memory is owned by the library -> \fBdo not free the memory\fP
.SS "command-line:  --buffersize"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBMqConfigGetBuffersize\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetBuffersize\fP (ctx, buffersize)\fP
.PP
The send and receive buffersize in bytes (default: 4KB)
.SS "command-line:  --debug"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBMqConfigGetDebug\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetDebug\fP (ctx, debug)\fP
.PP
Debug a message-queue application. Valid values are 0 <= \fINUM\fP <= 9 using 0 for 'no debugging' and 9 for 'maximum debugging'. (default: 0)
.SS "command-line:  --timeout"
\fBtype:\fP \fC\fBMQ_TIME_T\fP\fP, \fBget:\fP \fC\fBMqConfigGetTimeout\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetTimeout\fP (ctx, timeout)\fP
.PP
User defined timeout used for connection setup and data sending (default: 90 seconds)
.SS "command-line:  --name"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetName\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetName\fP (ctx. name)\fP
.PP
Use \fISTRING\fP as basename of the new message-queue object. The name shows up in the debugging output and is used as prefix for the new created command. (default: the name of the executable)
.SS "command-line:  --srvname"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetSrvName\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetSrvName\fP (ctx, srvName)\fP
.PP
Use \fISTRING\fP as a client specific prefix in the server debugging output. This is used to link debugging and error messages on the server to a specific client connection. (default: empty)
.SS "ident"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetIdent\fP (struct \fBMqS\fP *ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIdent\fP (struct \fBMqS\fP *ctx, MQ_CST ident)\fP
.PP
Use \fBMQ_CST\fP as an application specific identifier set by the programmer and checked with \fC\fBMqConfigCheckIdent\fP\fP (struct \fBMqS\fP *ctx, MQ_CST ident) against the \fIidentifier\fP of the link target. The goal is to change the behavior of the application depending on the result. (default: empty)
.SS "command-line: --silent"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsSilent\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsSilent\fP (ctx, bool)\fP
.PP
Write (\fIMQ_NO\fP) or don't write (\fIMQ_YES\fP) any output to stdout or stderr. (default: write to stdout or stderr)
.SS "command-line: --string"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsString\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsString\fP (ctx, bool)\fP
.PP
Use (\fIMQ_YES\fP), as much as possible, strings in the data-package. Convert any native data-type, like integer or double, into a string (sending) and back to native (receiving). (default: use binary)
.SS "isServer"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsServer\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsServer\fP (ctx, isServer)\fP
.PP
True if object is a \fIserver\fP object (default: \fIMQ_NO\fP, be a client)
.SS "command-line: --tcp --host --port --myhost --myport"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoTcpHost\fP/Port/MyHost/MyPort\fP , \fBset:\fP \fC\fBMqConfigSetIoTcp\fP (ctx,host,port,myhost,myport)\fP
.PP
Configure a \fItcp\fP socket link. 
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP client: name of the remote host (default: localhost)
.br
 server: name of the local interface (default: listen on \fIall\fP interfaces) 
.br
\fIport\fP client: name of the remote port
.br
 server: name of the local port 
.br
\fImyhost\fP client: name of the local interface 
.br
\fImyport\fP client: name of the local port 
.RE
.PP
\fBAttention:\fP
.RS 4
named ports are supported as well
.RE
.PP
.SS "command-line: --uds --file"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoUdsFile\fP\fP , \fBset:\fP \fC\fBMqConfigSetIoUds\fP (ctx, file)\fP
.PP
Use a \fIuds\fP (http://en.wikipedia.org/wiki/Unix_domain_socket) socket link. The uds communication is usually 50% faster than a local tcp communication but only available on UNIX. 
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP the name of the \fIuds\fP file
.RE
.PP
.SS "command-line: --pipe --socket"
\fBtype:\fP \fC\fBMQ_SOCK\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoPipeSocket\fP\fP , \fBset:\fP \fC\fBMqConfigSetIoPipe\fP (ctx, socket)\fP
.PP
Start a \fIpipe\fP server to listen on \fIsocket\fP. This is the \fBdefault\fP mode to start a server. The \fIsocket\fP option is special because it is used for internal purpose to submit the socket from the client to the server started as pipe by the client. 
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the file-descriptor number. The only public usage for this option is to serve as interface for an existing tool like (x)inetd. The (x)inetd tool is a \fIUNIX\fP service to listen on a tcp/ip port and start for every connection the proper entry from the file \fI/etc/\fP(x)inetd.conf with the file-descriptor \fI0\fP as send/recv socket handle.
.RE
.PP
.SS "command-line: --thread --spawn --fork"
\fBtype:\fP \fCenum \fBMqStartE\fP\fP, \fBget:\fP \fC\fBMqConfigGetStartAs\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetStartAs\fP (ctx, startAS\fP
.PP
Start a new server as \fIthread\fP or \fIspawn\fP a new process or \fIfork\fP a new process. This arguments are used with:
.IP "\(bu" 2
a server-context to start a new instance after a client connection request
.IP "\(bu" 2
on a server to create a worker with: \fBSlaveWorker\fP
.IP "\(bu" 2
on a client/server together with the \fB'SELF'\fP command-line argument: \fBLinkCreate\fP
.PP
\fBParameters:\fP
.RS 4
\fIstartAs\fP 0=default, 1=fork, 2=thread and 3=spawn
.RE
.PP
.SS "command-line:  --daemon"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBMqConfigSetDaemon\fP (ctx, pidfile)\fP
.PP
Close all default IO (e.g stdout, stdin, stderr) and fork the server into the background. (default: no daemon) 
.PP
\fBAttention:\fP
.RS 4
this option require the \fBfork\fP system-call and is \fBnot\fP compatible with threads. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpidfile\fP the name of the file to write the PID into
.RE
.PP
.SS "ignoreExit"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBMqConfigSetIgnoreExit\fP (ctx, bool)\fP
.PP
By default the \fIserver\fP exit if the \fIclient\fP close the connection. If the boolean value is \fIMQ_YES\fP the \fIserver\fP will continue to work. Without \fIclient\fP connection only the internal event function (set with \fBIEvent\fP) is available to work on tasks. if \fIall\fP (parent and child) event functions return with \fBErrorSetCONTINUE\fP (nothing to do) the process exit. 
.SS "interface: MqConfigSetServerSetup (ctx, fFunc, data, fFree, fCopy)"
Interface to define a \fIserver\fP libmsgque object. This Interface define the ServerSetup callback called at \fBLinkCreate\fP to define the services or to initialize context specific variables. This interface set the \fBisServer\fP configuration value to \fIMQ_YES\fP.
.SS "interface: MqConfigSetServerCleanup (ctx, fFunc, data, fFree, fCopy)"
Interface to define a \fIserver\fP libmsgque object. This Interface define the ServerCleanup callback called at \fBLinkDelete\fP to free context specific variables. This interface set the \fBisServer\fP configuration value to \fIMQ_YES\fP.
.SS "interface: MqConfigSetFactory (ctx, fCreate, cData, fcFree, fcCopy, fDelete, dData, fdFree, fdCopy)"
The factory pattern is used to create a new application object (read more at: \fBMqSetupS::Factory\fP) Without the \fIFactory\fP pattern only the initial startup context is available to serve incoming requests. In general every server need to provide a \fIFactory\fP pattern.
.SS "interface: MqConfigSetBgError (ctx, fFunc, Data, fFree, fCopy)"
Define an asynchronous error handler. This handler is used for handle errors send with \fBSendERROR\fP. Use \fBErrorGetNum\fP and \fBErrorGetText\fP to access the error.
.SS "interface: MqConfigSetEvent (ctx, fFunc, Data, fFree, fCopy)"
Event-Handling is used to process instructions in the \fIbackground\fP to give the tool-user the feeling of a non-blocking application. For example Tcl using the event-handling to update the Tk user-interface while the application is waiting for data. The event handling function is called on idle and is designed for a very \fBshort\fP function execution time. Do only \fIone\fP action per function call. This function will be called with a ~10000 usec interval to guarantee a parallel like execution. 
.PP
\fBAttention:\fP
.RS 4
Together with \fBignoreExit\fP the Event-Handler is used to start background processing of tasks. Return the Event-Handler with \fBErrorSetCONTINUE\fP to signal that all tasks are finished and the process/thread is ready to exit. If \fBall\fP \fIchild\fP context Event-Handler return with \fBErrorSetCONTINUE\fP too and the client/server links is already shutdown the process/thread will \fBexit\fP. example: \fCtheLink/example/C/Filter4.C\fP 
.RE
.PP
.SH "LINK API"
.PP
\fBLinkCreate\fP
.br
 \fBLinkCreateChild\fP
.br
 \fBLinkGetParent\fP
.br
 \fBLinkIsParent\fP
.br
 \fBLinkGetCtxId\fP
.br
 \fBLinkIsConnected\fP
.br
.PP
setup and manage a \fIclient-server-link\fP 
.PP
To create, destroy and manage a \fIclient-server-link\fP is the main purpose of the library. 
.SS "MqLinkCreate (struct MqS *ctx, struct MqBufferLS ** args)"
make a \fIcontext\fP to a \fIparent-context\fP and setup a new \fIclient-server-link\fP 
.PP
A \fIparent-context\fP is responsible to setup the \fIclient-server-link\fP 
.IP "\(bu" 2
the \fIclient-parent-context\fP start a new \fIclient-server-link\fP 
.IP "\(bu" 2
the \fIserver-parent-context\fP wait for a \fIclient-parent-context\fP connection request
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIargs\fP \fIcommand-line-arguments\fP to configure the \fIclient-server-link\fP including the \fB'@'\fP item to add \fIserver-commandline-arguments\fP for the \fI--pipe\fP setup.
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
if the first argument after the \fB'@'\fP item is the string \fB'SELF'\fP an independent server of the current server is started. This is not a \fBSLAVE API\fP. The 'SELF' argument is replaced by an application default setting (if available) or by arguments set with \fBInit\fP 
.RE
.PP
.SS "MqLinkCreateChild (struct MqS *ctx, struct MqS *parent, struct MqBufferLS ** args)"
make a \fIcontext\fP to a \fIchild-context\fP ontop of an existing \fIparent-client-server-link\fP 
.PP
A child is using the same process or thread as the parent but a different namespace. With a different namespace a child is able to act on different services on the shared server. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIparent\fP the \fIparent-context\fP defined with \fBLinkCreate\fP 
.br
\fIargs\fP \fIcommand-line-arguments\fP to configure the \fIclient-server-link\fP without the \fB'@'\fP item.
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqLinkDelete(struct MqS *ctx)"
close the \fIclient-server-link\fP 
.PP
On a client the \fIcontext\fP will be set to \fInot-connected\fP and the function \fBLinkIsConnected\fP will return \fIMQ_NO\fP. On a server the \fIcontext\fP will be deleted but only if \fBignoreExit\fP is \fInot\fP set to \fIMQ_YES\fP. If the \fIlink\fP is already \fInot-connected\fP nothing will happen. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
.SS "struct MqS* MqLinkGetParent (struct MqS *ctx)"
get the \fIparent-context\fP from a client/server link 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIparent-context\fP or \fINULL\fP if not a \fIchild-context\fP 
.RE
.PP
.SS "MQ_SIZE MqLinkGetCtxId (struct MqS *ctx)"
get an identifier which is \fIunique\fP per \fIparent-or-child-context\fP 
.PP
The \fIcontext-identifier\fP is a number and is used in the protocol to link a \fIdata-package\fP to a \fIcontext-pointer\fP. This is necessary because the communication interface is shared between the \fIparent-context\fP and the \fIchild-context\fP. This number is \fIunique\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the identifier as number 
.RE
.PP
.SS "MQ_BOL MqLinkIsParent (struct MqS *ctx)"
is the \fIcontext\fP a \fIparent-context\fP? 
.PP
A \fIcontext\fP is a \fIparent-context\fP if it was created with \fBLinkCreate\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SS "MQ_BOL MqLinkIsConnected (struct MqS *ctx)"
is the context connected? 
.PP
A context is connected if the \fBLinkCreate\fP command was successful. A context is \fInot\fP connected if:
.IP "\(bu" 2
the context has just been created and not connected
.IP "\(bu" 2
the link was deleted with \fBLinkDelete\fP
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SH "SERVICE API"
.PP
\fBServiceIdentifier\fP
.br
 \fBServiceCallback\fP
.br
 \fBServiceGetToken\fP
.br
 \fBServiceIsTransaction\fP
.br
 \fBServiceGetFilter\fP
.br
 \fBServiceCreate\fP
.br
 \fBServiceDelete\fP
.br
 \fBProcessEvent\fP
.br
.PP
create and manage services 
.PP
To provide a \fIservice\fP is the main purpose of a server and the main-purpose of a \fIclient/server\fP connection is to call a service and to process the results. A service have to be defined on a server during \fIlink-setup\fP (\fBIServerSetup\fP) with the \fBServiceCreate\fP function. The cleanup is done implicit on \fIlink-delete\fP or explicit with the \fBServiceDelete\fP function. 
.PP
\fBExample:\fP define the service \fISRV1\fP on the \fIserver-link-setup\fP: 
.PP
.nf
 enum MqErrorE ServerSetup(struct MqS * msgque) { 
   MqErrorCheck(MqServiceCreate(msgque, 'SRV1', SRV1, NULL, NULL)); 
   return MQ_OK; 
 error: 
   return MqErrorStack(msgque->error); 
 } 

.fi
.PP
.SS "TOKEN IDENTIFIER"
The \fItoken\fP identifier is a 4 byte string and identifies the service. The \fItoken\fP is set by the programmer to identify different services. libmsgque is using some special \fItoken\fP for \fIinternal\fP or \fIcommon\fP usage:
.IP "\(bu" 2
\fB_???\fP - all \fItoken\fP starting with a \fB'_'\fP are for \fBinternal\fP usage only
.IP "\(bu" 2
\fB+ALL\fP - used in \fBServiceCreate\fP and \fBServiceDelete\fP to listen on \fBall\fP token not handled by other \fItoken\fP more precise
.IP "\(bu" 2
\fB-ALL\fP - used in \fBServiceDelete\fP to delete \fBall\fP token
.IP "\(bu" 2
\fB+FTR\fP - used for \fBONE-DIRECTIONAL FILTER\fP
.IP "\(bu" 2
\fB+EOF\fP - used for \fBONE-DIRECTIONAL FILTER\fP
.PP
.SS "SERVICE CALLBACK"
A service is using a callback to act on an incoming service request. The callback is linked to a \fBTOKEN IDENTIFIER\fP with \fBServiceCreate\fP or as argument to the \fBSendEND_AND_CALLBACK\fP function.
.PP
The callback is implemented as a set of functions and data suitable for \fBMqCallbackS\fP.
.SS "MQ_CST ServiceGetToken (ctx)"
get the \fBTOKEN IDENTIFIER\fP from an \fIongoing-service-call\fP 
.PP
This function is needed on the server to process a \fIservice-request\fP defined as \fI+ALL\fP or as an \fIalias\fP to extract the \fIcurrent\fP \fBTOKEN IDENTIFIER\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBTOKEN IDENTIFIER\fP 
.RE
.PP
.SS "int ServiceIsTransaction (ctx)"
check if the \fIongoing-service-call\fP belongs to a transaction 
.PP
A \fIservice-call\fP can be \fIwith-transaction\fP (return \fIMQ_YES\fP if the package was send with \fBSendEND_AND_WAIT\fP or \fBSendEND_AND_CALLBACK\fP) or can be \fIwithout-transaction\fP (return \fIMQ_NO\fP if the package was send with \fBSendEND\fP) 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SS "struct MqS* ServiceGetFilter(ctx, MQ_SIZE id, struct MqCtx **const filter)"
get the \fIfilter-context\fP or the \fImaster-context\fP 
.PP
A \fIfilter-pipeline\fP has two context, one on the left and one on the right. The \fIleft-context\fP is linked with the \fImaster-context\fP and the \fIright-context\fP is linked to the \fIslave-context\fP. This function extract the \fIother-context\fP related to the initial \fIctx\fP argument using the following order:
.IP "1." 4
return the \fImaster-context\fP if not NULL
.IP "2." 4
return the \fIslave-context\fP using \fIid\fP if not NULL
.IP "3." 4
return a 'filter not available' error
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIfilter\fP the \fIother-context\fP or \fINULL\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqServiceCreate(ctx,token,callback,data,fFree)"
create a link between a \fBTOKEN IDENTIFIER\fP and a \fBSERVICE CALLBACK\fP 
.PP
The \fItoken\fP have to be unique but the \fIcallback\fP not, this is called an \fIalias\fP. Use \fBMQ_CST ServiceGetToken (ctx)\fP to get the current token in an \fIincomming-service-call\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIcallback\fP the function to process the incoming \fIservice-request\fP 
.br
\fIdata\fP a user defined additional \fIdata-argument\fP for the \fIcallback\fP function (C-API only) 
.br
\fIdatafreeF\fP the function to free the \fIdata-argument\fP after use (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqServiceProxy(ctx,MQ_CST token, MQ_SIZE id=0)"
create a service to link a \fImaster-context\fP with a \fIslave-context\fP. 
.PP
This function is used to create a \fIproxy-service\fP to forward the \fIbody-data\fP from the \fIread-data-package\fP of the \fImaster\fP to the \fIsend-data-package\fP of the slave. The data is \fInot\fP changed. This function support the \fIreverse-operation\fP also. If the \fIctx\fP is a \fImaster-context\fP than the data is send to \fIslave\fP identified by \fIid\fP. If the \fIctx\fP is a \fIslave-context\fP than the data is send to the \fImaster\fP of the \fIslave\fP. Use \fIid=0\fP to send that data to the \fIfilter-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIid\fP the slave identifier, only used if \fIctx\fP is a \fImaster-context\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqServiceDelete(ctx,MQ_CST token)"
delete a service. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqProcessEvent(ctx,MQ_TIME_T timeout,MQ_WAIT_(NO|ONCE|FOREVER))"
enter the \fIevent-loop\fP and wait for an incoming \fIservice-request\fP. 
.PP
This function is used to enter the \fIevent-loop\fP and start listen on open \fIfile-handles\fP and to call \fBIEvent\fP on idle. The third argument \fIwait\fP support three modes to define the \fIoperation-mode\fP:
.IP "\(bu" 2
\fB\fBMQ_WAIT_NO\fP\fP, don't wait for an event just do the check and comeback. if an Event is available process the event, but only one. If no Event is available return with \fBMQ_CONTINUE\fP.
.IP "\(bu" 2
\fB\fBMQ_WAIT_ONCE\fP\fP, wait maximum \fItimeout\fP seconds for only \fIone\fP event or raise a \fItimeout\fP error if no event was found.
.IP "\(bu" 2
\fB\fBMQ_WAIT_FOREVER\fP\fP, wait forever and only come back on \fIerror\fP or on \fIexit\fP.
.PP
This function is usually used on a server to enter the \fIevent-loop\fP and wait for incoming service requests or after the \fBSendEND_AND_CALLBACK\fP function to wait for the \fIservice-result\fP.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItimeout\fP seconds until a \fItimeout-error\fP is raised (default: \fBcommand-line: --timeout\fP value), only used if \fIwait\fP = \fBMQ_WAIT_ONCE\fP 
.br
\fIwait\fP chose the \fItime-interval\fP to wait for a new event (default: \fBMQ_WAIT_NO\fP) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SH "SEND API"
.PP
\fBSendSTART\fP
.br
 \fBSendEND\fP
.br
 \fBSendEND_AND_WAIT\fP
.br
 \fBSendEND_AND_CALLBACK\fP
.br
 \fBSendRETURN\fP
.br
 \fBSendERROR\fP
.br
 \fBSendTYPE\fP
.br
 \fBSendN\fP
.br
 \fBSendBDY\fP
.br
 \fBSendL_START\fP
.br
 \fBSendL_END\fP
.br
.PP
construct an outgoing \fIsend-data-package\fP. 
.PP
\fISending\fP data is an active task and the opposite of \fIreading\fP data which is an passive task. Active mean that the \fIsend\fP is triggered by the software-work-flow or the user. There is one \fIsend\fP function for every basic type defined in \fBTYPE IDENTIFIER\fP plus a couple of help functions. 
.PP
\fBAttention:\fP
.RS 4
Sending data is an atomic task and should not be split. Only one \fIsend-data-package\fP is always in duty. As basic rule do the processing first and send all the data afterwards. If the function \fBSendEND_AND_WAIT\fP is used the application enter the event-loop and is still able to work on other client/server links. 
.RE
.PP
 \fBExample:\fP send an integer and a list of double, string and a \fIbyte-array\fP: 
.PP
.nf
 SendSTART(ctx);
 MqSendI(ctx,num);
 MqSendL_START(ctx);
   MqSendD(ctx,balance);
   MqSendC(ctx,'name of the owner');
   MqSendB(ctx,signature);
 MqSendL_END(ctx);
 MqErrorCheck(MqSendEND_AND_WAIT(ctx,'SRV1',MQ_TIMEOUT_USER));

.fi
.PP
.SS "MqSendSTART(ctx)"
initialize the \fIsend-data-package\fP. 
.PP
This function have to be the first statement in a \fIsend-data-block\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendEND(ctx,MQ_CST token)"
finish the \fIsend-data-block\fP, call the remote service and do \fInot\fP expect a return. 
.PP
If an \fBerror\fP is raised on the server during the service-processing the error is send back as \fIasynchronous-error-event\fP and will be raised during the next enter into the event-loop. Use \fBIBgError\fP to control the \fIasynchronous-error-event\fP processing. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendEND_AND_WAIT(ctx,token,?timeout=MQ_TIMEOUT_USER?)"
finish the \fIsend-data-block\fP, call the remote service and do \fIwait\fP for return. 
.PP
If an \fBerror\fP is raised on the server during the service-processing the function will return this error immediately. During waiting for the return the \fIevent-loop\fP is used to process other events. Use \fBIEvent\fP to add your tasks into the event loop. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fItimeout\fP seconds until a \fItimeout-error\fP is raised 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendEND_AND_CALLBACK(ctx,token,fCallback,data,fFree)"
finish the \fIsend-data-block\fP, call the remote service and do \fInot-wait\fP for return. 
.PP
This function will \fInever\fP block and return immediately. If \fIreturn-data\fP or an error is available the \fIcallback-function\fP is called for processing. Use \fBMqProcessEvent(ctx,MQ_TIME_T timeout,MQ_WAIT_(NO|ONCE|FOREVER))\fP to enter the \fIevent-loop\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIcallback\fP the function to process the \fIservice-call\fP results 
.br
\fIdata\fP a user defined additional \fIdata-argument\fP for the \fIcallback\fP function (C-API only) 
.br
\fIdatafreeF\fP the function to free the \fIdata-argument\fP after use (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendRETURN(ctx)"
finish the \fIsend-data-block\fP on the server and optional return the results. 
.PP
Every \fIservice-handler\fP have to use this function at the end to return the results or the error. If an \fIerror\fP is returned the local \fIerror-object\fP is reset. If no results have to be returned (\fBMqSendEND(ctx,MQ_CST token)\fP)
.IP "\(bu" 2
if a transaction is ongoing this function return the answer.
.IP "\(bu" 2
if the answer is an empty package no previous \fBMqSendSTART\fP is required.
.IP "\(bu" 2
if no transaction is ongoing this function does just return the error code.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendERROR(ctx)"
send the data from the \fBEXCEPTION OBJECT\fP to the link target . 
.PP
If an error is available the \fIerror-number\fP and the \fIerror-text\fP is send to the link target. After send the error is reset. This function only raise an error if the sending self fails. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendTYPE(ctx,value)"
append a native \fBTYPE IDENTIFIER\fP value to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIvalue\fP the value for appending 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendN(ctx,MQ_BIN value,MQ_SIZE len)"
append a \fIbody-item\fP to the \fIsend-data-package\fP. 
.PP
A \fIbody-item\fP is a \fIbyte-array\fP and including the \fIitem-size\fP, \fIitem-type\fP and the \fIitem-data\fP as value. The \fIbody-item\fP is the result of a previous \fBMqReadN(ctx,MQ_BIN *value, MQ_SIZE *len)\fP function call and can be used for saving into an external storage or for an additional operation like encryption. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIvalue\fP the \fIbody-item\fP for appending 
.br
\fIlen\fP the size of the \fIbody-item-byte-array\fP (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendBDY(ctx,MQ_BIN value,MQ_SIZE len)"
append the \fIentire-body\fP to the \fIsend-data-package\fP. 
.PP
The \fIentire-body\fP is a \fIbyte-array\fP and including the \fInumber-of-items\fP and the \fIbody-items\fP as value. The \fIentire-body\fP is the result of a previous \fBMqReadBDY(ctx,MQ_BIN *value, MQ_SIZE *len)\fP function call and can be used for saving into an external storage or for an additional operation like encryption. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIvalue\fP the \fIentire-body\fP for appending 
.br
\fIlen\fP the size of the \fIentire-body-byte-array\fP (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendL_START(ctx)"
start to append an embedded \fIbody-list-item\fP to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqSendL_END(ctx)"
finish to append an embedded \fIbody-list-item\fP to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SH "READ API"
.PP
\fBReadTYPE\fP
.br
 \fBReadN\fP
.br
 \fBReadBDY\fP
.br
 \fBReadU\fP
.br
 \fBReadL_START\fP
.br
 \fBReadL_END\fP
.br
 \fBReadProxy\fP
.br
 \fBReadGetNumItems\fP
.br
 \fBReadItemExists\fP
.br
 \fBReadUndo\fP
.br
.PP
extract data from an incoming \fIread-data-package\fP. 
.PP
\fIReading\fP data is a passive task and the opposite of \fIsending\fP data which is an active task. Passive mean that the \fIread\fP is triggered by an incoming data-package and not by the software-work-flow or the user. There is one \fIread\fP function for every basic type defined in \fBTYPE IDENTIFIER\fP plus a couple of help functions. 
.PP
\fBAttention:\fP
.RS 4
Reading data is an atomic task and should not be split. Only one \fIread-data-package\fP is always in duty. As basic rule read first all data and start the processing afterwards. 
.RE
.PP
 \fBExample:\fP read an integer and a list of double, string and a \fIbyte-array\fP: 
.PP
.nf
 MqErrorCheck(MqReadI(ctx, &i));
 MqErrorCheck(MqReadL_START(ctx, NULL));
   MqErrorCheck(MqReadD(ctx, &balance));
   MqErrorCheck(MqReadC(ctx, &owner));
   MqErrorCheck(MqReadB(ctx, &signature));
 MqReadL_END(ctx);

.fi
.PP
.SS "MqReadTYPE(ctx, TYPE *val)"
read a \fBTYPE IDENTIFIER\fP from the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIval\fP the value to read 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadN(ctx,MQ_BIN *value, MQ_SIZE *len)"
extract a \fIbody-item\fP from the \fIread-data-package\fP 
.PP
A \fIbody-item\fP is a \fIbyte-array\fP with a defined \fIlength\fP and including the \fIsize\fP, \fIdata-type\fP and the \fInative\fP data object as information. The \fIitem\fP extracted can be saved into an external storage and be send later using \fBSendN\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIval\fP the \fIbody-item\fP as \fIbyte-array\fP 
.br
\fIlen\fP the \fIbyte-array-length\fP of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadBDY(ctx,MQ_BIN *value, MQ_SIZE *len)"
extract the entire \fIbody-package\fP from the \fIread-data-package\fP 
.PP
A \fIbody\fP is a \fIbyte-array\fP with a defined \fIlength\fP and including the \fInumber-of-items\fP and the \fIbody-items\fP as information. The \fIbody\fP extracted can be saved into an external storage or be used in a software tunnel (example: the \fIagurad\fP tool) and be send later using \fBSendBDY\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIval\fP the \fIbody\fP as \fIbyte-array\fP 
.br
\fIlen\fP the \fIbyte-array-length\fP of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadU(ctx)"
extract a \fBtemporary\fP \fBBUFFER API\fP from the \fIread-data-package\fP 
.PP
The object returned is owned by the \fIread-data-package\fP and is \fBonly\fP valid up to the next call of any \fBREAD API\fP function. If a long-term object is required use the C-API function: \fBMqBufferDup\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIval\fP the buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadL_START(ctx, struct MqBufferS buffer=NULL)"
start to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
Initialize the read with the current \fIbody-item\fP or an optional \fIbuffer-object\fP. This command requires a final \fBMqReadL_END(ctx)\fP to finish the read. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.br
\fIbuffer\fP an optional \fIbuffer-object\fP as result from a previous \fBMqReadU(ctx)\fP call or \fINULL\fP to use the next item from the \fIread-data-package\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadL_END(ctx)"
finish start to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MqReadProxy(ctx, struct MqS *otherCtx)"
link two \fIcontext-objects\fP to direct pass a data item from one object to the other. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP and the source of the copy 
.br
\fIotherCtx\fP the \fIother-context-object\fP and the target of the copy 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SS "MQ_SIZE MqReadGetNumItems(ctx)"
get the number of items left in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of items as integer 
.RE
.PP
.SS "MQ_BOL MqReadItemExists(ctx)"
check if an item exists in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
boolean, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SS "MqReadUndo(ctx)"
undo the last \fBREAD API\fP function call 
.PP
Put the internal position-pointer to the start of the last read \fIbody-item\fP. The next read function call will extract the same item again. Only \fBone\fP undo level is supported. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.SH "SLAVE API"
.PP
\fBSlaveWorker\fP
.br
 \fBSlaveCreate\fP
.br
 \fBSlaveDelete\fP
.br
 \fBSlaveGet\fP
.br
 \fBSlaveGetMaster\fP
.br
 \fBSlaveIs\fP
.br
.PP
The \fImaster-slave-link\fP is used to create a mesh of nodes defined by different \fIparent-context\fP. \fBThe master control the slave.\fP
.PP
The \fImaster-slave-link\fP is used to perform the following tasks:
.IP "\(bu" 2
report error messages from the \fIslave-context\fP to the \fImaster-context\fP 
.IP "\(bu" 2
to create a \fIslave-child-context\fP if a \fImaster-child-context\fP is created
.IP "\(bu" 2
to delete a \fIslave-context\fP if a \fImaster-context\fP is deleted
.PP
In difference to the \fIclient-server-link\fP the \fImaster-slave-link\fP connect two independent \fIparent-context\fP in the same process or thread (e.g. node). This leads to the restriction that only the \fImaster-context\fP can be a \fIserver-context\fP because only one \fIserver-context\fP per node is possible.
.PP
.PP
.nf

    node-0   |           node-1/2        |   node-3/4/5
===================================================================

| <- client/server link -> | <- client/server link -> |

             | <-- master/slave link --> |

                           |- client1-0 -|- server3 ...
             |-  server1  -|             
             |             |- client1-1 -|- server4 ...
  client0-0 -|                           
             |-  server2  -|- client1-2 -|- server5 ...
.fi
.PP
 
.SS "MqSlaveWorker(ctx, MQ_SIZE id, struct MqBufferLS **argv)"
create a \fImaster/slave\fP link using the image of the \fIctx\fP object self. 
.PP
The slave-context is started as an independent process or thread based on the \fBstartAs\fP argument. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIargs\fP command-line arguments passed to the \fIworker-client\fP or the \fIworker-server\fP. all arguments prior the first \fB@\fP token are added to the \fIworker-client\fP and the other arguments to the \fIworker-server\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
.PP
\fBexample\fP create a worker with id 7 and name 'MyWorker' as thread. 
.PP
.nf
 MqErrorCheck(MqSlaveWorker (ctx, 7,
    MqBufferLCreateArgsV(ctx, '--thread', '--silent', '@', '--name', 'MyWorker', NULL)
 );

.fi
.PP
.SS "MqSlaveCreate(ctx, MQ_SIZE id, struct MqS *slaveCtx)"
create a \fImaster/slave\fP link between the master-context object and the slave-context object 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIslave\fP the \fIslave\fP context object as CLIENT-PARENT without a CHILD 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
The \fIslave-context\fP is owned by the \fImaster-context\fP. This mean that no other external references should be used and the \fIslave-context\fP will be deleted if the \fImaster-context\fP is be deleted. 
.RE
.PP
.SS "MqSlaveDelete(ctx, MQ_SIZE id)"
Delete a \fIslave\fP object from a \fImaster/slave\fP link identified by \fIid\fP. 
.PP
By default the \fIslave-context\fP object will be deleted if the \fImaster-context\fP is deleted. Use this function to delete the \fIparent-slave-context\fP explicit and brake the \fImaster/slave\fP link. If \fIid\fP is invalid nothing will happen. It is an \fIerror\fP to delete a \fIchild-slave-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBEXCEPTION OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
it is still possible to delete a \fIchild-slave-context\fP using \fBLinkDelete\fP but this will break the internal master/slave order. 
.RE
.PP
.SS "MqSlaveGet(ctx, MQ_SIZE id)"
get the \fIslave-context\fP from a \fImaster-context\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIslave-context\fP or \fCNULL\fP if \fIid\fP is not valid or \fIcontext\fP is not a \fImaster-context\fP. 
.RE
.PP
.SS "MqSlaveGetMaster(ctx)"
get the \fImaster-context\fP from the \fIslave-context\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fImaster-context\fP or \fINULL\fP if the \fIcontext\fP is no \fIslave-context\fP 
.RE
.PP
.SS "MqSlaveIs(ctx)"
is the \fIcontext\fP a \fIslave-context\fP ? 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBstruct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SH "BUFFER API"
.PP
\fBBufferIdentifer\fP
.br
 \fBBufferGetTYPE\fP
.br
 \fBBufferType\fP
.br
.PP
a single object to store a \fInative-type-data-item\fP defined by \fBTYPE IDENTIFIER\fP 
.PP
The \fIbuffer-object\fP is returned by \fBReadU\fP and is used to save a \fItypeless-temporary-data-item\fP from the \fIread-data-package\fP. The lifetime of the \fIbuffer-object\fP is only the current callback up to the next read operation in the same \fIparent-context\fP. 
.PP
\fBExample:\fP read a \fIbuffer-object\fP and check for \fIstring-type\fP. 
.PP
.nf
 MQ_BUF buf = MqReadU(ctx); 
 if (buf->type == MQ_STRT) 
   printf(buf->cur.C); 

.fi
.PP
.SS "TYPE IDENTIFIER"
a collection of all \fInative-data-types\fP supported 
.PP
The \fItype-identifier\fP (TYPE) is a \fIone-character-value\fP (Y,O,S,I,W,F,D,B,C,L,U) for every \fInative-data-type\fP supported. A \fIbuffer-data-package\fP is type safe, this mean that every item has a \fItype-prefix\fP and every \fBReadTYPE\fP or \fBBufferGetTYPE\fP have to match the previous \fBSendTYPE\fP with the same \fITYPE\fP. One exception is allowed, the cast from and to the \fBMQ_CST\fP datatype (TYPE=C) is allowed. The following type identifier's are available:
.IP "\(bu" 2
\fCY\fP : 1 byte signed character (\fBMQ_BYT\fP)
.IP "\(bu" 2
\fCO\fP : 1 byte boolean value using \fIMQ_YES\fP or \fIMQ_NO\fP (\fBMQ_BOL\fP)
.IP "\(bu" 2
\fCS\fP : 2 byte signed short (\fBMQ_SRT\fP)
.IP "\(bu" 2
\fCI\fP : 4 byte signed integer (\fBMQ_INT\fP)
.IP "\(bu" 2
\fCW\fP : 8 byte signed long long integer (\fBMQ_WID\fP)
.IP "\(bu" 2
\fCF\fP : 4 byte float (\fBMQ_FLT\fP)
.IP "\(bu" 2
\fCD\fP : 8 byte double (\fBMQ_DBL\fP)
.IP "\(bu" 2
\fCB\fP : unsigned char array used for binary data (\fBMQ_BIN\fP)
.IP "\(bu" 2
\fCC\fP : string data using a \fC\\0\fP at the end (\fBMQ_CST\fP)
.IP "\(bu" 2
\fCL\fP : list type able to hold a list of all items from above
.IP "\(bu" 2
\fCU\fP : typeless buffer able to hold a single item from above (\fBMQ_BUF\fP)
.PP
.SS "TYPE MqBufferGetTYPE(MQ_BUF buffer)"
return the data form the buffer using the \fBTYPE IDENTIFIER\fP. (on error return an \fBEXCEPTION OBJECT\fP)
.SS "buffer->type"
return the type as single character of the item stored in the buffer object.
.SH "EXCEPTION OBJECT"
.PP
\fBErrorGetText\fP
.br
 \fBErrorGetNum\fP
.br
 \fBErrorC\fP
.br
 \fBErrorSet\fP
.br
 \fBErrorSetCONTINUE\fP
.br
 \fBErrorReset\fP
.br
 \fBErrorRaise\fP
.br
 \fBErrorPrint\fP
.br
.PP
The exception object is used to transport a libmsgque error using the \fIctx\fP.
.PP
\fBExample:\fP catch an error and write the message to stdout: 
.PP
.nf
 if (MqErrorCheckI(MqReadI(ctx, &i))) { 
  printf(MqErrorGetText(ctx)); 
  MqErrorReset(ctx); 
 } 

.fi
.PP
.SS "MQ_CST MqErrorGetText(ctx)"
return the error message from the error object.
.SS "MQ_INT MqErrorGetNum(ctx)"
return the error number from the error object. The number can be used as exit-code.
.SS "MqErrorC(ctx,MQ_CST prefix, MQ_INT errnum, MQ_CST message)"
create a libmsgque error object but do \fBnot\fP raise the \fBEXCEPTION OBJECT\fP
.SS "MqErrorSet(ctx,MQ_INT errnum,enum MqErrorE errorcode,MQ_CST message)"
convert a \fIctx\fP into a libmsgque conform error using the \fIctx\fP object. This method is used to enable additional error processing capabilities from \fBLinkDelete\fP or \fBExit\fP after the exception was caught and before the application exit or the object is deleted.
.SS "MqErrorSetCONTINUE(ctx)"
set \fBMqErrorS::code\fP to \fBMQ_CONTINUE\fP and return the value 
.SS "MqErrorReset(ctx)"
clear the libmsgque error object.
.SS "MqErrorRaise(ctx)"
convert and raise an libmsgque error object into a C \fBEXCEPTION OBJECT\fP.
.SS "MqErrorPrint(ctx)"
print an libmsgque error object to stderr and \fIclear\fP the libmsgque error
.SH "FILTER MODE"
.PP
The filter mode is related to a special usage of the libmsgque software called a command pipeline. To define a filter create a \fIserver\fP with \fBisServer\fP or use \fBIServerSetup\fP and add the required services.
.SS "ONE-DIRECTIONAL FILTER"
A one-directional filter has a \fIdata-flow\fP from the \fIleft\fP to the \fIright\fP and is well known from the \fBunix\fP shell to link different commands together: 
.PP
.nf

    command1 | command2 | command3

.fi
.PP
 A libmsgque command pipeline is created with the special character \fB@\fP instead of \fB\fP| : 
.PP
.nf

    msgcmd1 @ msgcmd2 @ msgcmd3

.fi
.PP
 with every command have to use \fBlibmsgque\fP. To define a libmsgque filter create a service handle with \fBServiceCreate\fP or \fBServiceProxy\fP for the both special token:
.IP "\(bu" 2
\fB+FTR\fP : required to act on filter data rows. Every filter input data is a list of filter data rows and every row is a list of filter data columns. Every row is send to the following filter-command as \fB+FTR\fP service request.
.IP "\(bu" 2
\fB+EOF\fP : required to act on End-Of-Filter data and is called after all \fB+FTR\fP data was send. Sometimes the filter data can not be served as \fB+FTR\fP data (example: sorting of the input rows need to read all rows before the data can be send to the next filter command) and the \fB+EOF\fP token is used to continue send \fB+FTR\fP data rows.
.PP
and send every data item with \fBSendEND_AND_WAIT\fP.
.SS "BI-DIRECTIONAL FILTER"
A bi-directional filter has a \fIdata-flow\fP in both directions and is used in a \fIclassical\fP client/server application: 
.PP
.nf

    client ... <--> ... server

.fi
.PP
 to add an additional feature like a protocol-tunnelling: 
.PP
.nf

    client @ mq2tunnel ... <--> ... tunnel2mq @ server

.fi
.PP
 or to convert the protocol into an other protocol: 
.PP
.nf

    client @ mq2soap ... <--> ... soap-server

.fi
.PP
 To define a \fIbi-directional\fP filter a couple of commands provide support:
.IP "\(bu" 2
\fBServiceCreate\fP : use the token \fB+ALL\fP to act on \fIall\fP services
.IP "\(bu" 2
\fBServiceGetFilter\fP: to get the filter context (other site)
.IP "\(bu" 2
\fBServiceGetToken\fP: to get the current token
.IP "\(bu" 2
\fBServiceIsTransaction\fP : to check if a transaction is ongoing
.IP "\(bu" 2
\fBReadBDY\fP : to read the entire body as \fIbyte-array\fP 
.IP "\(bu" 2
\fBSendBDY\fP : to send the entire body
.PP
.SH "PORTABILITY ISSUES"
.PP
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc processor or i686 processor from the VritualBox emulator.
.SH "EXAMPLES"
.PP
.SS "1. create a server to multiplicate 2 double values and return the result"
.PP
.nf

#include 'string.h'
#include 'msgque.h'
static enum MqErrorE  MMUL( struct MqS *ctx, MQ_PTR data) {
  MQ_DBL d1,d2;
  MqErrorCheck (MqSendSTART(ctx));
  MqErrorCheck (MqReadD(ctx, &d1));
  MqErrorCheck (MqReadD(ctx, &d2));
  MqErrorCheck (MqSendD(ctx, d1*d2));
error:
  return MqSendRETURN(ctx);
}
static enum MqErrorE ServerSetup (struct MqS *ctx, MQ_PTR data) {
  return MqServiceCreate(ctx,'MMUL', MMUL, NULL, NULL);
}
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MqConfigSetName (ctx, 'MyMulServer');
  MqConfigSetServerSetup (ctx, ServerSetup, NULL, NULL, NULL);
  MqConfigSetDefaultFactory (ctx);
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqErrorCheck (MqProcessEvent(ctx,MQ_TIMEOUT,MQ_WAIT_FOREVER));
error:
  MqExit(ctx);
}
.fi
.PP
 Start \fImulserver.c\fP using \fITCP\fP port \fI7777\fP and create a \fIthread\fP for every incoming connection 
.PP
.nf

> mulserver --tcp --port 7777 --thread

.fi
.PP
.SS "2. in a client call the service from 1."
.PP
.nf

#include 'string.h'
#include 'msgque.h'
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MQ_DBL d;
  MqConfigSetName (ctx, 'MyMul');
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqSendSTART(ctx);
  MqSendD(ctx,3.67);
  MqSendD(ctx,22.3);
  MqSendEND_AND_WAIT(ctx, 'MMUL', 10);
  MqErrorCheck (MqReadD(ctx, &d));
  printf('%f\n', d);
error:
  MqExit(ctx);
}
.fi
.PP
 Use \fImulclient.c\fP to connect to \fImulserver.c\fP using \fITCP\fP port \fI7777\fP: 
.PP
.nf

> mulclient --tcp --port 7777

.fi
.PP
.SS "3. create a filter to wrap every column in a '<>' pair"
.PP
.nf

#include 'string.h'
#include 'msgque.h'
static enum MqErrorE  FTR( struct MqS *ctx, MQ_PTR data) {
  MQ_CST str;
  struct MqS * ftr;
  MqErrorCheck (MqServiceGetFilter (ctx, 0, &ftr));
  MqSendSTART(ftr);
  while (MqReadItemExists(ctx)) {
    MqErrorCheck (MqReadC(ctx, &str));
    MqBufferSetV(ctx->temp,'<%s>', str);
    MqSendU(ftr, ctx->temp);
  }
  MqErrorCheck (MqSendEND_AND_WAIT(ftr, '+FTR', MQ_TIMEOUT_USER));
error:
  return MqSendRETURN (ctx);
}
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MqConfigSetName (ctx, 'ManFilter');
  MqConfigSetDefaultFactory (ctx);
  MqConfigSetIsServer (ctx, MQ_YES);
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqServiceCreate (ctx, '+FTR', FTR, NULL, NULL));
  MqErrorCheck (MqServiceProxy  (ctx, '+EOF', 0));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqErrorCheck (MqProcessEvent(ctx,MQ_TIMEOUT,MQ_WAIT_FOREVER));
error:
  MqExit(ctx);
}
.fi
.PP
 Use \fImanfilter.c\fP in a LibMsgque command pipeline: 
.PP
.nf

> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :

.fi
.PP
.SH "SEE ALSO"
.PP
C, C: libmsgque(n), C++: ccmsgque(n), C#: csmsgque(n), JAVA: javamsgque(n), PYTHON: pymsgque(n), TCL: tclmsgque(n), PERL: perlmsgque(n), VB.NET: vbmsgque(n)
.SH "KEYWORDS"
.PP
C, unix, socket, message, msgque 
.SH "Author"
.PP 
Generated automatically by Doxygen for libmsgque from the source code.
