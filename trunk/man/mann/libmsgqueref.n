.TH "libmsgque" n "Tue Jan 11 2011" "Version 4.8" "libmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
libmsgque \- The \fBC\fP \fBApplication-Server\fP and \fBProgramming-Language-Micro-Kernel\fP Project
.SH "SYNOPSIS"
.PP
\fB#include 'msgque.h'\fP
.SH "INDEX"
.PP
\fBCONTEXT API\fP
.br
 \fBFACTORY API\fP
.br
 \fBCONFIG API\fP
.br
 \fBLINK API\fP
.br
 \fBSERVICE API\fP
.br
 \fBSEND API\fP
.br
 \fBREAD API\fP
.br
 \fBSLAVE API\fP
.br
 \fBBUFFER API\fP
.br
 \fBERROR OBJECT\fP
.br
 \fBBINARY OBJECT\fP
.br
 \fBFILTER MODE\fP
.br
 \fBCONTEXT LOCAL STORAGE API\fP
.SH "INTRODUCTION"
.PP
public libmsgque API 
.PP
The msgque project is an infrastructure to link software together to act like a single software. To link mean distributing work from one software to an other software an wait or not wait for an answer. The linking is done using unix or inet domain sockets and is based on packages send from one software to an other software and back. The msgque project is used to handle all the different aspects for setup and maintain the link and is responsible for:
.IP "\(bu" 2
starting and stopping the server application
.IP "\(bu" 2
starting and stopping the communication interface
.IP "\(bu" 2
sending and receiving package data
.IP "\(bu" 2
reading and writing data from or into a package
.IP "\(bu" 2
setup and maintain the event-handling for an asynchronous transfer
.IP "\(bu" 2
propagate the error messages from the server to the client
.PP
.SH "CONTEXT API"
.PP
\fBMqContextCreate\fP
.br
 \fBMqContextDelete\fP
.br
 \fBMqExit\fP
.br
 \fBMqLogC\fP
.br
 \fBMqLogV\fP
.br
 \fBMqLogVL\fP
.br
 \fIcontext\fP, the top-level data structure and \fIapplication-handle\fP 
.PP
The \fIcontext-data-structure\fP is created with \fBMqContextCreate\fP and deleted with \fBMqContextDelete\fP. The structure has a \fIlibmsgque-specific-part\fP and an \fIapplication-specific-part\fP. Both parts are linked together. The \fIlibmsgque-specific-part\fP has all data required to manage a \fIclient-server-link\fP. The \fIapplication-specific-part\fP as all data required by the application. The following C-API example demonstrate the layout of the \fIcontext-data-structure\fP. 
.PP
.nf
 struct MyCtxDataS {
   struct MqS  mqctx;   // libmsgque-specific-data
   int         mydata;  // application-specific-data
   ...                  // application-specific-data
 };

.fi
.PP
 The \fIlibmsgque-specific-data\fP have to be the \fIfirst\fP data entry in the structure.
.br
 A \fIhigh-level-programming-language\fP like JAVA, C#, C++, Perl, Python, Ruby, Tcl or VB-NET is using a wrapper around this \fIdata-structure\fP as \fIapplication-handle\fP. The \fIapplication-specific-data\fP is available as \fBCONTEXT LOCAL STORAGE API\fP 
.SS "struct MqS* MqContextCreate(MQ_SIZE size, struct MqS const * const tmpl)"
C-API: \fBMqContextCreate\fP, create a new context and initialize the default configuration data 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP (C-API) the number of bytes in the \fIcontext-data-structure\fP as returned by \fCsizeof(struct MyCtxDataS)\fP (default: \fI0\fP, use only \fIlibmsgque-specific-data\fP and no \fIapplication-specific-data\fP) 
.br
\fItmpl\fP (C-API) an other \fIcontext-data-structure\fP used as template to initialize the configuration data. This template is used for a \fIchild\fP to get the configuration data from the \fIparent\fP. (default: \fINULL\fP, create an initial context) 
.RE
.PP
\fBReturns:\fP
.RS 4
the new \fIcontext\fP, no error return because this function \fIpanic\fP on \fIout-of-memory-error\fP 
.RE
.PP
.PP
\fBExample:\fP create an \fIapplication-context\fP with \fImydata\fP as \fIapplication-specific-data\fP: 
.PP
.nf
 struct MyCtxDataS { 
   struct MqS mqctx; 
   int mydata; 
 }; 
 struct MqS * const ctx = MqContextCreate(sizeof(struct MyCtxDataS), NULL); 

.fi
.PP
.SS "MqContextDelete(struct MqS ** ctx)"
C-API: \fBMqContextDelete\fP, delete the \fBMqS\fP object and \fBall\fP depending data including the \fItoplevel\fP object self 
.PP
Shutdown the \fIclient-server-link\fP, free the memory and set the \fIctx\fP to \fINULL\fP. The \fIcontext\fP can \fBnot\fP be reused. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
.SS "MqExit(struct MqS* ctx)"
C-API: \fBMqExitP\fP, delete the \fIcontext\fP and exit the current process or thread 
.PP
To delete an application is a difficult task because the \fIlink-target\fP have to be informed. This information is send as \fIshutdown-event\fP and finally as \fIsocket-exit\fP after \fIapplication-exit\fP. This library tries to perform this two steps even if the default \fBexit\fP function is called. This is no problem because the second step (\fIsocket-exit\fP) is enough to signal a \fIlink-down\fP. It is \fBnot\fP secure to depend only on \fIsocket-exit\fP for application exit because sometimes the sockets stop working or the \fIlink-target\fP does not get a \fIsocket-exit\fP. For example the \fIpipe-link\fP on windows. The client can not exit and create a \fIsocket-exit\fP error on the \fIserver\fP because the \fIserver\fP is still running without receiving a \fIshutdown-event\fP. A second argument for using the \fBMqExit\fP function is, that it can be used for process \fBand\fP thread exit. A thread, started by \fBlibmsgque\fP, does exit but the process continue to work. To make it short use \fBMqExit\fP to exit your application. 
.PP
\fBParameters:\fP
.RS 4
\fIprefix\fP identify the caller (\fBMqExitP\fP only) 
.br
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
.SS "MqLogC(struct MqS* ctx, MQ_CST const prefix, MQ_INT level, MQ_CST const message)"
C-API: \fBMqLogC\fP, write a logging-message to stderr using the internal format 
.PP
The logging is only done if '\fC\fBdebug\fP >= level\fP' and '\fC\fBisSilent\fP == \fIMQ_NO\fP'\fP using the following format: 
.PP
.nf

C> (NAME:PID:THREADID) [YYYY-MM-DD:HH-MM-SS] [DEBUGLEVEL-CONTEXTID-REFCOUNT-CONTEXTPTR-prefix]: message

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIprefix\fP used to identify the calling function or the environment 
.br
\fIlevel\fP debug level: 0 <= level <= 9 
.br
\fImessage\fP string to log to stderr 
.RE
.PP
 
.SS "MqLogV(struct MqS* ctx, MQ_CST const prefix, MQ_INT level, MQ_CST fmt, ...)"
C-API: \fBMqLogV\fP, write a \fIprintf\fP style logging-message to stderr using the internal format 
.PP
Use the format and the restrictions from \fBMqLogC\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIprefix\fP used to identify the calling function or the environment 
.br
\fIlevel\fP debug level: 0 <= level <= 9 
.br
\fIfmt\fP a \fBprintf\fP like format string 
.RE
.PP
 
.SS "MqLogVL(struct MqS* ctx, MQ_CST const prefix, MQ_INT level, MQ_CST const fmt, va_list var_list)"
C-API: \fBMqLogVL\fP, write a \fIvprintf\fP style logging-message to stderr using the internal format 
.PP
Use the format and the restrictions from \fBMqLogC\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIprefix\fP used to identify the calling function or the environment 
.br
\fIlevel\fP debug level: 0 <= level <= 9 
.br
\fIfmt\fP a \fBprintf\fP like format string 
.br
\fIvar_list\fP a variable argument list object 
.RE
.PP
.SH "FACTORY API"
.PP
\fBMqFactoryDefault\fP
.br
 \fBMqFactoryDefaultIdent\fP
.br
 \fBMqFactoryAdd\fP
.br
 \fBMqFactoryNew\fP
.br
 \fBMqFactoryCall\fP
.br
 \fBMqFactoryCtxIdentSet\fP
.br
 \fBMqFactoryCtxIdentGet\fP
.br
 \fBMqFactoryCtxDefaultSet\fP
.br
.PP
provide an interface to create a new instance 
.PP
The \fIfactory\fP is an important part of the object management and has the following basic features:
.IP "1." 4
create a new instance identified by an \fIidentifier\fP or using an already available instance as template
.IP "2." 4
cleanup and delete an instance
.IP "3." 4
provide an \fIidentifier\fP for factory lookup and as an unique application name
.IP "4." 4
identify the server in the network available as \fBMqLinkGetTargetIdent\fP on a remote context
.PP
The link between the \fIFactory-Identifier\fP and the \fIFactory-Interface\fP is important for the future development of \fBlibmsgque\fP. \fIMessage-Routing\fP, \fIService-Location\fP and \fIPersistent-Transactions\fP depend on this feature.
.PP
The relationship between the \fBMqFactoryS\fP and the \fBMqS\fP is the same as the relationship between a \fItype\fP and an \fIinstance\fP of the \fItype\fP in a regular programming language. The \fBMqFactoryS\fP define the \fItype\fP of the server and the \fBMqS\fP define a single instance of the server. Every kind of server has \fBonly one\fP specific \fBMqFactoryS\fP object but every instance of a server has one \fBMqS\fP object used for object management. Decreasing the size and the complexity of a \fBMqS\fP object will improve the server performance. In future more fields, defined in the \fBMqSetupS\fP attribute of the the \fBMqS\fP object, will move into \fBMqFactoryS\fP object. 
.SS "MqFactoryDefault(MQ_CST ident, interface...)"
C-API: \fBMqFactoryDefault\fP, add a new \fIdefault-factory-interface\fP identified by \fIident\fP 
.PP
The default factory is always used to create an instance if no other factory is available 
.PP
\fBParameters:\fP
.RS 4
\fIident\fP factory identifier 
.br
\fIcreateCallF\fP (C-API) instance constructor function 
.br
\fIcreateData\fP (C-API) instance constructor data 
.br
\fIcreateDataFreeF\fP (C-API) instance constructor data free function 
.br
\fIdeleteCallF\fP (C-API) instance destructor function 
.br
\fIdeleteData\fP (C-API) instance destructor data 
.br
\fIdeleteDataFreeF\fP (C-API) instance destructor data free function 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBMqFactoryReturnE\fP object on error 
.RE
.PP
.PP
\fBExample\fP from \fCexample/c/Filter4.c\fP:  
.PP
.nf
  MqFactoryDefault ('transFilter', MqFactoryDefaultCreate, NULL, NULL, NULL, NULL, NULL);

.fi
.PP
.SS "MQ_CST MqFactoryDefaultIdent()"
C-API: \fBMqFactoryDefaultIdent\fP, return the identifier of the \fIdefault\fP factory  
.SS "MqFactoryAdd(MQ_CST ident, interface...)"
C-API: \fBMqFactoryAdd\fP, add a new \fIfactory-interface\fP identified by \fIident\fP 
.PP
\fBParameters:\fP
.RS 4
\fIident\fP factory identifier 
.br
\fIcreateCallF\fP (C-API) instance constructor function 
.br
\fIcreateData\fP (C-API) instance constructor data 
.br
\fIcreateDataFreeF\fP (C-API) instance constructor data free function 
.br
\fIdeleteCallF\fP (C-API) instance destructor function 
.br
\fIdeleteData\fP (C-API) instance destructor data 
.br
\fIdeleteDataFreeF\fP (C-API) instance destructor data free function 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBMqFactoryReturnE\fP object on error 
.RE
.PP
.PP
\fBExample\fP from \fCexample/c/Filter5.c\fP:  
.PP
.nf
  MqFactoryAdd ('F1', F1New, NULL, NULL, NULL, NULL, NULL);

.fi
.PP
.SS "MqFactoryNew(MQ_CST ident, interface..., MQ_PTR data, struct MqS *ctxP)"
C-API: \fBMqFactoryNew\fP, add a new factory interface and create a new top-level instance 
.PP
This function is a convenient function to combine the \fBMqFactoryAdd\fP and the \fBMqFactoryCall\fP functionality. 
.PP
\fBParameters:\fP
.RS 4
\fIident\fP factory identifier 
.br
\fIcreateCallF\fP (C-API) instance constructor function 
.br
\fIcreateData\fP (C-API) instance constructor data 
.br
\fIcreateDataFreeF\fP (C-API) instance constructor data free function 
.br
\fIdeleteCallF\fP (C-API) instance destructor function 
.br
\fIdeleteData\fP (C-API) instance destructor data 
.br
\fIdeleteDataFreeF\fP (C-API) instance destructor data free function 
.br
\fIdata\fP (C-API) environment specific data or \fCNULL\fP used by \fIcreateCallF\fP 
.br
\fIctxP\fP (C-API) the new created instance to return 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBMqFactoryReturnE\fP object on error 
.RE
.PP
.PP
\fBExample\fP from \fCexample/c/mulserver.c\fP:  
.PP
.nf
  MqFactoryErrorPanic(MqFactoryNew('mulserver', MulServerFactory, NULL, NULL, NULL, NULL, NULL, NULL, &ctx));

.fi
.PP
.SS "MqFactoryCall(MQ_CST ident, MQ_PTR data, struct MqS *ctxP)"
C-API: \fBMqFactoryCall\fP, call the factory constructor, identified by \fIident\fP, to create a new instance 
.PP
\fBParameters:\fP
.RS 4
\fIident\fP factory identifier to call 
.br
\fIdata\fP (C-API) environment specific data or \fCNULL\fP 
.br
\fIctxP\fP (C-API) the new created instance to return 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBMqFactoryReturnE\fP object on error 
.RE
.PP
.PP
\fBExample\fP from \fCexample/c/Filter5.c\fP:  
.PP
.nf
  MqFactoryErrorPanic(MqFactoryCall(argv[1], NULL, &ctx));

.fi
.PP
.SS "MqFactoryCtxIdentSet(struct MqS *ctx, MQ_CST ident)"
C-API: \fBMqFactoryCtxIdentSet\fP, link the context to a new \fIfactory-interface\fP identified by \fIident\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIident\fP the factory identifier to link with 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MQ_CST MqFactoryCtxIdentGet(struct MqS *ctx)"
C-API: \fBMqFactoryCtxIdentGet\fP, get the \fIident\fP of the \fIfactory-interface\fP used for the context 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.factory.ident\fP value or an empty string if no factory is available 
.RE
.PP
\fBAttention:\fP
.RS 4
the \fIstring\fP is owned by \fBlibmsgque\fP -> do not free !! 
.RE
.PP
 
.SS "MqFactoryCtxDefaultSet(struct MqS *ctx, MQ_CST ident)"
C-API: \fBMqFactoryCtxDefaultSet\fP, create a copy of the default \fIfactory-interface\fP using the identifier \fIident\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIident\fP the new factory identifier 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SH "CONFIG API"
.PP
\fBMqInit\fP
.br
 \fBbuffersize\fP, \fBdebug\fP, \fBtimeout\fP
.br
 \fBname\fP, \fBsrvname\fP
.br
 \fBisSilent\fP, \fBisString\fP, \fBisServer\fP
.br
 \fBtcp\fP, \fBuds\fP, \fBpipe\fP
.br
 \fBstartAs\fP, \fBdaemon\fP, \fBignoreExit\fP
.br
 \fBIServerSetup\fP, \fBIServerCleanup\fP
.br
 \fBIBgError\fP, \fBIEvent\fP
.br
.PP
configuration of a context 
.PP
The configuration is done persistent using \fIconfig-api\fP functions or on link-setup using \fIcommand-line-arguments\fP. 
.SS "static: struct MqBufferLS * init = MqInitCreate()"
Initialize the process \fIstartup-prefix\fP argument. 
.PP
The \fIstartup-prefix\fP have to be the name of the executable, found in the \fCPATH\fP environment variable, and additional arguments like the script name or the required startup options. The \fIstartup-prefix\fP is used for two different purpose:
.IP "\(bu" 2
To start a new entity using the \fBstartAs\fP '--spawn' command-line option.
.IP "\(bu" 2
To replace the \fIcommand-line-argument\fP \fC'... @ SELF ...'\fP with \fC'... @ startup-prefix ...'\fP at \fBMqLinkCreate\fP.
.PP
Every use of this function will free the data of the previous \fIstartup-prefix\fP. By default the \fIstartup-prefix\fP is set during package loading or during \fBMqLinkCreate\fP and have \fBnot\fP to be initialized again. 
.PP
\fBExample:\fP initialize the \fIstratup-prefix\fP with \fImyExecutable\fP and \fImyFirstArgument\fP 
.PP
.nf
 struct MqBufferLS * init = MqInitCreate(); 
 MqBufferLAppendC(init, 'myExecutable'); 
 MqBufferLAppendC(init, 'myFirstArgument'); 

.fi
.PP
 The memory is owned by the library -> \fBdo not free the memory\fP
.SS "command-line:  --buffersize"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBMqConfigGetBuffersize\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetBuffersize\fP (ctx, MQ_INT buffersize)\fP
.PP
set the OS specific value for the \fIsocket-operation-buffer\fP (default: OS specific) 
.SS "command-line:  --debug"
\fBtype:\fP \fC\fBMQ_INT\fP\fP, \fBget:\fP \fC\fBMqConfigGetDebug\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetDebug\fP (ctx, MQ_INT debug)\fP
.PP
set the \fIdebug-level\fP of the \fIcontext\fP 
.PP
Valid values are 0 <= \fIdebug-level\fP <= 9 using 0 for \fIno-debug\fP and 9 for \fImaximum-debug\fP. (default: 0) 
.SS "command-line:  --timeout"
\fBtype:\fP \fC\fBMQ_TIME_T\fP\fP, \fBget:\fP \fC\fBMqConfigGetTimeout\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetTimeout\fP (ctx, MQ_TIME_T timeout)\fP
.PP
user defined timeout to terminate a blocking function call (default: 90 sec) 
.SS "command-line:  --name"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetName\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetName\fP (ctx. MQ_CST name)\fP
.PP
set the human-readable name of the \fIlocal-context\fP 
.PP
Use the \fIname\fP as a prefix in the local debug/error/log output: 
.PP
.nf
C> (name) [2009-01-12:16-22-27] [4-0-sIoCheckArg]: option:  io->com = PIPE 
.fi
.PP
 The value is define using the following order:
.IP "1." 4
initial set to \fIunknown\fP 
.IP "2." 4
the \fBname\fP \fIconfiguration-option\fP 
.IP "3." 4
use the basename of the \fIfirst\fP entry from the \fIcommand-line-arguments\fP, usually the \fIexecutable-name\fP 
.IP "4." 4
use the \fI--name\fP argument from the \fIcommand-line-arguments\fP 
.PP
.SS "command-line:  --srvname"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetSrvName\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetSrvName\fP (ctx, MQ_CST srvName)\fP
.PP
set the human-readable name of the \fIserver-context\fP 
.PP
Use the \fIserver-name\fP as a client specific prefix in the server debug/error/log output to link \fIserver-messages\fP to a specific \fIclient-connection\fP. 
.PP
.nf
C> (server-name) [2009-01-12:16-22-27] [4-0-sIoCheckArg]: option:  io->com = PIPE 
.fi
.PP
 If the \fIserver-name\fP is not defined on the \fIclient\fP the \fIserver\fP is using \fBname\fP to create a usable name. (default: \fINULL\fP) 
.SS "command-line: --silent"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsSilent\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsSilent\fP (ctx, MQ_BOL bool)\fP
.PP
write (\fIMQ_NO\fP) or don't write (\fIMQ_YES\fP) any massages to stdout or stderr (default: \fIMQ_NO\fP) 
.SS "command-line: --string"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsString\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsString\fP (ctx, MQ_BOL bool)\fP
.PP
use the string-mode (\fIMQ_YES\fP) or the binary-mode (\fIMQ_NO\fP) to send \fInative-data\fP 
.PP
The items in a \fIdata-package\fP are defined as \fBTYPE IDENTIFIER\fP and can be transmitted as \fIstring\fP (slow) or as \fIbinary\fP (fast) data. The \fIstring-mode\fP is used for debugging purpose or if the \fIbinary-data-model\fP is different between the client and the server. The difference in endianness (http://en.wikipedia.org/wiki/Endian) is handled by \fBlibmsgque\fP and does not require the \fIstring-mode\fP. The option is only available for the \fIclient-parent-context\fP. (default: binary-mode) 
.SS "isServer"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fC\fBMqConfigGetIsServer\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetIsServer\fP (ctx, MQ_BOL isServer)\fP
.PP
change the context to act as \fIserver-context\fP (\fIMQ_YES\fP) or not (\fIMQ_NO\fP) 
.PP
A \fIserver-context\fP is responsible to answer \fIservice-requests\fP. This options is also set as side-effect in a \fBIServerSetup\fP or \fBIServerCleanup\fP function-call. (default: \fIMQ_NO\fP) 
.SS "command-line: --tcp --host --port --myhost --myport"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoTcpHost\fP/Port/MyHost/MyPort\fP , \fBset:\fP \fC\fBMqConfigSetIoTcp\fP (ctx,MQ_CST host, MQ_CST port, MQ_CST myhost, MQ_CST myport)\fP
.PP
configure a context to use a \fItcp-client-server-link\fP 
.PP
\fBParameters:\fP
.RS 4
\fIhost\fP client: name of the remote interface (default: localhost)
.br
 server: name of the local interface (default: listen on \fIall\fP interfaces) 
.br
\fIport\fP client: name of the remote port
.br
 server: name of the local port 
.br
\fImyhost\fP client: name of the local interface 
.br
\fImyport\fP client: name of the local port 
.RE
.PP
 
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error
.RE
.PP
.SS "command-line: --uds --file"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoUdsFile\fP\fP , \fBset:\fP \fC\fBMqConfigSetIoUdsFile\fP (ctx, MQ_CST file)\fP
.PP
configure a context to use a \fIuds-client-server-link\fP 
.PP
The \fIuds-socket\fP (http://en.wikipedia.org/wiki/Unix_domain_socket) is usually 50% faster than a local tcp communication but only available on UNIX. 
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP name of a \fIuds-socket-file\fP (default: \fINULL\fP) 
.RE
.PP
 
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error
.RE
.PP
.SS "command-line: --pipe --socket"
\fBtype:\fP \fC\fBMQ_SOCK\fP\fP, \fBget:\fP \fC\fBMqConfigGetIoPipeSocket\fP\fP , \fBset:\fP \fC\fBMqConfigSetIoPipeSocket\fP (ctx, MQ_INT socket)\fP
.PP
configure a context to use a \fIpipe-client-server-link\fP 
.PP
The \fIsocket\fP option is special because it is used only for internal purpose to submit the socket from the client to the server started as pipe by the client. The only public usage for this option is to serve as interface for an existing tool like (x)inetd. The (x)inetd tool is a \fIUNIX\fP service to listen on a tcp/ip port and start for every connection the proper entry from the file \fI/etc/\fP(x)inetd.conf with the file-descriptor \fI0\fP as send/recv socket handle. 
.PP
\fBParameters:\fP
.RS 4
\fIsocket\fP the \fIfile-descriptor-number\fP (default: not set) 
.RE
.PP
 
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error
.RE
.PP
.SS "command-line: --thread --spawn --fork"
\fBtype:\fP \fCenum \fBMqStartE\fP\fP, \fBget:\fP \fC\fBMqConfigGetStartAs\fP (ctx)\fP , \fBset:\fP \fC\fBMqConfigSetStartAs\fP (ctx, enum \fBMqStartE\fP startAS)\fP
.PP
create a new \fIapplication-context\fP as thread, spawn or fork 
.PP
A new \fIapplication-context\fP is created if:
.IP "\(bu" 2
a \fItcp-uds-server\fP listen on socket and get a \fIconnection-request\fP from a client. This require: \fBFACTORY API\fP and \fBIServerSetup\fP
.IP "\(bu" 2
a \fIfilter-context\fP create a new \fIfilter-instance\fP 
.IP "\(bu" 2
a \fIserver-context\fP create a new \fIworker-context\fP using \fBMqSlaveWorker\fP
.IP "\(bu" 2
a \fIserver-context\fP start a new \fIclient-server-link\fP using \fISELF\fP as executable-name using \fBMqLinkCreate\fP
.PP
The allowed integer values are:
.IP "\(bu" 2
\fB\fBMQ_START_DEFAULT\fP\fP = 0, use application-context default entity creation
.IP "\(bu" 2
\fB\fBMQ_START_FORK\fP\fP = 1, create entity as \fIfork\fP 
.IP "\(bu" 2
\fB\fBMQ_START_THREAD\fP\fP = 2, create entity as \fIthread\fP 
.IP "\(bu" 2
\fB\fBMQ_START_SPAWN\fP\fP = 3, create entity as \fIspawn\fP process
.PP
(default: do not create a new application-context) 
.SS "command-line:  --daemon"
\fBtype:\fP \fC\fBMQ_CST\fP\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBMqConfigSetDaemon\fP (ctx, MQ_CST pidfile)\fP
.PP
start the \fIserver-context\fP as daemon 
.PP
A \fIdaemon\fP is a \fIserver-process\fP without any link to the \fIparent-process\fP. A \fIdaemon-process\fP has closed all default IO (e.g stdout, stdin, stderr) and forked into the background. (default: no daemon) 
.PP
\fBAttention:\fP
.RS 4
this option require the \fBfork\fP system-call and is \fBnot\fP compatible with threads. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIpidfile\fP write the PID of the daemon into this file (default: NULL, do not start as daemon) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SS "ignoreExit"
\fBtype:\fP \fC\fBMQ_BOL\fP\fP, \fBget:\fP \fCNO\fP , \fBset:\fP \fC\fBMqConfigSetIgnoreExit\fP (ctx, MQ_BOL bool)\fP
.PP
do not delete the \fIserver-context\fP on \fIclient-server-link\fP shutdown 
.PP
By default the \fIserver-context\fP is deleted and the \fIserver-process\fP or \fIserver-thread\fP exit if the \fIclient\fP close the connection. If this option is set to \fIMQ_YES\fP the \fIserver\fP will continue to work. Without \fIclient\fP connection only the internal event function (set with \fBIEvent\fP) is available to work on tasks. if \fIall\fP (parent and child) event functions return with \fBMqErrorSetCONTINUE\fP (nothing to do) the process finally exit. (default: \fIMQ_NO\fP) 
.SS "interface: MqConfigSetServerSetup (ctx, fFunc, data, fFree, fCopy)"
This interface is used to configure a new \fIserver-context-link\fP, like a constructor, and is called at the end of \fBMqLinkCreate\fP or \fBMqLinkCreateChild\fP. This interface is called for every new incoming connection request and is used to define context specific services using \fBMqServiceCreate\fP or to initialize \fIcontext-specific\fP variables. As side-effect this interface set \fBisServer\fP to \fIMQ_YES\fP.  Read more about how to define a \fIcallback\fP at \fBSERVICE CALLBACK\fP.
.SS "interface: MqConfigSetServerCleanup (ctx, fFunc, data, fFree, fCopy)"
This interface is used to cleanup an old \fIserver-context-link\fP, like a destructor, and is called at the beginning of \fBMqLinkDelete\fP to free \fIcontext-specific\fP variables. As side-effect this interface set \fBisServer\fP to \fIMQ_YES\fP.  Read more about how to define a \fIcallback\fP at \fBSERVICE CALLBACK\fP.
.SS "interface: MqConfigSetBgError (ctx, fFunc, Data, fFree, fCopy)"
A background error is an error without a link to an \fIapplication-context\fP and happen if an \fBMqSendEND\fP call fails or if an other asynchronous task fails. if the interface is \fInot\fP defined the error is printed to stderr and the application continue to work. if the interface is defined the context is set to error and the callback is called to process this error. Inside the callback the error is available using \fBMqErrorGetNum\fP and \fBMqErrorGetText\fP and can be cleared using \fBMqErrorReset\fP.  Read more about how to define a \fIcallback\fP at \fBSERVICE CALLBACK\fP.
.SS "interface: MqConfigSetEvent (ctx, fFunc, Data, fFree, fCopy)"
Event-Handling is used to process instructions in the \fIbackground\fP to give the tool-user the feeling of a non-blocking application. For example Tcl using the event-handling to update the Tk user-interface while the application is waiting for data. The event handling function is called on idle and is designed for a very \fBshort\fP function execution time. Do only \fIone\fP action per function call. This function will be called with a ~10000 usec interval to guarantee a parallel like execution. 
.PP
\fBAttention:\fP
.RS 4
Together with \fBignoreExit\fP the Event-Handler is used to start background processing of tasks. Return the Event-Handler with \fBMqErrorSetCONTINUE\fP to signal that all tasks are finished and the process/thread is ready to exit. If \fBall\fP \fIchild\fP context Event-Handler return with \fBMqErrorSetCONTINUE\fP too and the client/server links is already shutdown the process/thread will \fBexit\fP. example: \fCtheLink/example/LANG/Filter4.EXT\fP 
.RE
.PP
 Read more about how to define a \fIcallback\fP at \fBSERVICE CALLBACK\fP.
.SH "LINK API"
.PP
\fBMqLinkCreate\fP
.br
 \fBMqLinkCreateChild\fP
.br
 \fBMqLinkDelete\fP
.br
 \fBMqLinkConnect\fP
.br
 \fBMqLinkGetParent\fP
.br
 \fBMqLinkIsParent\fP
.br
 \fBMqLinkGetCtxId\fP
.br
 \fBMqLinkIsConnected\fP
.br
 \fBMqLinkGetTargetIdent\fP
.br
.PP
setup and manage a \fIclient-server-link\fP 
.PP
The \fIclient-server-link\fP connect two \fIcontext\fP, a \fIclient-parent-context\fP and a \fIserver-parent-context\fP. The \fIlink\fP can be \fIlocal\fP (connect two \fIcontext\fP on the same host) or can be \fIremote\fP (connect two \fIcontext\fP on different hosts). On-Top the \fIparent-context\fP multiple \fIchild-context\fP are allowed. 
.PP
.nf

     !on local host!                                  !on remote host!
   
         server1---------x                     x----------server2
            |            |                     |             |
            |     child-context-1       child-context-2      |
            |            |                     |             |                      server
    parent-context-1-----x                     x-----parent-context-2
            |                                                |
   (MqConfigS::server)                  (MqConfigS::server --fork --tcp --port)
            |                                                |
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
            |                                                |
        (--pipe)                                   (--tcp --host --port)
            |                                                |
    parent-context-1-----x                     x-----parent-context-2
            |            |                     |             |                      client
            |     child-context-1       child-context-2      |
            |            |                     |             |
            x------------x--------client-------x-------------x
   
                              !on local host!  
.fi
.PP
.PP
\fBDefinition of a 'client-context'\fP
.br
.IP "\(bu" 2
every new \fIclient-parent-context\fP create a new \fIclient-server-link\fP and perform the \fIconnect\fP system-call.
.IP "\(bu" 2
every new \fIclient-server-link\fP start a new \fIserver-instance\fP and creating a new \fIserver-parent-context\fP 
.IP "\(bu" 2
every deletion of the \fIclient-parent-context\fP stop the previous started \fIserver-instance\fP and delete the server-parent-context
.IP "\(bu" 2
the \fIclient-context\fP get all the error/warning/info messages from the \fIserver-context\fP 
.PP
\fBDefinition of a 'server-context'\fP
.br
.IP "\(bu" 2
every new \fIserver-parent-context\fP is created by request from the \fIclient-parent-context\fP:
.IP "\(bu" 2
in remote mode every new \fIserver-parent-context\fP wait for a \fItcp\fP or \fIuds\fP connection request using the \fIaccept\fP system-call. 
.PP
.nf

   client --tcp --hots REMOTE_HOST --port REMOTE_PORT ...    or
   client --uds --file MYFILE ...
.fi
.PP

.IP "\(bu" 2
in local mode new \fIserver-parent-context\fP is started by the \fIclient-parent-context\fP as \fIpipe:\fP 
.PP
.nf

   client @ server 
.fi
.PP

.IP "\(bu" 2
a \fIserver-context\fP have to implement the \fBIServerSetup\fP and the \fBFACTORY API\fP interface.
.IP "\(bu" 2
a \fIserver-context\fP have to enter the \fIevent-loop\fP and wait for incoming \fIservice-request\fP using \fBMqProcessEvent\fP together with the \fBMQ_WAIT_FOREVER\fP.
.PP
\fBDefinition of a 'parent-context'\fP
.br
.PP
.IP "\(bu" 2
the parent is the first context created and is created with \fBMqLinkCreate\fP
.IP "\(bu" 2
every new \fIparent-context\fP on the client create a new communication to a server.
.IP "\(bu" 2
every new \fIparent-context\fP on the client connect to a new \fIparent-context\fP on the server
.IP "\(bu" 2
every new \fIparent-context\fP on the server is using a new \fIserver-instance\fP 
.IP "\(bu" 2
the \fIparent-context\fP control the socket communication interface
.PP
\fBDefinition of a 'child-context'\fP
.br
.PP
.IP "\(bu" 2
the \fIchild-context\fP is the second or more context and is created with \fBMqLinkCreateChild\fP.
.IP "\(bu" 2
every new \fIchild-context\fP on the client create a new \fIchild-context\fP on the server.
.IP "\(bu" 2
every new \fIchild-context\fP is totally independent from the \fIparent-context\fP setup and is able to serve its own services.
.IP "\(bu" 2
the \fIchild-context\fP is using the \fIparent-context\fP as a tunnel.
.IP "\(bu" 2
the parent of a \fIchild-context\fP can be a \fIparent-context\fP or an other \fIchild-context\fP. A tree like structure is created.
.IP "\(bu" 2
the \fIchild-context\fP is using the communication interface from the parent-context.
.IP "\(bu" 2
if a \fIcontext\fP is deleted (parent or child) the \fIdepending\fP context (parent or child) is deleted too.
.IP "\(bu" 2
if a \fIcontext\fP is deleted the \fIdepending\fP context-tree is deleted too.
.PP
.SS "MqLinkCreate (struct MqS *ctx, struct MqBufferLS ** args)"
C-API: \fBMqLinkCreate\fP, make \fIctx\fP to a \fIparent-context\fP and setup a new \fIclient-server-link\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIargs\fP \fIcommand-line-arguments\fP to configure the \fIclient-server-link\fP including the \fB'@'\fP item to add \fIserver-command-line-arguments\fP for the \fI--pipe\fP setup. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
if the first argument after the \fB'@'\fP item is the string \fB'SELF'\fP an independent server of the current server is started. This is not a \fBSLAVE API\fP. The 'SELF' argument is replaced by an application default setting (if available) or by arguments set with \fBMqInit\fP 
.RE
.PP
.SS "MqLinkCreateChild (struct MqS *ctx, struct MqS *parent, struct MqBufferLS ** args)"
C-API: \fBMqLinkCreateChild\fP, make a \fIcontext\fP to a \fIchild-context\fP on-top of an existing \fIparent-client-server-link\fP 
.PP
A child is using the same process or thread as the parent but a different namespace. With a different namespace a child is able to act on different services on the shared server. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIparent\fP the \fIparent-context\fP defined with \fBMqLinkCreate\fP 
.br
\fIargs\fP \fIcommand-line-arguments\fP to configure the \fIclient-server-link\fP without the \fB'@'\fP item. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SS "MqLinkDelete(struct MqS *ctx)"
C-API: \fBMqLinkDelete\fP, close the \fIclient-server-link\fP 
.PP
On a client the \fIcontext\fP will be set to \fInot-connected\fP and the function \fBMqLinkIsConnected\fP will return \fIMQ_NO\fP. On a server the \fIcontext\fP will be deleted but only if \fBignoreExit\fP is \fInot\fP set to \fIMQ_YES\fP. If the \fIlink\fP is already \fInot-connected\fP nothing will happen. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
 
.SS "MqLinkConnect(struct MqS *ctx)"
C-API: \fBMqLinkConnect\fP, re-connect a \fIclient-server-link\fP after a server crash or a network downtime 
.PP
Do nothing if the \fIclient-server-link\fP is already connected. This function is only useful in an \fIevent-function\fP (\fBIEvent\fP) if the \fIlink-disconnect\fP (\fBMqErrorIsEXIT\fP) is ignored (\fBMqErrorReset\fP). Read more from the: \fC/theLink/example/c/Filter4.c\fP example. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "struct MqS* MqLinkGetParent (struct MqS *ctx)"
C-API: \fBMqLinkGetParent\fP, get the \fIparent-context\fP from a client/server link 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIparent-context\fP or \fINULL\fP if not a \fIchild-context\fP 
.RE
.PP
 
.SS "MQ_SIZE MqLinkGetCtxId (struct MqS *ctx)"
C-API: \fBMqLinkGetCtxId\fP, get an identifier which is \fIunique\fP per \fIparent-or-child-context\fP 
.PP
The \fIcontext-identifier\fP is a number and is used in the protocol to link a \fIdata-package\fP to a \fIcontext-pointer\fP. This is necessary because the communication interface is shared between the \fIparent-context\fP and the \fIchild-context\fP. This number is \fIunique\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the identifier as number 
.RE
.PP
 
.SS "MQ_BOL MqLinkIsParent (struct MqS *ctx)"
C-API: \fBMqLinkIsParent\fP, is the \fIcontext\fP a \fIparent-context\fP? 
.PP
A \fIcontext\fP is a \fIparent-context\fP if it was created with \fBMqLinkCreate\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
 
.SS "MQ_BOL MqLinkIsConnected (struct MqS *ctx)"
C-API: \fBMqLinkIsConnected\fP, is the context connected? 
.PP
A context is connected if the \fBMqLinkCreate\fP command was successful. A context is \fInot\fP connected if:
.IP "\(bu" 2
the context has just been created and not connected
.IP "\(bu" 2
the link was deleted with \fBMqLinkDelete\fP
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
 
.SS "MQ_CST MqLinkGetTargetIdent (struct MqS *ctx)"
C-API: \fBMqLinkGetTargetIdent\fP, get the \fIident\fP of the \fIlink-target\fP 
.PP
This function is only useful if the link is up and running. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
get the \fIident\fP of the \fIlink-target\fP or \fINULL\fP if not connected 
.RE
.PP
.SH "SERVICE API"
.PP
\fBMqServiceIdentifier\fP
.br
 \fBMqServiceCallback\fP
.br
 \fBMqServiceGetToken\fP
.br
 \fBMqServiceIsTransaction\fP
.br
 \fBMqServiceGetFilter\fP
.br
 \fBMqServiceCreate\fP
.br
 \fBMqServiceDelete\fP
.br
 \fBMqServiceProxy\fP
.br
 \fBMqProcessEvent\fP
.br
.PP
create and manage services 
.PP
To provide a \fIservice\fP is the main purpose of a server and the main-purpose of a \fIclient/server\fP connection is to call a service and to process the results. A service have to be defined on a server during \fIlink-setup\fP (\fBIServerSetup\fP) with the \fBMqServiceCreate\fP function. The cleanup is done implicit on \fIlink-delete\fP or explicit with the \fBMqServiceDelete\fP function. 
.PP
\fBExample:\fP define the service \fISRV1\fP on the \fIserver-link-setup\fP: 
.PP
.nf
 enum MqErrorE ServerSetup(struct MqS * msgque) { 
   MqErrorCheck(MqServiceCreate(msgque, 'SRV1', SRV1, NULL, NULL)); 
   return MQ_OK; 
 error: 
   return MqErrorStack(msgque->error); 
 } 

.fi
.PP
.SS "TOKEN IDENTIFIER"
a 4 byte string to identify different services 
.PP
The \fItoken-identifier\fP is defined by the programmer using \fBMqServiceCreate\fP to link a \fIservice-handler\fP with an \fIidentifier\fP. The \fIidentifier\fP is part of the \fBMqSendEND\fP, \fBMqSendEND_AND_WAIT\fP or \fBMqSendEND_AND_CALLBACK\fP function-call to access the services.
.br
 For internal purpose some special \fItoken\fP are predefined:
.IP "\(bu" 2
\fB_???\fP - all \fItoken\fP starting with a \fB'_'\fP are for \fBinternal\fP usage only
.IP "\(bu" 2
\fB+ALL\fP - used in \fBMqServiceCreate\fP and \fBMqServiceDelete\fP to listen on \fBall\fP token not handled by other \fItoken\fP more precise
.IP "\(bu" 2
\fB-ALL\fP - used in \fBMqServiceDelete\fP to delete \fBall\fP token
.IP "\(bu" 2
\fB+FTR\fP and \fB+EOF\fP - used for \fIone-directional-filter\fP 
.PP
.SS "SERVICE CALLBACK"
function used as \fIservice-handle\fP 
.PP
A service is using a \fIcallback\fP to act on an incoming \fIservice-request\fP. The \fIcallback\fP is linked to a \fBTOKEN IDENTIFIER\fP with \fBMqServiceCreate\fP or is used as argument to the \fBMqSendEND_AND_CALLBACK\fP function.  The callback is implemented as a set of functions and data suitable for \fBMqCallbackS\fP.
.SS "MQ_CST MqServiceGetToken (ctx)"
C-API: \fBMqServiceGetToken\fP, get the \fBTOKEN IDENTIFIER\fP from an \fIongoing-service-call\fP 
.PP
This function is needed on the server to process a \fIservice-request\fP defined as \fI+ALL\fP or as an \fIalias\fP to extract the \fIcurrent\fP \fBTOKEN IDENTIFIER\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBTOKEN IDENTIFIER\fP 
.RE
.PP
 
.SS "int MqServiceIsTransaction (ctx)"
C-API: \fBMqServiceIsTransaction\fP, check if the \fIongoing-service-call\fP belongs to a transaction 
.PP
A \fIservice-call\fP can be \fIwith-transaction\fP (return \fIMQ_YES\fP if the package was send with \fBMqSendEND_AND_WAIT\fP or \fBMqSendEND_AND_CALLBACK\fP) or can be \fIwithout-transaction\fP (return \fIMQ_NO\fP if the package was send with \fBMqSendEND\fP) 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
 
.SS "struct MqS* MqServiceGetFilter(ctx, MQ_SIZE id, struct MqS **const filter)"
C-API: \fBMqServiceGetFilter\fP, get the \fIfilter-context\fP or the \fImaster-context\fP 
.PP
A \fIfilter-pipeline\fP has two context, one on the left and one on the right. The \fIleft-context\fP is linked with the \fImaster-context\fP and the \fIright-context\fP is linked to the \fIslave-context\fP. This function extract the \fIother-context\fP related to the initial \fIctx\fP argument using the following order:
.IP "1." 4
return the \fImaster-context\fP if not NULL
.IP "2." 4
return the \fIslave-context\fP using \fIid\fP if not NULL
.IP "3." 4
return a 'filter not available' error
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIfilter\fP the \fIother-context\fP or \fINULL\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqServiceCreate(ctx,MQ_TOK token,callback,data,fFree)"
C-API: \fBMqServiceCreate\fP, create a link between a \fBTOKEN IDENTIFIER\fP and a \fBSERVICE CALLBACK\fP 
.PP
The \fItoken\fP have to be unique but the \fIcallback\fP not, this is called an \fIalias\fP. Use \fBMQ_CST MqServiceGetToken (ctx)\fP to get the current token in an \fIincoming-service-call\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIcallback\fP the function to process the incoming \fIservice-request\fP 
.br
\fIdata\fP a user defined additional \fIdata-argument\fP for the \fIcallback\fP function (C-API only) 
.br
\fIdatafreeF\fP the function to free the \fIdata-argument\fP after use (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
the link-setup (\fBMqLinkCreate\fP or \fBMqLinkCreateChild\fP) have to done \fBbefore\fP using this function 
.RE
.PP
 
.SS "MqServiceProxy(ctx,MQ_TOK token, MQ_SIZE id=0)"
C-API: \fBMqServiceProxy\fP, create a service to link a \fImaster-context\fP with a \fIslave-context\fP. 
.PP
This function is used to create a \fIproxy-service\fP to forward the \fIbody-data\fP from the \fIread-data-package\fP of the \fImaster\fP to the \fIsend-data-package\fP of the slave. The data is \fInot\fP changed. This function support the \fIreverse-operation\fP also. If the \fIctx\fP is a \fImaster-context\fP than the data is send to \fIslave\fP identified by \fIid\fP. If the \fIctx\fP is a \fIslave-context\fP than the data is send to the \fImaster\fP of the \fIslave\fP. Use \fIid=0\fP to send that data to the \fIfilter-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIid\fP the slave identifier, only used if \fIctx\fP is a \fImaster-context\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqServiceDelete(ctx,MQ_TOK token)"
C-API: \fBMqServiceDelete\fP, delete a service. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqProcessEvent(ctx,MQ_TIME_T timeout,MQ_WAIT_NO(|ONCE|FOREVER))"
C-API: \fBMqProcessEvent\fP, enter the \fIevent-loop\fP and wait for an incoming \fIservice-request\fP. 
.PP
This function is used to enter the \fIevent-loop\fP and start listen on open \fIfile-handles\fP and to call \fBIEvent\fP on idle.
.br
 This function is direct used on a server to enter the \fIevent-loop\fP and wait for incoming service requests or after the \fBMqSendEND_AND_CALLBACK\fP function to wait for the \fIservice-result\fP. This function is indirect used in \fBMqSendEND_AND_WAIT\fP too.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItimeout\fP the maximum \fIwait-time\fP in seconds until a \fItimeout-error\fP is raised, possible values are:
.IP "\(bu" 2
\fB>0\fP, use this value as number of seconds.
.IP "\(bu" 2
\fB\fC\fBMQ_TIMEOUT_DEFAULT\fP\fP = -1\fP, \fC\fBMQ_TIMEOUT_USER\fP\fP for \fC\fBMQ_WAIT_ONCE\fP\fP or \fC\fBMQ_TIMEOUT_MAX\fP\fP for \fC\fBMQ_WAIT_FOREVER\fP\fP. \fBdefault\fP, request the default timeout value 
.IP "\(bu" 2
\fB\fC\fBMQ_TIMEOUT_USER\fP\fP = -2\fP, request the user defined timeout value from the \fBtimeout\fP configuration value 
.IP "\(bu" 2
\fB\fC\fBMQ_TIMEOUT_MAX\fP\fP = -3\fP, request the maximum possible (infinite) timeout value 
.PP
.br
\fIwait\fP the \fIoperation-mode\fP used to define the behaviour, possible values are:
.IP "\(bu" 2
\fB\fC\fBMQ_WAIT_NO\fP\fP = 0\fP, don't wait for an event just do the check and comeback. if an Event is available process the event, but only one. If no Event is available return with \fBMQ_CONTINUE\fP. \fBdefault\fP 
.IP "\(bu" 2
\fB\fC\fBMQ_WAIT_ONCE\fP\fP = 1\fP, wait maximum \fItimeout\fP seconds for only \fIone\fP event or raise a \fItimeout-error\fP if no event was found.
.IP "\(bu" 2
\fB\fC\fBMQ_WAIT_FOREVER\fP\fP = 2\fP, wait maximum \fItimeout\fP seconds for a event. If an event was found process the event. If no event was found, raise a \fItimeout-error\fP. After the event was processed continue to listen for a the new event. The function will only come back on \fIerror\fP or on \fIexit\fP.
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SH "SEND API"
.PP
\fBMqSendSTART\fP
.br
 \fBMqSendEND\fP
.br
 \fBMqSendEND_AND_WAIT\fP
.br
 \fBMqSendEND_AND_CALLBACK\fP
.br
 \fBMqSendRETURN\fP
.br
 \fBMqSendERROR\fP
.br
 \fBMqSendTYPE\fP
.br
 \fBMqSendN\fP
.br
 \fBMqSendBDY\fP
.br
 \fBMqSendL_START\fP
.br
 \fBMqSendL_END\fP
.br
 \fBMqSendT_START\fP
.br
 \fBMqSendT_END\fP
.br
.PP
construct an outgoing \fIsend-data-package\fP. 
.PP
\fISending\fP data is an active task and the opposite of \fIreading\fP data which is an passive task. Active mean that the \fIsend\fP is triggered by the software-work-flow or the user. There is one \fIsend\fP function for every basic type defined in \fBTYPE IDENTIFIER\fP plus a couple of help functions. 
.PP
\fBAttention:\fP
.RS 4
Sending data is an atomic task and should not be split. Only one \fIsend-data-package\fP is always in duty. As basic rule do the processing first and send all the data afterwards. If the function \fBMqSendEND_AND_WAIT\fP is used the application enter the event-loop and is still able to work on other client/server links. 
.RE
.PP
.PP
\fBExample:\fP send an \fBMQ_INT\fP and a list of \fBMQ_DBL\fP, \fBMQ_CST\fP and a \fI\fBMQ_BIN\fP:\fP 
.PP
.nf
 MqSendSTART(ctx);
 MqSendI(ctx,num);
 MqSendL_START(ctx);
   MqSendD(ctx,balance);
   MqSendC(ctx,'name of the owner');
   MqSendB(ctx,signature);
 MqSendL_END(ctx);
 MqErrorCheck(MqSendEND_AND_WAIT(ctx,'SRV1',MQ_TIMEOUT_USER));

.fi
.PP
.SS "MqSendSTART(ctx)"
C-API: \fBMqSendSTART\fP, initialize the \fIsend-data-package\fP. 
.PP
This function have to be the first statement in a \fIsend-data-block\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendEND(ctx,MQ_TOK token)"
C-API: \fBMqSendEND\fP, finish the \fIsend-data-block\fP, call the remote service and do \fInot\fP expect a return. 
.PP
If an \fBerror\fP is raised on the server during the service-processing the error is send back as \fIasynchronous-error-event\fP and will be raised during the next enter into the event-loop. Use \fBIBgError\fP to control the \fIasynchronous-error-event\fP processing. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendEND_AND_WAIT(ctx,MQ_TOK token,MQ_TIME_T timeout)"
C-API: \fBMqSendEND_AND_WAIT\fP, finish the \fIsend-data-block\fP, call the remote service and do \fIwait\fP for return. 
.PP
If an \fBerror\fP is raised on the server during the service-processing the function will return this error immediately. During waiting for the return the \fIevent-loop\fP is used to process other events. Use \fBIEvent\fP to add your tasks into the event loop. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fItimeout\fP seconds until a \fItimeout-error\fP is raised 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendEND_AND_CALLBACK(ctx,MQ_TOK token,fCallback,data,fFree)"
C-API: \fBMqSendEND_AND_CALLBACK\fP, finish the \fIsend-data-block\fP, call the remote service and do \fInot-wait\fP for return. 
.PP
This function will \fInever\fP block and return immediately. If \fIreturn-data\fP or an error is available the \fIcallback-function\fP is called for processing. Use \fBMqProcessEvent(ctx,MQ_TIME_T timeout,MQ_WAIT_NO(|ONCE|FOREVER))\fP to enter the \fIevent-loop\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIcallback\fP the function to process the \fIservice-call\fP results 
.br
\fIdata\fP a user defined additional \fIdata-argument\fP for the \fIcallback\fP function (C-API only) 
.br
\fIdatafreeF\fP the function to free the \fIdata-argument\fP after use (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendRETURN(ctx)"
C-API: \fBMqSendRETURN\fP, finish the \fIsend-data-block\fP on the server and optional return the results. 
.PP
Every \fIservice-handler\fP have to use this function at the end to return the results or the error. If an \fIerror\fP is returned the local \fIerror-object\fP is reset. The following behaviour is used:
.IP "\(bu" 2
if a shortterm transaction is ongoing this function return the data or the error to the link target
.IP "\(bu" 2
if the answer does not return any data no previous \fBMqSendSTART\fP is required.
.IP "\(bu" 2
if no transaction is ongoing this function does just return. If an error is available report an asynchronous error to the link target.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendERROR(ctx)"
C-API: \fBMqSendERROR\fP, send the data from the \fBERROR OBJECT\fP to the link target . 
.PP
If an error is available the \fIerror-number\fP and the \fIerror-text\fP is send to the link target. After send the error is reset. This function only raise an error if the sending self fails. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendTYPE(ctx,value)"
C-API: \fBMqSendY\fP, append a native \fBTYPE IDENTIFIER\fP value to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIvalue\fP the value for appending 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendN(ctx,MQ_CBI const value,MQ_SIZE const len)"
C-API: \fBMqSendN\fP, append a \fIbody-item\fP to the \fIsend-data-package\fP. 
.PP
A \fIbody-item\fP is a \fIbyte-array\fP and including the \fIitem-size\fP, \fIitem-type\fP and the \fIitem-data\fP as value. The \fIbody-item\fP is the result of a previous \fBMqReadN(ctx,MQ_CBI * const value, MQ_SIZE * const len)\fP function call and can be used for saving into an external storage or for an additional operation like encryption. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIvalue\fP the \fIbody-item\fP for appending 
.br
\fIlen\fP the size of the \fIbody-item-byte-array\fP (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "enum MqErrorE MqSendBDY(ctx,MQ_CBI const value,MQ_SIZE const len)"
C-API: \fBMqSendBDY\fP, send the \fIentire-body\fP to the \fIlink-target\fP 
.PP
The goal of this function is to send the \fIentire-body\fP of a service request to the \fIlink-target\fP. The \fIentire-body\fP is the result of a previous \fBMqReadBDY\fP function call and can be used to save the \fIentire-body\fP into an external storage or for an additional operation like encryption. The \fISendBDY\fP is a special kind of function because it combines the \fISendSTART\fP, \fISend\fP? and \fISendEND\fP... style of function into one single command. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIvalue\fP the \fIentire-body\fP for appending 
.br
\fIlen\fP the size of the \fIentire-body-byte-array\fP (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendL_START(ctx)"
C-API: \fBMqSendL_START\fP, start to append an embedded \fIbody-list-item\fP to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendL_END(ctx)"
C-API: \fBMqSendL_END\fP, finish to append an embedded \fIbody-list-item\fP to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqSendT_START(ctx, MQ_CST callback)"
C-API: \fBMqSendT_START\fP, start to write a \fIlongterm-transaction-item\fP to the \fIsend-data-package\fP. 
.PP
In difference to \fBMqSendEND_AND_WAIT\fP and \fBMqSendEND_AND_CALLBACK\fP a \fIlongterm-transaction-call\fP have to survive an application restart. To achieve this goal two features have to be available to process the results:
.IP "1." 4
a callback as \fIknown\fP service created with \fBMqServiceCreate\fP
.IP "2." 4
one or more \fIdata-item\fP(s) to initialise the environment in the callback
.PP
The \fItransaction-item\fP have to be the first item in the \fIdata-package\fP. The callback is a \fBMqServiceIdentifier\fP and have to be defined with \fBMqServiceCreate\fP in the application setup code (like \fBIServerSetup\fP) to be available after an application restart. This command requires a final \fBMqSendT_END\fP to finish the write. The list of \fIdata-items\fP between \fISTART\fP and \fIEND\fP have to be provided by the programmer and is used to initialise the environment in the \fIcallback\fP. The data is send to the \fIlink-target\fP and returned as first item in the \fIresult-data-package\fP. Use \fBMqReadT_START\fP and \fBMqReadT_END\fP to extract the data. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIcallback\fP a \fBMqServiceIdentifier\fP to identify the target to process the results 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.PP
\fBExample:\fP make a \fIservice-call\fP with \fItransaction-support\fP: 
.PP
.nf
 MqErrorCheck (MqSendSTART (mqctx)); 
 MqErrorCheck (MqSendT_START (mqctx, 'SRVR')); 
 MqErrorCheck (MqSendC (mqctx, 'myEnvironment')); 
 MqErrorCheck (MqSendT_END (mqctx)); 
 MqErrorCheck (MqSendC (mqctx, 'myData')); 
 MqErrorCheck (MqSendEND_AND_WAIT (mqctx, 'SRVC', MQ_TIMEOUT_USER)); 

.fi
.PP
 
.SS "MqSendT_END(ctx)"
C-API: \fBMqSendT_END\fP, finish to write a \fIlongterm-transaction-item\fP to the \fIsend-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SH "READ API"
.PP
\fBMqReadTYPE\fP
.br
 \fBMqReadN\fP
.br
 \fBMqReadBDY\fP
.br
 \fBMqReadU\fP
.br
 \fBMqReadL_START\fP
.br
 \fBMqReadL_END\fP
.br
 \fBMqReadT_START\fP
.br
 \fBMqReadT_END\fP
.br
 \fBMqReadProxy\fP
.br
 \fBMqReadGetNumItems\fP
.br
 \fBMqReadItemExists\fP
.br
 \fBMqReadUndo\fP
.br
.PP
extract data from an incoming \fIread-data-package\fP. 
.PP
\fIReading\fP data is a passive task and the opposite of \fIsending\fP data which is an active task. Passive mean that the \fIread\fP is triggered by an incoming data-package and not by the software-work-flow or the user. There is one \fIread\fP function for every basic type defined in \fBTYPE IDENTIFIER\fP plus a couple of help functions. 
.PP
\fBAttention:\fP
.RS 4
Reading data is an atomic task and should not be split. Only one \fIread-data-package\fP is always in duty. As basic rule read first all data and start the processing afterwards. 
.RE
.PP
.PP
\fBExample:\fP read an \fBMQ_INT\fP and a list of \fBMQ_DBL\fP, \fBMQ_CST\fP and a \fBMQ_BIN\fP: 
.PP
.nf
 MqErrorCheck(MqReadI(ctx, &i));
 MqErrorCheck(MqReadL_START(ctx, NULL));
   MqErrorCheck(MqReadD(ctx, &balance));
   MqErrorCheck(MqReadC(ctx, &owner));
   MqErrorCheck(MqReadB(ctx, &signature));
 MqReadL_END(ctx);

.fi
.PP
.SS "MqReadTYPE(ctx, TYPE *val)"
C-API: \fBMqReadY\fP, read a \fBTYPE IDENTIFIER\fP from the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIval\fP the value to read 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadN(ctx,MQ_CBI * const value, MQ_SIZE * const len)"
C-API: \fBMqReadN\fP, extract a \fIbody-item\fP from the \fIread-data-package\fP 
.PP
A \fIbody-item\fP is a \fIbyte-array\fP with a defined \fIlength\fP and including the \fIsize\fP, \fIdata-type\fP and the \fInative\fP data object as information. The \fIitem\fP extracted can be saved into an external storage and be send later using \fBMqSendN\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIval\fP the \fIbody-item\fP as \fIbyte-array\fP 
.br
\fIlen\fP the \fIbyte-array-length\fP of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadBDY(ctx,MQ_CBI * const value, MQ_SIZE * const len)"
C-API: \fBMqReadBDY\fP, extract the entire \fIbody-package\fP from the \fIread-data-package\fP 
.PP
A \fIbody\fP is a \fIbyte-array\fP with a defined \fIlength\fP and including the \fInumber-of-items\fP and the \fIbody-items\fP as information. The \fIbody\fP extracted can be saved into an external storage or be used in a software tunnel (example: the \fIagurad\fP tool) and be can send later using \fBMqSendBDY\fP. The memory is \fIdynamic-allocated\fP and have to be freed using \fBMqSysFree\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIval\fP the \fIbody\fP as \fIbyte-array\fP 
.br
\fIlen\fP the \fIbyte-array-length\fP of the \fIval\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadU(ctx)"
C-API: \fBMqReadU\fP, extract a \fBtemporary\fP \fBBUFFER API\fP from the \fIread-data-package\fP 
.PP
The object returned is owned by the \fIread-data-package\fP and is \fBonly\fP valid up to the next call of any \fBREAD API\fP function. If a long-term object is required use the C-API function: \fBMqBufferDup\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIval\fP the buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadL_START(ctx, struct MqBufferS *buffer=NULL)"
C-API: \fBMqReadL_START\fP, start to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
Initialize the read with the current \fIbody-item\fP or an optional \fIbuffer-object\fP. This command requires a final \fBMqReadL_END(ctx)\fP to finish the read. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIbuffer\fP an optional \fIbuffer-object\fP as result from a previous \fBMqReadU\fP call or \fINULL\fP to use the next item from the \fIread-data-package\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadL_END(ctx)"
C-API: \fBMqReadL_END\fP, finish to extract a \fIlist-items\fP from the \fIread-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadT_START(ctx, struct MqBufferS *buffer=NULL)"
C-API: \fBMqReadT_START\fP, start to extract a \fIlongterm-transaction-item\fP from the \fIread-data-package\fP. 
.PP
Initialize the read with the \fIcurrent-item\fP or an optional \fIbuffer-object\fP. The \fIcurrent-item\fP have to be the first item in the \fIread-data-package\fP. This command requires a final \fBMqReadL_END(ctx)\fP to finish the read. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIbuffer\fP an optional \fIbuffer-object\fP as result from a previous \fBMqReadU\fP call or \fINULL\fP to use the next item from the \fIread-data-package\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.PP
\fBExample:\fP read the results from a \fIservice-call\fP with \fItransaction-support\fP: 
.PP
.nf
 static enum MqErrorE SRVR ( 
   struct MqS * const mqctx, 
   MQ_PTR data 
 ) 
 { 
   struct MyCtxS *srvctx = (struct MyCtxS*) mqctx; 
   MqErrorCheck (MqReadT_START (mqctx, NULL)); 
   MqErrorCheck (MqReadC (mqctx, &myEnvrironment)); 
   MqErrorCheck (MqReadT_END (mqctx)); 
   MqErrorCheck (MqReadC (mqctx, &theResult)); 
 error: 
   return MqErrorStack (mqctx); 
 } 

.fi
.PP
 
.SS "MqReadT_END(ctx)"
C-API: \fBMqReadT_END\fP, finish to extract a \fIlongterm-transaction-item\fP from the \fIread-data-package\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MqReadProxy(ctx, struct MqS *otherCtx)"
C-API: \fBMqReadProxy\fP, link two \fIcontext-objects\fP to direct pass a data item from one object to the other. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP and the source of the copy 
.br
\fIotherCtx\fP the \fIother-context-object\fP and the target of the copy 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 
.SS "MQ_SIZE MqReadGetNumItems(ctx)"
C-API: \fBMqReadGetNumItems\fP, get the number of items left in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of items as integer 
.RE
.PP
 
.SS "MQ_BOL MqReadItemExists(ctx)"
C-API: \fBMqReadItemExists\fP, check if an item exists in the \fIread-data-package\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
boolean, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
 
.SS "MqReadUndo(ctx)"
C-API: \fBMqReadUndo\fP, undo the last \fBREAD API\fP function call 
.PP
Put the internal position-pointer to the start of the last read \fIbody-item\fP. The next read function call will extract the same item again. Only \fBone\fP undo level is supported. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
.SH "SLAVE API"
.PP
\fBMqSlaveWorker\fP
.br
 \fBMqSlaveCreate\fP
.br
 \fBMqSlaveDelete\fP
.br
 \fBMqSlaveGet\fP
.br
 \fBMqSlaveGetMaster\fP
.br
 \fBMqSlaveIs\fP
.br
.PP
create and manage a slave context 
.PP
The \fImaster-slave-link\fP is used to create a mesh of nodes defined by different \fIparent-context\fP. \fBThe master control the slave.\fP
.PP
The \fImaster-slave-link\fP is used to perform the following tasks:
.IP "\(bu" 2
report error messages from the \fIslave-context\fP to the \fImaster-context\fP 
.IP "\(bu" 2
to create a \fIslave-child-context\fP if a \fImaster-child-context\fP is created
.IP "\(bu" 2
to delete a \fIslave-context\fP if a \fImaster-context\fP is deleted
.PP
In difference to the \fIclient-server-link\fP the \fImaster-slave-link\fP connect two independent \fIparent-context\fP in the same process or thread (e.g. node). This leads to the restriction that only the \fImaster-context\fP can be a \fIserver-context\fP because only one \fIserver-context\fP per node is possible. 
.PP
.nf

       node-0   |           node-1/2        |   node-3/4/5
   ===================================================================
   
   | <- client/server link -> | <- client/server link -> |
   
                | <-- master/slave link --> |
   
                              |- client1-0 -|- server3 ...
                |-  server1  -|             
                |             |- client1-1 -|- server4 ...
     client0-0 -|                           
                |-  server2  -|- client1-2 -|- server5 ...  
.fi
.PP
.PP
\fBDefinition of a 'master-context'\fP
.br
.IP "\(bu" 2
the \fImaster-context\fP is a \fBMqparent-context\fP without a \fBMqchild-context\fP available.
.IP "\(bu" 2
the \fImaster-context\fP is a \fBMqclient-context\fP or a \fBMqserver-context\fP.
.IP "\(bu" 2
the \fImaster-context\fP is responsible to create or delete the \fBMqchild-context\fP of the \fIslave\fP.
.IP "\(bu" 2
the \fImaster-context\fP is responsible to delete the \fBMqparent-context\fP of the \fIslave\fP.
.IP "\(bu" 2
the \fIlink\fP between the \fImaster-context\fP and the \fIslave-context\fP is done using \fBMqSlaveWorker\fP
.PP
\fBDefinition of a 'slave-context'\fP
.br
.IP "\(bu" 2
the \fIslave-context\fP is a \fBMqparent-context\fP without a \fBMqchild-context\fP available.
.IP "\(bu" 2
the \fIslave-context\fP is a \fBMqclient-context\fP.
.IP "\(bu" 2
the \fIslave-context\fP lifetime is controlled by the \fImaster-context\fP.
.IP "\(bu" 2
the \fIslave-context\fP report all error-messages to the \fImaster-context\fP.
.IP "\(bu" 2
a special form of a \fIslave-context\fP is a \fIworker-context\fP 
.PP
\fBDefinition of a 'worker-context'\fP
.br
.IP "\(bu" 2
the \fIworker-context\fP is a \fIslave-context\fP using the image of the \fImaster-context\fP self.
.IP "\(bu" 2
the \fImaster-context\fP have to be a \fBMqserver-context\fP.
.IP "\(bu" 2
the \fIworker-context\fP is created using \fBMqSlaveWorker\fP
.IP "\(bu" 2
the \fIworker-context\fP is identified by a \fIunique\fP integer starting with \fC0\fP.
.PP
.SS "MqSlaveWorker(ctx, MQ_SIZE id, struct MqBufferLS **argv)"
C-API: \fBMqSlaveWorker\fP, create a \fImaster/slave\fP link using the image of the \fIctx\fP object self. 
.PP
The slave-context is started as an independent process or thread based on the \fBstartAs\fP argument. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIargs\fP command-line arguments passed to the \fIworker-client\fP or the \fIworker-server\fP. all arguments prior the first \fB@\fP token are added to the \fIworker-client\fP and the other arguments to the \fIworker-server\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
 \fBexample\fP create a worker with id 7 and name 'MyWorker' as thread. 
.PP
.nf
 MqErrorCheck(MqSlaveWorker (ctx, 7,
    MqBufferLCreateArgsV(ctx, '--thread', '--silent', '@', '--name', 'MyWorker', NULL)
 );

.fi
.PP
.SS "MqSlaveCreate(ctx, MQ_SIZE id, struct MqS *slaveCtx)"
C-API: \fBMqSlaveCreate\fP, create a \fImaster/slave\fP link between the master-context object and the slave-context object 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIslave\fP the \fIslave\fP context object as CLIENT-PARENT without a CHILD 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
The \fIslave-context\fP is owned by the \fImaster-context\fP. This mean that no other external references should be used and the \fIslave-context\fP will be deleted if the \fImaster-context\fP is be deleted. 
.RE
.PP
 
.SS "MqSlaveDelete(ctx, MQ_SIZE id)"
C-API: \fBMqSlaveDelete\fP, Delete a \fIslave\fP object from a \fImaster/slave\fP link identified by \fIid\fP. 
.PP
By default the \fIslave-context\fP object will be deleted if the \fImaster-context\fP is deleted. Use this function to delete the \fIparent-slave-context\fP explicit and brake the \fImaster/slave\fP link. If \fIid\fP is invalid nothing will happen. It is an \fIerror\fP to delete a \fIchild-slave-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
it is still possible to delete a \fIchild-slave-context\fP using \fBMqLinkDelete\fP but this will break the internal master/slave order. 
.RE
.PP
 
.SS "struct MqS* MqSlaveGet(ctx, MQ_SIZE id)"
C-API: \fBMqSlaveGet\fP, get the \fIslave-context\fP from a \fImaster-context\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the \fImaster\fP context object as PARENT without a CHILD 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIslave-context\fP or \fCNULL\fP if \fIid\fP is not valid or \fIcontext\fP is not a \fImaster-context\fP. 
.RE
.PP
 
.SS "struct MqS* MqSlaveGetMaster(ctx)"
C-API: \fBMqSlaveGetMaster\fP, get the \fImaster-context\fP from the \fIslave-context\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fImaster-context\fP or \fINULL\fP if the \fIcontext\fP is no \fIslave-context\fP 
.RE
.PP
 
.SS "MQ_BOL MqSlaveIs(ctx)"
C-API: \fBMqSlaveIs\fP, is the \fIcontext\fP a \fIslave-context\fP ? 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fIMQ_YES\fP or \fIMQ_NO\fP 
.RE
.PP
.SH "BUFFER API"
.PP
\fBMqBufferIdentifer\fP
.br
 \fBMqBufferGetTYPE\fP
.br
 \fBMqBufferType\fP
.br
.PP
a single object to store a \fInative-type-data-item\fP defined by \fBTYPE IDENTIFIER\fP 
.PP
The \fIbuffer-object\fP is returned by \fBMqReadU\fP and is used to save a \fItypeless-temporary-data-item\fP from the \fIread-data-package\fP. The lifetime of the \fIbuffer-object\fP is only the current callback up to the next read operation in the same \fIparent-context\fP. 
.PP
\fBExample:\fP read a \fIbuffer-object\fP and check for \fIstring-type\fP. 
.PP
.nf
 MQ_BUF buf = MqReadU(ctx); 
 if (buf->type == MQ_STRT) 
   printf(buf->cur.C); 

.fi
.PP
.SS "TYPE IDENTIFIER"
a collection of all \fInative-data-types\fP supported 
.PP
The \fItype-identifier\fP (TYPE) is a \fIone-character-value\fP (Y,O,S,I,W,F,D,B,C,L,U) for every \fInative-data-type\fP supported. A \fIbuffer-data-package\fP is type safe, this mean that every item has a \fItype-prefix\fP and every \fBMqReadTYPE\fP or \fBMqBufferGetTYPE\fP have to match the previous \fBMqSendTYPE\fP with the same \fITYPE\fP. One exception is allowed, the cast from and to the \fBMQ_CST\fP data-type (TYPE=C) is allowed. The following type identifier's are available:
.IP "\(bu" 2
\fCY\fP : 1 byte signed character (\fBMQ_BYT\fP)
.IP "\(bu" 2
\fCO\fP : 1 byte boolean value using \fIMQ_YES\fP or \fIMQ_NO\fP (\fBMQ_BOL\fP)
.IP "\(bu" 2
\fCS\fP : 2 byte signed short (\fBMQ_SRT\fP)
.IP "\(bu" 2
\fCI\fP : 4 byte signed integer (\fBMQ_INT\fP)
.IP "\(bu" 2
\fCW\fP : 8 byte signed long long integer (\fBMQ_WID\fP)
.IP "\(bu" 2
\fCF\fP : 4 byte float (\fBMQ_FLT\fP)
.IP "\(bu" 2
\fCD\fP : 8 byte double (\fBMQ_DBL\fP)
.IP "\(bu" 2
\fCB\fP : unsigned char array used for binary data (\fBMQ_BIN\fP)
.IP "\(bu" 2
\fCC\fP : string data using a \fC\\0\fP at the end (\fBMQ_CST\fP)
.IP "\(bu" 2
\fCL\fP : list type able to hold a list of all items from above
.IP "\(bu" 2
\fCU\fP : typeless buffer able to hold a single item from above (\fBMQ_BUF\fP)
.PP
.SS "TYPE MqBufferGetTYPE(MQ_BUF buffer)"
return the data form the buffer using the \fBTYPE IDENTIFIER\fP.
.SS "buffer->type"
return the type as single character of the item stored in the buffer object.
.SH "ERROR OBJECT"
.PP
\fBMqErrorGetText\fP
.br
 \fBMqErrorGetNum\fP
.br
 \fBMqErrorC\fP
.br
 \fBMqErrorSet\fP
.br
 \fBMqErrorSetCONTINUE\fP
.br
 \fBMqErrorSetEXIT\fP
.br
 \fBMqErrorIsEXIT\fP
.br
 \fBMqErrorReset\fP
.br
 \fBMqErrorRaise\fP
.br
 \fBMqErrorPrint\fP
.br
.PP
The \fIerror-object\fP (\fIctx\fP) is used to transport the \fIerror\fP from the \fBlibmsgque\fP context using the \fIprogramming-language\fP error-handling-code.
.PP
\fBExample:\fP catch an error and write the message to stdout: 
.PP
.nf
 if (MqErrorCheckI(MqReadI(ctx, &i))) { 
  printf(MqErrorGetText(ctx)); 
  MqErrorReset(ctx); 
 } 

.fi
.PP
.SS "MQ_CST MqErrorGetText(ctx)"
C-API: \fBMqErrorGetText\fP, 
.PP
\fBReturns:\fP
.RS 4
the \fIerror-message\fP from the \fIexception-object\fP 
.RE
.PP
 
.SS "MQ_INT MqErrorGetNum(ctx)"
C-API: \fBMqErrorGetNum\fP, 
.PP
\fBReturns:\fP
.RS 4
the \fIerror-number\fP from the \fIexception-object\fP. The number can be used as exit-code. 
.RE
.PP
 
.SS "MqErrorC(ctx,MQ_CST prefix, MQ_INT errnum, MQ_CST message)"
C-API: \fBMqErrorC\fP, set the \fIcontext\fP to an \fIerror\fP but do \fBnot\fP raise an \fBERROR OBJECT\fP 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBMqContextCreate\fP 
.br
\fIprefix\fP the error-location like the current function-call or operation 
.br
\fIerrnum\fP the error-number 
.br
\fImessage\fP the error-message 
.RE
.PP
.SS "MqErrorSet(ctx,MQ_INT errnum,enum MqErrorE errorcode,MQ_CST message)"
convert a \fIctx\fP into a libmsgque conform error using the \fIctx\fP object. This method is used to enable additional error processing capabilities from \fBMqLinkDelete\fP or \fBMqExit\fP after the error was caught and before the application exit or the object is deleted.
.SS "MqErrorSetCONTINUE(ctx)"
C-API: \fBMqErrorSetCONTINUE\fP, signal end of processing in an \fBIEvent\fP callback  
.SS "MqErrorSetEXIT(ctx)"
C-API: \fBMqErrorSetEXIT\fP, finish the current \fIcallback\fP, return to \fItoplevel\fP and \fBMqExit\fP the application 
.PP
To exit a application from a callback is a difficult task because the code is \fIin-duty\fP. To achieve this goal a special \fIexit-error-object\fP is created and reported to the \fItoplevel\fP. If a \fItransaction\fP is ongoing the \fBMqSendRETURN\fP is \fBnot\fP called and thus the transaction is not finished. The calling application is informed later by a \fIsocket-down\fP event.  
.SS "MQ_BOL MqErrorIsEXIT(ctx)"
C-API: \fBMqErrorIsEXIT\fP, check for an \fIexit-error-object\fP, return \fIMQ_YES\fP or \fIMQ_NO\fP 
.PP
A \fI\fIexit-error-object\fP is\fP set to signal a fatal error which require an \fIapplication-exit\fP. The \fIonly\fP source of this kind of error is a \fIlink-target-abnormal-exit\fP like a server/network crash or an \fBMqErrorSetEXIT\fP function call. The \fIlink-target-abnormal-exit\fP can only happen for functions doing a network-request like: \fBMqLinkCreate\fP, \fBMqLinkCreateChild\fP, \fBMqLinkConnect\fP, \fBMqSendEND\fP, \fBMqSendEND_AND_WAIT\fP or \fBMqProcessEvent\fP. The goal of this function is to act on an \fIexit-error-object\fP and is used to ignore this error using \fBMqErrorReset\fP and later do a reconnect using \fBMqLinkConnect\fP.
.br
 Read more using from the: \fCtheLink/example/c/Filter4.c\fP example 
.PP
\fBExample:\fP catch and ignore an EXIT return-code: 
.PP
.nf
 if (MqErrorCheckI (MqSendEND_AND_WAIT (ctx, 'TOKS', MQ_TIMEOUT_USER))) { 
   if (MqErrorIsEXIT (ctx)) MqErrorReset (ctx); 
 } 

.fi
.PP
.SS "MqErrorReset(ctx)"
C-API: \fBMqErrorReset\fP, clear the \fIerror\fP and reset the \fIcontext\fP 
.SS "MqErrorRaise(ctx)"
convert the error from an \fIcontext\fP into an \fBERROR OBJECT\fP and raise the object.
.SS "MqErrorPrint(ctx)"
C-API: \fBMqErrorPrint\fP, print the \fIerror\fP from the \fIcontext\fP to stderr and clear the \fIerror\fP afterwards 
.SH "BINARY OBJECT"
.PP
No special \fIbinary-object\fP is used. All \fIbinary-data\fP is available as \fBMQ_BIN\fP.
.SH "CONTEXT LOCAL STORAGE API"
.PP
The \fIapplication-specific-data\fP is available as \fIclass-data-member\fP.
.SH "FILTER MODE"
.PP
modify data using filter technology 
.PP
The filter mode is related to a special usage of the \fBlibmsgque\fP software called a command pipeline. To define a filter create a \fIserver\fP with:
.IP "\(bu" 2
\fBisServer\fP or \fBIServerSetup\fP
.PP
and add a factory:
.IP "\(bu" 2
\fBFACTORY API\fP
.PP
Every filter has \fBtwo\fP context one belongs to the \fIleft\fP command and one belongs to the \fIright\fP command: 
.PP
.nf

 <-- left cmd --> <------- filter -------> <-- right cmd -->

                  <-- left --><- right -->
                  <- server -><- client ->
                  <- master -><- slave -->
                  <-context1-><-context2->

  ... command1   @         filter         @   command2 ...

.fi
.PP
 The \fIleft\fP context is created on application startup and the \fIright\fP context is created as \fIslave\fP of the \fIleft\fP context.
.IP "\(bu" 2
if the \fB@\fP argument is followed by an \fInormal\fP command (server) a local pipeline is created: 
.PP
.nf

client @ filter @ server

.fi
.PP

.IP "\(bu" 2
if the \fB@\fP argument is followed by an option a non-local pipeline is created: 
.PP
.nf

<------------ host-1 -------------> <-- network --> <---------- host-2 ----------->
       <---- client arguments ---->                       <--- server arguments -->
                <-- filter arg. -->
                  <--- options --->

client @ filter @ --tcp --port 7777   ...........   server --tcp --port 7777 --fork

.fi
.PP

.PP
.PP
\fBBI-DIRECTIONAL FILTER\fP
.br
.PP
A bi-directional filter allow a \fIdata-flow\fP in both directions and is used in a \fIclassical\fP client/server application: 
.PP
.nf

    client ... <--> ... server

.fi
.PP
 as a feature enhancement like a protocol-tunnelling: 
.PP
.nf

    client @ mq2tunnel ... <--> ... tunnel2mq @ server

.fi
.PP
 or to convert the protocol into an other protocol: 
.PP
.nf

    client @ mq2soap ... <--> ... soap-server

.fi
.PP
 To define a \fIbi-directional\fP filter a couple of commands provide support:
.IP "\(bu" 2
\fBMqServiceCreate\fP
.IP "  \(bu" 4
use the token \fB+ALL\fP to add a listener for \fIall\fP services. This feature is used for a tunnel to modify the body at all. (example: \fCaguard\fP)
.PP

.IP "\(bu" 2
\fBMqServiceProxy\fP
.IP "  \(bu" 4
use this function to link the \fIleft\fP context with the \fIright\fP context identified with the slave-identifier \fIid\fP (default: 0). No data manipulation is performed.
.PP

.IP "\(bu" 2
\fBMqServiceGetFilter\fP
.IP "  \(bu" 4
in a filter service the current context is used to \fIread\fP the data. To \fIsend\fP the data an other context, belonging to the \fIother\fP site of the communication, have to be used. This function return the context of the other site.
.PP

.IP "\(bu" 2
\fBMqServiceGetToken\fP
.IP "  \(bu" 4
if the token \fB+ALL\fP is used in \fBServiceCreate\fP to add a \fIgeneric\fP service handler the current token is not known. This function return the current token.
.PP

.IP "\(bu" 2
\fBMqServiceIsTransaction\fP
.IP "  \(bu" 4
if the token \fB+ALL\fP is used in \fBServiceCreate\fP to add a \fIgeneric\fP service handler the current transaction-status is not known. This function return the transaction-status as boolean with \fBtrue\fP (with-transaction) or \fBfalse\fP (without-transaction).
.IP "  \(bu" 4
\fBwith-transaction\fP: the package was send with \fBMqSendEND_AND_WAIT\fP or \fBMqSendEND_AND_CALLBACK\fP
.IP "  \(bu" 4
\fBwithout-transaction\fP: the package was send with \fBMqSendEND\fP
.PP

.IP "\(bu" 2
\fBMqReadBDY\fP
.IP "  \(bu" 4
read and return the entire body as binary array. Use this array to apply a transformation to the body at all like encryption (example: \fCaguard\fP) or to save the body in a persistent storage for later use like transaction support (example: \fCatrans\fP)
.PP

.IP "\(bu" 2
\fBMqSendBDY\fP
.IP "  \(bu" 4
send a binary array, as returned by \fBReadBDY\fP, to the filter target.
.PP

.PP
\fBONE-DIRECTIONAL FILTER\fP
.br
.PP
A one-directional filter is a special form of a bi-directional filter and allow a \fIdata-flow\fP from the \fIleft\fP to the \fIright\fP. This filter is well known from the \fBunix\fP shell to link different commands together: 
.PP
.nf

    command1 | command2 | command3

.fi
.PP
 A \fBlibmsgque\fP command pipeline is created with the special character \fB@\fP instead of \fB\fP| : 
.PP
.nf

    msgcmd1 @ msgcmd2 @ msgcmd3

.fi
.PP
 with every command have to use \fBlibmsgque\fP. To define a \fBlibmsgque\fP filter create a service handle with \fBMqServiceCreate\fP or \fBMqServiceProxy\fP for the both special token:
.IP "\(bu" 2
\fB+FTR\fP : required to act on filter data rows. Every filter input data is a list of filter data rows and every row is a list of filter data columns. Every row is send to the following filter-command as \fB+FTR\fP service request.
.IP "\(bu" 2
\fB+EOF\fP : required to act on End-Of-Filter data and is called after all \fB+FTR\fP data was send. Sometimes the filter data can not be served as \fB+FTR\fP data (example: sorting of the input rows need to read all rows before the data can be send to the next filter command) and the\fB+EOF\fP token is used to continue send \fB+FTR\fP data rows.
.PP
and send every data item with \fBMqSendEND_AND_WAIT\fP. 
.SH "PORTABILITY ISSUES"
.PP
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc or i686 processor from the VritualBox emulator.
.SH "EXAMPLES"
.PP
.SS "1. create a server to multiplicate 2 double values and return the result"
.PP
.nf

#include 'string.h'
#include 'msgque.h'
static enum MqErrorE  MMUL( struct MqS *ctx, MQ_PTR data) {
  MQ_DBL d1,d2;
  MqErrorCheck (MqSendSTART(ctx));
  MqErrorCheck (MqReadD(ctx, &d1));
  MqErrorCheck (MqReadD(ctx, &d2));
  MqErrorCheck (MqSendD(ctx, d1*d2));
error:
  return MqSendRETURN(ctx);
}
static enum MqErrorE ServerSetup (struct MqS *ctx, MQ_PTR data) {
  return MqServiceCreate(ctx,'MMUL', MMUL, NULL, NULL);
}
static enum MqErrorE
MulServerFactory (
  struct MqS * const tmpl,
  enum MqFactoryE create,
  struct MqFactoryS * const item,
  struct MqS **contextP
)
{ 
  struct MqS * const ctx = *contextP = MqContextCreate(0,tmpl);
  MqConfigSetServerSetup (ctx, ServerSetup, NULL, NULL, NULL);
  return MQ_OK;
}
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MqFactoryErrorPanic(MqFactoryNew('mulserver', MulServerFactory, NULL, NULL, NULL, NULL, NULL, NULL, &ctx));
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqErrorCheck (MqProcessEvent(ctx,MQ_TIMEOUT,MQ_WAIT_FOREVER));
error:
  MqExit(ctx);
}
.fi
.PP
 Start \fImulserver.c\fP using \fITCP\fP port \fI7777\fP and create a \fIthread\fP for every incoming connection 
.PP
.nf

> mulserver --tcp --port 7777 --thread

.fi
.PP
.SS "2. in a client call the service from 1."
.PP
.nf

#include 'string.h'
#include 'msgque.h'
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MQ_DBL d;
  MqConfigSetName (ctx, 'MyMul');
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqSendSTART(ctx);
  MqSendD(ctx,3.67);
  MqSendD(ctx,22.3);
  MqSendEND_AND_WAIT(ctx, 'MMUL', 10);
  MqErrorCheck (MqReadD(ctx, &d));
  printf('%f\n', d);
error:
  MqExit(ctx);
}
.fi
.PP
 Use \fImulclient.c\fP to connect to \fImulserver.c\fP using \fITCP\fP port \fI7777\fP: 
.PP
.nf

> mulclient --tcp --port 7777

.fi
.PP
.SS "3. create a filter to wrap every column in a '<>' pair"
.PP
.nf

#include 'string.h'
#include 'msgque.h'
static enum MqErrorE  FTR( struct MqS *ctx, MQ_PTR data) {
  MQ_CST str;
  struct MqS * ftr;
  MqErrorCheck (MqServiceGetFilter (ctx, 0, &ftr));
  MqSendSTART(ftr);
  while (MqReadItemExists(ctx)) {
    MqErrorCheck (MqReadC(ctx, &str));
    MqBufferSetV(ctx->temp,'<%s>', str);
    MqSendU(ftr, ctx->temp);
  }
  MqErrorCheck (MqSendEND_AND_WAIT(ftr, '+FTR', MQ_TIMEOUT_USER));
error:
  return MqSendRETURN (ctx);
}
int main (int argc, MQ_CST argv[]) 
{
  struct MqBufferLS * largv = MqBufferLCreateArgs(argc, argv);
  struct MqS * ctx = MqContextCreate(0, NULL);
  MqConfigSetName (ctx, 'ManFilter');
  MqConfigSetIsServer (ctx, MQ_YES);
  MqErrorCheck (MqLinkCreate (ctx, &largv));
  MqErrorCheck (MqServiceCreate (ctx, '+FTR', FTR, NULL, NULL));
  MqErrorCheck (MqServiceProxy  (ctx, '+EOF', 0));
  MqErrorCheck (MqCheckForLeftOverArguments(ctx, &largv));
  MqErrorCheck (MqProcessEvent(ctx,MQ_TIMEOUT,MQ_WAIT_FOREVER));
error:
  MqExit(ctx);
}
.fi
.PP
 Use \fImanfilter.c\fP in a LibMsgque command pipeline: 
.PP
.nf

> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :

.fi
.PP
.SH "SEE ALSO"
.PP
C, C: libmsgqueref(n), C++: ccmsgqueref(n), C#: csmsgqueref(n), JAVA: javamsgqueref(n), PYTHON: pymsgqueref(n), TCL: tclmsgqueref(n), PERL: perlmsgqueref(n), PHP: msgqueforphpref(n), RUBY: rubymsgqueref(n), VB.NET: vbmsgqueref(n)
.SH "KEYWORDS"
.PP
C, unix, socket, message, msgque 
.SH "Author"
.PP 
Generated automatically by Doxygen for libmsgque from the source code.
