.TH "MqBufferListAPI" n "1 Jan 2010" "Version 4.1" "tclmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MqBufferListAPI \- the \fIMsgque Buffer List API\fP is used to manage a list of \fI\fBMqBufferS\fP\fP objects.  

.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBMqBufferLS\fP"
.br
.I "the object to manage an array of \fI\fBMqBufferS\fP\fP items. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLCreate\fP (\fBMQ_SIZE\fP const size)"
.br
.I "create and initialize a \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLCreateArgs\fP (int const argc, \fBMQ_CST\fP argv[])"
.br
.I "create and initialize a \fBMqBufferLS\fP object with argc/argv data "
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLCreateArgsVA\fP (struct \fBMqS\fP *const context, va_list ap)"
.br
.I "create and return a \fC\fBMqBufferLS\fP\fP object using a \fIva_list\fP argument "
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLCreateArgsV\fP (struct \fBMqS\fP *const context,...)"
.br
.I "create and return a \fC\fBMqBufferLS\fP\fP object using \fIvarargs\fP arguments end with \fCNULL\fP "
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLCreateArgsVC\fP (struct \fBMqS\fP *const context, int const argc, \fBMQ_CST\fP argv[])"
.br
.I "create and return a a \fC\fBMqBufferLS\fP\fP object using \fImain\fP startup arguments "
.ti -1c
.RI "MQ_EXTERN struct \fBMqBufferLS\fP * \fBMqBufferLDup\fP (struct \fBMqBufferLS\fP const *const in)"
.br
.I "create an \fBMqBufferLS\fP object as copy from an existing \fI\fBMqBufferLS\fP\fP object "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLDelete\fP (struct \fBMqBufferLS\fP **bufP)"
.br
.I "delete a dynamically created \fI\fBMqBufferLS\fP\fP object "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppend\fP (register struct \fBMqBufferLS\fP *const bufL, struct \fBMqBufferS\fP *const in, \fBMQ_SIZE\fP const position)"
.br
.I "append a \fBMqBufferS\fP item into an \fBMqBufferLS\fP object on \fIposition\fP "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendL\fP (register struct \fBMqBufferLS\fP *const bufL, struct \fBMqBufferLS\fP *const in, \fBMQ_SIZE\fP position)"
.br
.I "copy a \fBMqBufferLS\fP list into an \fBMqBufferLS\fP object on \fIposition\fP "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendY\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_BYT\fP const val)"
.br
.I "append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendO\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_BOL\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendS\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_SRT\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendI\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_INT\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendF\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_FLT\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendW\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_WID\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendD\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_DBL\fP const val)"
.br
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendC\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const val)"
.br
.I "append an \fBMQ_STR\fP object to the \fBend\fP of an \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLAppendU\fP (struct \fBMqBufferLS\fP *const bufL, \fBMQ_BUF\fP const val)"
.br
.I "append an \fBMQ_BUF\fP object to the \fBend\fP of an \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionO\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_BOL\fP *const var)"
.br
.I "search for boolean \fIoption\fP in \fBMqBufferLS\fP list and fill \fIvar\fP with \fBMQ_BOL\fP value for 'found' = \fBMQ_YES\fP and 'not found' = \fBMQ_NO\fP "
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionY\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_BYT\fP *const valP)"
.br
.I "search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionS\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_SRT\fP *const valP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionI\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_INT\fP *const valP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionF\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_FLT\fP *const valP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionW\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_WID\fP *const valP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionD\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_DBL\fP *const valP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionC\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_STR\fP *const var)"
.br
.I "search for an \fIoption\fP with an \fBMQ_STR\fP argument in an \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLCheckOptionU\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_CST\fP const opt, \fBMQ_BUF\fP *const var)"
.br
.I "search for an \fIoption\fP with an \fBMQ_BUF\fP argument in an \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLMove\fP (struct \fBMqBufferLS\fP *const to, struct \fBMqBufferLS\fP **fromP)"
.br
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLDeleteItem\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, const \fBMQ_SIZE\fP index, const \fBMQ_SIZE\fP numitems, const \fBMQ_BOL\fP doDelete)"
.br
.I "delete the \fIindex'th\fP list item from the \fBMqBufferLS\fP object "
.ti -1c
.RI "MQ_EXTERN \fBMQ_SIZE\fP \fBMqBufferLSearchC\fP (struct \fBMqBufferLS\fP const *const bufL, \fBMQ_CST\fP const str, \fBMQ_SIZE\fP const len, \fBMQ_SIZE\fP const startindex)"
.br
.I "search \fBMQ_STR\fP item from a \fBMqBufferLS\fP object starting at \fIstartindex\fP "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLLog\fP (struct \fBMqS\fP const *const context, struct \fBMqBufferLS\fP const *const bufL, \fBMQ_CST\fP const func)"
.br
.I "output a \fBMqBufferLS\fP object for debugging purpose to stderr "
.ti -1c
.RI "MQ_EXTERN void \fBMqBufferLLogS\fP (struct \fBMqS\fP const *const context, struct \fBMqBufferLS\fP const *const bufL, \fBMQ_CST\fP const func, \fBMQ_CST\fP const varname)"
.br
.I "\fIshort\fP output a \fBMqBufferLS\fP object for debugging purpose to stderr "
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqBufferLGetU\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP *const bufL, \fBMQ_SIZE\fP const index, struct \fBMqBufferS\fP **const var)"
.br
.I "get an \fBMqBufferS\fP object from the buffer list \fIbuf\fP "
.in -1c
.SH "Detailed Description"
.PP 
the \fIMsgque Buffer List API\fP is used to manage a list of \fI\fBMqBufferS\fP\fP objects. 

the memory is allocated and extended dynamically. 
.SH "Function Documentation"
.PP 
.SS "MQ_EXTERN void MqBufferLAppend (register struct \fBMqBufferLS\fP *const  bufL, struct \fBMqBufferS\fP *const  in, \fBMQ_SIZE\fP const  position)"
.PP
append a \fBMqBufferS\fP item into an \fBMqBufferLS\fP object on \fIposition\fP 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIin\fP the \fBMqBufferS\fP object to append 
.br
\fIposition\fP insert \fIin\fP at \fIposition\fP, shift all following arguments one up 
.RE
.PP
\fBAttention:\fP
.RS 4
Set \fIposition\fP to \fB0\fP to append to the beginning or set position to \fB-1\fP to append to the end 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLAppendC (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  val)"
.PP
append an \fBMQ_STR\fP object to the \fBend\fP of an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the string for input 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLAppendD (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_DBL\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendF (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_FLT\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendI (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_INT\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendL (register struct \fBMqBufferLS\fP *const  bufL, struct \fBMqBufferLS\fP *const  in, \fBMQ_SIZE\fP position)"
.PP
copy a \fBMqBufferLS\fP list into an \fBMqBufferLS\fP object on \fIposition\fP 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIin\fP the \fBMqBufferLS\fP object to append 
.br
\fIposition\fP insert \fIin\fP at \fIposition\fP, shift all following arguments one up 
.RE
.PP
\fBAttention:\fP
.RS 4
Set \fIposition\fP to \fB0\fP to append to the beginning or set position to \fB-1\fP to append to the end 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLAppendO (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_BOL\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendS (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_SRT\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendU (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_BUF\fP const  val)"
.PP
append an \fBMQ_BUF\fP object to the \fBend\fP of an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the buffer for input 
.RE
.PP
\fBAttention:\fP
.RS 4
after the insert the buffer is owed by the \fIbuf\fP object -> do \fBnot\fP free \fIval\fP 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLAppendW (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_WID\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP
 
.SS "MQ_EXTERN void MqBufferLAppendY (struct \fBMqBufferLS\fP *const  bufL, \fBMQ_BYT\fP const  val)"
.PP
append a native typed value to the \fBend\fP of a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIval\fP the value to append to 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionC (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_STR\fP *const  var)"
.PP
search for an \fIoption\fP with an \fBMQ_STR\fP argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvar\fP the MQ_STR argument for return 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.br
 The return string \fIvar\fP has dynamic allocated data and have to be freed later.
.br
 if the original value of \fC*var != NULL\fP than the memory is freed before set with the new value. 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionD (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_DBL\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP
  
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionF (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_FLT\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP
  
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionI (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_INT\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP
 
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionO (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_BOL\fP *const  var)"
.PP
search for boolean \fIoption\fP in \fBMqBufferLS\fP list and fill \fIvar\fP with \fBMQ_BOL\fP value for 'found' = \fBMQ_YES\fP and 'not found' = \fBMQ_NO\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIvar\fP if \fIoption\fP string is found set \fIvar\fP with \fIdef\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found the entry is deleted from the \fBMqBufferLS\fP object 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionS (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_SRT\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP
 
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionU (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_BUF\fP *const  var)"
.PP
search for an \fIoption\fP with an \fBMQ_BUF\fP argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvar\fP the MQ_BUF argument for return 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionW (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_WID\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP
  
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLCheckOptionY (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_CST\fP const  opt, \fBMQ_BYT\fP *const  valP)"
.PP
search for an \fIoption\fP with native typed argument in an \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on or \fCNULL\fP 
.br
\fIopt\fP find option string in the \fBMqBufferLS\fP list 
.br
\fIvalP\fP the native option value to search for 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIoption\fP is found, the entry \fBand\fP his argument will be deleted from the \fBMqBufferLS\fP object 
.RE
.PP

.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLCreate (\fBMQ_SIZE\fP const  size)\fC [read]\fP"
.PP
create and initialize a \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP create the object with a predefined list size 
.RE
.PP
\fBReturns:\fP
.RS 4
the new created and initialized \fBMqBufferLS\fP object 
.RE
.PP

.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLCreateArgs (int const  argc, \fBMQ_CST\fP argv[])\fC [read]\fP"
.PP
create and initialize a \fBMqBufferLS\fP object with argc/argv data 
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP the argc from the initial \fBmain\fP function 
.br
\fIargv\fP the arguments from the initial \fBmain\fP function 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIargs\fP the new created \fBMqBufferLS\fP object including all arguments from argv \fBbefore\fP the first \fBMQ_ALFA\fP 
.br
\fIalfa\fP the new created \fBMqBufferLS\fP object including all arguments from argv \fBafter\fP the first \fBMQ_ALFA\fP
.RE
.PP
This function is usually called by the client (the initiator) of a msgque request. The \fIalfa\fP arguments will be used to start the server during the creation of the msgque object in \fBMqLinkCreate\fP. 
.PP
.nf
int
main ( int argc, char **argv)
{
  // the command-line-arguments before (largv) and after (lalfa) the first MQ_ALFA
  struct MqBufferLS * largv, lalfa;
  MqBufferLCreateArgv(NULL, argc, argv, &largv, &lalfa);
....

.fi
.PP
 
.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLCreateArgsV (struct \fBMqS\fP *const  context,  ...)\fC [read]\fP"
.PP
create and return a \fC\fBMqBufferLS\fP\fP object using \fIvarargs\fP arguments end with \fCNULL\fP 
.PP
.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLCreateArgsVA (struct \fBMqS\fP *const  context, va_list ap)\fC [read]\fP"
.PP
create and return a \fC\fBMqBufferLS\fP\fP object using a \fIva_list\fP argument 
.PP
.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLCreateArgsVC (struct \fBMqS\fP *const  context, int const  argc, \fBMQ_CST\fP argv[])\fC [read]\fP"
.PP
create and return a a \fC\fBMqBufferLS\fP\fP object using \fImain\fP startup arguments 
.PP
.SS "MQ_EXTERN void MqBufferLDelete (struct \fBMqBufferLS\fP ** bufP)"
.PP
delete a dynamically created \fI\fBMqBufferLS\fP\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIbufP\fP the pointer to an struct \fBMqBufferLS\fP * object 
.RE
.PP
\fBAttention:\fP
.RS 4
The memory will be freed and the object-pointer will be set to \fBNULL\fP. If the object-pointer is already \fBNULL\fP nothing will be done. 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLDeleteItem (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, const \fBMQ_SIZE\fP index, const \fBMQ_SIZE\fP numitems, const \fBMQ_BOL\fP doDelete)"
.PP
delete the \fIindex'th\fP list item from the \fBMqBufferLS\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIindex\fP the index'th object from the \fBMqBufferLS\fP object starting with 0 
.br
\fInumitems\fP delete number of items 
.br
\fIdoDelete\fP if \fIdelete\fP != 0 delete the \fI\fBMqBufferS\fP\fP object, associated with the index, too 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP

.SS "MQ_EXTERN struct \fBMqBufferLS\fP* MqBufferLDup (struct \fBMqBufferLS\fP const *const  in)\fC [read]\fP"
.PP
create an \fBMqBufferLS\fP object as copy from an existing \fI\fBMqBufferLS\fP\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP the \fI\fBMqBufferLS\fP\fP object to copy from 
.RE
.PP
\fBReturns:\fP
.RS 4
out the \fI\fBMqBufferLS\fP\fP object to create 
.RE
.PP

.SS "MQ_EXTERN enum \fBMqErrorE\fP MqBufferLGetU (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP *const  bufL, \fBMQ_SIZE\fP const  index, struct \fBMqBufferS\fP **const  var)"
.PP
get an \fBMqBufferS\fP object from the buffer list \fIbuf\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIindex\fP get the \fIindex'th\fP element of the \fIbuf\fP list 
.RE
.PP
\fBReturn values:\fP
.RS 4
\fIvar\fP the \fBMqBufferS\fP object to return 
.RE
.PP
\fBAttention:\fP
.RS 4
the \fIindex'th\fP element of the \fIbuf\fP list \fBwill\fP be deleted from the buffer list 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if \fIbufL\fP is \fBnot\fP \fCNULL\fP the object from \fIbufL\fP will be deleted first 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLLog (struct \fBMqS\fP const *const  context, struct \fBMqBufferLS\fP const *const  bufL, \fBMQ_CST\fP const  func)"
.PP
output a \fBMqBufferLS\fP object for debugging purpose to stderr 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIfunc\fP prefix to identify the debugging output 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLLogS (struct \fBMqS\fP const *const  context, struct \fBMqBufferLS\fP const *const  bufL, \fBMQ_CST\fP const  func, \fBMQ_CST\fP const  varname)"
.PP
\fIshort\fP output a \fBMqBufferLS\fP object for debugging purpose to stderr 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIfunc\fP prefix to identify the debugging output 
.br
\fIvarname\fP prefix to identify the variable name 
.RE
.PP

.SS "MQ_EXTERN void MqBufferLMove (struct \fBMqBufferLS\fP *const  to, struct \fBMqBufferLS\fP ** fromP)"
.PP
.SS "MQ_EXTERN \fBMQ_SIZE\fP MqBufferLSearchC (struct \fBMqBufferLS\fP const *const  bufL, \fBMQ_CST\fP const  str, \fBMQ_SIZE\fP const  len, \fBMQ_SIZE\fP const  startindex)"
.PP
search \fBMQ_STR\fP item from a \fBMqBufferLS\fP object starting at \fIstartindex\fP 
.PP
\fBParameters:\fP
.RS 4
\fIbufL\fP the \fBMqBufferLS\fP object to work on 
.br
\fIstr\fP the string to search for 
.br
\fIlen\fP the length of \fIstr\fP 
.br
\fIstartindex\fP start searching in \fIbuf\fP from index \fIstartindex\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The index of the \fIstr\fP found or -1 if not found. The return value can be used as startindex of following calls to \fIMqBufferLSearchC\fP 
.RE
.PP
a typical usage for this code is parsing an \fBMqBufferLS\fP object for multiple occurrences of a string 
.PP
.nf
 while ((startindex = MqBufferLSearchC (buf, str, startindex)) != -1) {
   ...
 }

.fi
.PP
 
.PP
\fBAttention:\fP
.RS 4
The size of \fIstr\fP have to be at least 4 bytes 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for tclmsgque from the source code.
