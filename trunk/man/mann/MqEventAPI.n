.TH "MqEventAPI" n "1 Jan 2010" "Version 4.1" "tclmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MqEventAPI \- handle different aspects of the \fI\fBMqS\fP\fP event-queue  

.PP
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBMqWaitOnEventE\fP { \fBMQ_WAIT_NO\fP =  0, \fBMQ_WAIT_ONCE\fP =  1, \fBMQ_WAIT_FOREVER\fP =  2 }"
.br
.I "wait for an event? "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "MQ_EXTERN enum \fBMqErrorE\fP \fBMqProcessEvent\fP (struct \fBMqS\fP *const context, \fBMQ_TIME_T\fP timeout, enum \fBMqWaitOnEventE\fP const wait)"
.br
.I "Waiting for an incoming packet on all open msgque objects. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBEventCreateF\fP )(struct \fBMqS\fP *const )"
.br
.I "prototype for a Event-Check function "
.in -1c
.SH "Detailed Description"
.PP 
handle different aspects of the \fI\fBMqS\fP\fP event-queue 

the event-queue have to be linked into an existing event-processing infrastructure. the linking is done by defining prototypes for two independent functions:
.IP "\(bu" 2
\fBMqEventF\fP is used to call an external event processing function (e.g. \fCTcl_DoOneEvent\fP)
.IP "\(bu" 2
\fBEventCreateF\fP is used to add events, created by the file-handles owned by the \fI\fBMqS\fP\fP objects, into the external event-queue (e.g. \fCTcl_QueueEvent\fP)
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBMqWaitOnEventE\fP"
.PP
wait for an event? 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMQ_WAIT_NO \fP\fP
just do the check 
.TP
\fB\fIMQ_WAIT_ONCE \fP\fP
wait for one new event 
.TP
\fB\fIMQ_WAIT_FOREVER \fP\fP
wait forever 
.PP
Definition at line 334 of file msgque.h.
.SH "Function Documentation"
.PP 
.SS "MQ_EXTERN enum \fBMqErrorE\fP MqProcessEvent (struct \fBMqS\fP *const  context, \fBMQ_TIME_T\fP timeout, enum \fBMqWaitOnEventE\fP const  wait)"
.PP
Waiting for an incoming packet on all open msgque objects. 
.PP
This function is used to wait for (e.g. \fBMQ_WAIT_ONCE\fP) or check (e.g. \fBMQ_WAIT_NO\fP) for an incoming event. If an event occurs the header of the Msgque packet is parsed and the according service-handle is called. if \fBMQ_WAIT_FOREVER\fP is set the function will never return, accept for an error or on exit. This function is usually used on a server to enter the event-loop and wait for incoming service requests.
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItimeout\fP \fBtime_t\fP type value for timeout in seconds. A value of \fC-1\fP is used as \fIdefault\fP using \fBMQ_TIMEOUT\fP seconds. 
.br
\fIwait\fP should the code wait forever (e.g. \fBMQ_WAIT_FOREVER\fP), just wait for the next event (e.g. \fBMQ_WAIT_ONCE\fP) or just return after one single test (\fBMQ_WAIT_NO\fP)' 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP
.RE
.PP
\fBAttention:\fP
.RS 4
The \fItimeout\fP argument is only used if \fBMQ_WAIT_ONCE\fP is set.
.RE
.PP
A typical server looks like: 
.PP
.nf
...
MqErrorCheck(MqLinkCreate(ctx,argv,alfa);
...
MqErrorCheck(MqProcessEvent(ctx, MQ_TIMEOUT, MQ_WAIT_FOREVER);
...
MqLinkDelete(ctx);
...

.fi
.PP
 
.SH "Variable Documentation"
.PP 
.SS "enum \fBMqErrorE\fP( * \fBEventCreateF\fP)(struct \fBMqS\fP *const )"
.PP
prototype for a Event-Check function 
.PP
This function is called by the \fBlibmsgque\fP event-loop as idle-task in \fBMqProcessEvent\fP 
.SH "Author"
.PP 
Generated automatically by Doxygen for tclmsgque from the source code.
