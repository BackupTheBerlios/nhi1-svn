.TH "Mq_Service_C_API" n "Mon Jan 10 2011" "Version 4.8" "csmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Mq_Service_C_API \- 
.PP
create and manage services  

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBMQ_CST\fP \fBMQ_TOK\fP"
.br
.RI "\fIa 4 byte string to identify different services \fP"
.ti -1c
.RI "typedef \fBMqTokenF\fP \fBMqServiceCallbackF\fP"
.br
.RI "\fIfunction used as \fIservice-handle\fP \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBMqWaitOnEventE\fP { \fBMQ_WAIT_NO\fP =  0, \fBMQ_WAIT_ONCE\fP =  1, \fBMQ_WAIT_FOREVER\fP =  2 }"
.br
.RI "\fIwait for an event? \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceGetFilter\fP (struct \fBMqS\fP *const ctx, \fBMQ_SIZE\fP const id, struct \fBMqS\fP **filter)"
.br
.RI "\fIget the \fIfilter-context\fP or the \fImaster-context\fP \fP"
.ti -1c
.RI "struct \fBMqS\fP *const \fBMqServiceGetFilter2\fP (struct \fBMqS\fP *const ctx, \fBMQ_SIZE\fP const id)"
.br
.RI "\fIget the \fIfilter-context\fP or the \fImaster-context\fP \fP"
.ti -1c
.RI "int \fBMqServiceIsTransaction\fP (struct \fBMqS\fP const *const ctx)"
.br
.RI "\fIcheck if the \fIongoing-service-call\fP belongs to a transaction \fP"
.ti -1c
.RI "\fBMQ_TOK\fP \fBMqServiceGetToken\fP (struct \fBMqS\fP const *const ctx)"
.br
.RI "\fIget the \fBTOKEN IDENTIFIER\fP from an \fIongoing-service-call\fP \fP"
.ti -1c
.RI "\fBMQ_BOL\fP \fBMqServiceCheckToken\fP (struct \fBMqS\fP const *const ctx, \fBMQ_TOK\fP const token)"
.br
.RI "\fIin an \fIongoing-service-call\fP compare the \fBTOKEN IDENTIFIER\fP with \fItoken\fP on equity \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceCreate\fP (struct \fBMqS\fP *const ctx, \fBMQ_TOK\fP const token, \fBMqServiceCallbackF\fP const callback, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP datafreeF)"
.br
.RI "\fIcreate a link between a \fBTOKEN IDENTIFIER\fP and a \fBSERVICE CALLBACK\fP \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceProxy\fP (struct \fBMqS\fP *const ctx, \fBMQ_TOK\fP const token, \fBMQ_SIZE\fP const id)"
.br
.RI "\fIcreate a service to link a \fImaster-context\fP with a \fIslave-context\fP. \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceDelete\fP (struct \fBMqS\fP *const ctx, \fBMQ_TOK\fP const token)"
.br
.RI "\fIdelete a service. \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqProcessEvent\fP (struct \fBMqS\fP *const ctx, \fBMQ_TIME_T\fP timeout, enum \fBMqWaitOnEventE\fP const wait)"
.br
.RI "\fIenter the \fIevent-loop\fP and wait for an incoming \fIservice-request\fP. \fP"
.in -1c
.SH "Detailed Description"
.PP 
create and manage services 

To provide a \fIservice\fP is the main purpose of a server and the main-purpose of a \fIclient/server\fP connection is to call a service and to process the results. A service have to be defined on a server during \fIlink-setup\fP (\fBIServerSetup\fP) with the \fBServiceCreate\fP function. The cleanup is done implicit on \fIlink-delete\fP or explicit with the \fBServiceDelete\fP function. 
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBMQ_CST\fP \fBMQ_TOK\fP"
.PP
a 4 byte string to identify different services The \fItoken-identifier\fP is defined by the programmer using \fBServiceCreate\fP to link a \fIservice-handler\fP with an \fIidentifier\fP. The \fIidentifier\fP is part of the \fBSendEND\fP, \fBSendEND_AND_WAIT\fP or \fBSendEND_AND_CALLBACK\fP function-call to access the services.
.br
 For internal purpose some special \fItoken\fP are predefined:
.IP "\(bu" 2
\fB_???\fP - all \fItoken\fP starting with a \fB'_'\fP are for \fBinternal\fP usage only
.IP "\(bu" 2
\fB+ALL\fP - used in \fBServiceCreate\fP and \fBServiceDelete\fP to listen on \fBall\fP token not handled by other \fItoken\fP more precise
.IP "\(bu" 2
\fB-ALL\fP - used in \fBServiceDelete\fP to delete \fBall\fP token
.IP "\(bu" 2
\fB+FTR\fP and \fB+EOF\fP - used for \fIone-directional-filter\fP 
.PP

.PP
Definition at line 1989 of file msgque.h.
.SS "typedef \fBMqTokenF\fP \fBMqServiceCallbackF\fP"
.PP
function used as \fIservice-handle\fP A service is using a \fIcallback\fP to act on an incoming \fIservice-request\fP. The \fIcallback\fP is linked to a \fBTOKEN IDENTIFIER\fP with \fBServiceCreate\fP or is used as argument to the \fBSendEND_AND_CALLBACK\fP function. 
.PP
Definition at line 1998 of file msgque.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBMqWaitOnEventE\fP"
.PP
wait for an event? 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMQ_WAIT_NO \fP\fP
just do the check 
.TP
\fB\fIMQ_WAIT_ONCE \fP\fP
wait for one new event 
.TP
\fB\fIMQ_WAIT_FOREVER \fP\fP
wait forever 
.PP
Definition at line 2001 of file msgque.h.
.SH "Function Documentation"
.PP 
.SS "enum \fBMqErrorE\fP MqProcessEvent (struct \fBMqS\fP *constctx, \fBMQ_TIME_T\fPtimeout, enum \fBMqWaitOnEventE\fP constwait)"
.PP
enter the \fIevent-loop\fP and wait for an incoming \fIservice-request\fP. This function is used to enter the \fIevent-loop\fP and start listen on open \fIfile-handles\fP and to call \fBIEvent\fP on idle.
.br
 This function is direct used on a server to enter the \fIevent-loop\fP and wait for incoming service requests or after the \fBSendEND_AND_CALLBACK\fP function to wait for the \fIservice-result\fP. This function is indirect used in \fBSendEND_AND_WAIT\fP too.
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fItimeout\fP the maximum \fIwait-time\fP in seconds until a \fItimeout-error\fP is raised, possible values are:
.IP "\(bu" 2
\fB>0\fP, use this value as number of seconds.
.IP "\(bu" 2
\fB\fCMqS.TIMEOUT.DEFAULT\fP = -1\fP, request the default timeout value . \fCMqS.TIMEOUT.USER\fP for \fCMqS.WAIT.ONCE\fP or \fCMqS.TIMEOUT.MAX\fP for \fCMqS.WAIT.FOREVER\fP. \fBdefault\fP 
.IP "\(bu" 2
\fB\fCMqS.TIMEOUT.USER\fP = -2\fP, request the user defined timeout value from the \fBtimeout\fP configuration value 
.IP "\(bu" 2
\fB\fCMqS.TIMEOUT.MAX\fP = -3\fP, request the maximum possible (infinite) timeout value 
.PP
.br
\fIwait\fP the \fIoperation-mode\fP used to define the behaviour, possible values are:
.IP "\(bu" 2
\fB\fCMqS.WAIT.NO\fP = 0\fP, don't wait for an event just do the check and comeback. if an Event is available process the event, but only one. If no Event is available return with \fBMQ_CONTINUE\fP. \fBdefault\fP 
.IP "\(bu" 2
\fB\fCMqS.WAIT.ONCE\fP = 1\fP, wait maximum \fItimeout\fP seconds for only \fIone\fP event or raise a \fItimeout-error\fP if no event was found.
.IP "\(bu" 2
\fB\fCMqS.WAIT.FOREVER\fP = 2\fP, wait maximum \fItimeout\fP seconds for a event. If an event was found process the event. If no event was found, raise a \fItimeout-error\fP. After the event was processed continue to listen for a the new event. The function will only come back on \fIerror\fP or on \fIexit\fP.
.PP
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "\fBMQ_BOL\fP MqServiceCheckToken (struct \fBMqS\fP const *constctx, \fBMQ_TOK\fP consttoken)"
.PP
in an \fIongoing-service-call\fP compare the \fBTOKEN IDENTIFIER\fP with \fItoken\fP on equity \fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fItrue\fP or \fIfalse\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceCreate (struct \fBMqS\fP *constctx, \fBMQ_TOK\fP consttoken, \fBMqServiceCallbackF\fP constcallback, \fBMQ_PTR\fPdata, \fBMqTokenDataFreeF\fPdatafreeF)"
.PP
create a link between a \fBTOKEN IDENTIFIER\fP and a \fBSERVICE CALLBACK\fP The \fItoken\fP have to be unique but the \fIcallback\fP not, this is called an \fIalias\fP. Use \fBstring ServiceGetToken()\fP to get the current token in an \fIincoming-service-call\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIcallback\fP the function to process the incoming \fIservice-request\fP 
.br
\fIdata\fP a user defined additional \fIdata-argument\fP for the \fIcallback\fP function (C-API only) 
.br
\fIdatafreeF\fP the function to free the \fIdata-argument\fP after use (C-API only) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP
\fBAttention:\fP
.RS 4
the link-setup (\fBLinkCreate\fP or \fBLinkCreateChild\fP) have to done \fBbefore\fP using this function 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceDelete (struct \fBMqS\fP *constctx, \fBMQ_TOK\fP consttoken)"
.PP
delete a service. \fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceGetFilter (struct \fBMqS\fP *constctx, \fBMQ_SIZE\fP constid, struct \fBMqS\fP **filter)"
.PP
get the \fIfilter-context\fP or the \fImaster-context\fP A \fIfilter-pipeline\fP has two context, one on the left and one on the right. The \fIleft-context\fP is linked with the \fImaster-context\fP and the \fIright-context\fP is linked to the \fIslave-context\fP. This function extract the \fIother-context\fP related to the initial \fIctx\fP argument using the following order:
.IP "1." 4
return the \fImaster-context\fP if not NULL
.IP "2." 4
return the \fIslave-context\fP using \fIid\fP if not NULL
.IP "3." 4
return a 'filter not available' error
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.br
\fIfilter\fP the \fIother-context\fP or \fInull\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "struct \fBMqS\fP* const MqServiceGetFilter2 (struct \fBMqS\fP *constctx, \fBMQ_SIZE\fP constid)\fC [read]\fP"
.PP
get the \fIfilter-context\fP or the \fImaster-context\fP A \fIfilter-pipeline\fP has two context, one on the left and one on the right. The \fIleft-context\fP is linked with the \fImaster-context\fP and the \fIright-context\fP is linked to the \fIslave-context\fP. This function extract the \fIother-context\fP related to the initial \fIctx\fP argument using the following order:
.IP "1." 4
return the \fImaster-context\fP if not NULL
.IP "2." 4
return the \fIslave-context\fP using \fIid\fP if not NULL
.IP "3." 4
return a 'filter not available' error
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fIid\fP an \fIinteger\fP used as \fIunique\fP identifer for the master/slave link 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fIfilter-context\fP or \fInull\fP if the \fIcontext\fP has no \fIfilter-context\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
if no filter is available an error-message is created in the context 
.RE
.PP

.SS "\fBMQ_TOK\fP MqServiceGetToken (struct \fBMqS\fP const *constctx)"
.PP
get the \fBTOKEN IDENTIFIER\fP from an \fIongoing-service-call\fP This function is needed on the server to process a \fIservice-request\fP defined as \fI+ALL\fP or as an \fIalias\fP to extract the \fIcurrent\fP \fBTOKEN IDENTIFIER\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBTOKEN IDENTIFIER\fP 
.RE
.PP

.SS "int MqServiceIsTransaction (struct \fBMqS\fP const *constctx)"
.PP
check if the \fIongoing-service-call\fP belongs to a transaction A \fIservice-call\fP can be \fIwith-transaction\fP (return \fItrue\fP if the package was send with \fBSendEND_AND_WAIT\fP or \fBSendEND_AND_CALLBACK\fP) or can be \fIwithout-transaction\fP (return \fIfalse\fP if the package was send with \fBSendEND\fP) 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
a boolean value, \fItrue\fP or \fIfalse\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceProxy (struct \fBMqS\fP *constctx, \fBMQ_TOK\fP consttoken, \fBMQ_SIZE\fP constid)"
.PP
create a service to link a \fImaster-context\fP with a \fIslave-context\fP. This function is used to create a \fIproxy-service\fP to forward the \fIbody-data\fP from the \fIread-data-package\fP of the \fImaster\fP to the \fIsend-data-package\fP of the slave. The data is \fInot\fP changed. This function support the \fIreverse-operation\fP also. If the \fIctx\fP is a \fImaster-context\fP than the data is send to \fIslave\fP identified by \fIid\fP. If the \fIctx\fP is a \fIslave-context\fP than the data is send to the \fImaster\fP of the \fIslave\fP. Use \fIid=0\fP to send that data to the \fIfilter-context\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fItoken\fP the \fBTOKEN IDENTIFIER\fP to identify the service 
.br
\fIid\fP the slave identifier, only used if \fIctx\fP is a \fImaster-context\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for csmsgque from the source code.
