.TH "MqMsgqueAPI" n "1 Jan 2010" "Version 4.1" "tclmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MqMsgqueAPI \- the toplevel \fBlibmsgque\fP object: \fBMqS\fP  

.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBMqLinkS\fP"
.br
.R "object responsible to manage client/server link data "
.ti -1c
.RI "struct \fBMqErrorS\fP"
.br
.R "error-object data type "
.ti -1c
.RI "struct \fBMqS\fP"
.br
.R "Prototype for a context object. "
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBMQ_MqS_SIGNATURE\fP   0x212CF91"
.br
.R "signature used in \fBMqS::signature\fP "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBMqBufferLS\fP * \fBMqInitCreate\fP (void)"
.br
.R "setup and return the \fIinit\fP object "
.ti -1c
.RI "void \fBMqInitSysAPI\fP (\fBMqForkF\fP forkF, \fBMqVForkF\fP vforkF)"
.br
.R "helper to set the application specific \fCfork\fP functions "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqLinkCreate\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP **argsP)"
.br
.R "create a parent \fBlibmsgque\fP object link "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqLinkCreateChild\fP (struct \fBMqS\fP *const context, struct \fBMqS\fP *const parent, struct \fBMqBufferLS\fP **argsP)"
.br
.R "create a child \fBlibmsgque\fP object link "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqDefaultLinkCreate\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP **argsP)"
.br
.R "wrapper for \fBMqLinkCreate\fP with \fIargv\fP error check "
.ti -1c
.RI "void \fBMqLinkDelete\fP (struct \fBMqS\fP *const context)"
.br
.R "delete a \fBlibmsgque\fP object "
.ti -1c
.RI "void \fBMqExit\fP (struct \fBMqS\fP *context)"
.br
.R "exit the current process or thread "
.ti -1c
.RI "\fBMQ_STR\fP \fBMqHelp\fP (\fBMQ_CST\fP tool)"
.br
.R "write \fBlibmsgque\fP specific user-help to stderr "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqCheckForLeftOverArguments\fP (struct \fBMqS\fP *const context, struct \fBMqBufferLS\fP **argvP)"
.br
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceCreate\fP (struct \fBMqS\fP *const context, \fBMQ_CST\fP const token, \fBMqTokenF\fP const proc, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP datafreeF)"
.br
.R "create a service handle "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceProxy\fP (struct \fBMqS\fP *const context, \fBMQ_CST\fP const token, \fBMQ_SIZE\fP const id)"
.br
.R "use a proxy to proxy the incomming trafic to the outgoing trafic "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqServiceDelete\fP (struct \fBMqS\fP const *const context, \fBMQ_CST\fP const token)"
.br
.R "delete service handle "
.ti -1c
.RI "\fBMQ_BOL\fP \fBMqCurrentTokenIs\fP (struct \fBMqS\fP const *const context, char const *const token)"
.br
.R "check the current token "
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqProcessEvent\fP (struct \fBMqS\fP *const context, \fBMQ_TIME_T\fP timeout, enum \fBMqWaitOnEventE\fP const wait)"
.br
.R "Waiting for an incoming packet on all open msgque object links. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBMqBufferLS\fP * \fBMqInitBuf\fP"
.br
.R "the prefix arguments of the starting application "
.ti -1c
.RI "\fBMqFactorySelectorF\fP \fBMqFactorySelector\fP"
.br
.R "name of a procedure to return \fImain\fP like entry-points "
.in -1c
.SH "Detailed Description"
.PP 
the toplevel \fBlibmsgque\fP object: \fBMqS\fP 

Every user defined context object has a \fBMqS\fP object as first parameter: 
.PP
.nf
struct MyCtx {
  struct MqS  mqctx;
  int         mydata;
  ...
}

.fi
.PP
 The \fBMqS\fP object is created with the \fBMqContextCreate\fP function and is used as toplevel \fBlibmsgque\fP context and handle. Near every \fBlibmsgque\fP function uses this handle as first argument. The handle is delete with \fBMqContextDelete\fP. 
.SH "Define Documentation"
.PP 
.SS "#define MQ_MqS_SIGNATURE   0x212CF91"
.PP
signature used in \fBMqS::signature\fP 
.PP
Definition at line 958 of file msgque.h.
.SH "Function Documentation"
.PP 
.SS "enum \fBMqErrorE\fP MqCheckForLeftOverArguments (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP ** argvP)"
.PP
check for left over arguments from parameter \fIargv\fP of \fBMqLinkCreate\fP 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIargvP\fP a pointer to the argv, the memory will be freed and the value will be set to \fCNULL\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP
.RE
.PP
This code is not part of \fBMqLinkCreate\fP because sometimes it is necessary to check for left over arguments \fBafter\fP \fBMqLinkCreate\fP was called and after the calling function was able to process function specific arguments. By Default \fBMqLinkCreate\fP will delete \fBall\fP arguments belonging to \fBlibmsgque\fP from the \fIargv\fP object. If the calling function does \fBnot\fP expect additional arguments or arguments were added with spelling errors, a call to \fBMqCheckForLeftOverArguments\fP will detect this. 
.SS "\fBMQ_BOL\fP MqCurrentTokenIs (struct \fBMqS\fP const *const  context, char const *const  token)"
.PP
check the current token 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the current context 
.br
\fItoken\fP the token to compare with 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqDefaultLinkCreate (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP ** argsP)"
.PP
wrapper for \fBMqLinkCreate\fP with \fIargv\fP error check 
.PP
create a parent \fBlibmsgque\fP object link 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIargsP\fP command-line arguments will be freed and set to \fCNULL\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP
 
.SS "void MqExit (struct \fBMqS\fP * context)"
.PP
exit the current process or thread 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBAttention:\fP
.RS 4
this function will never return
.RE
.PP
.IP "1." 4
Delete the context object using: \fBMqLinkDelete\fP
.IP "2." 4
If available call the context specific exit handler \fC--fParentExit\fP 
.IP "3." 4
final call \fCSysExit\fP to exit the process
.IP "4." 4
It is an Panic error if \fBMqExit\fP is called twice for the same object
.PP

.SS "\fBMQ_STR\fP MqHelp (\fBMQ_CST\fP tool)"
.PP
write \fBlibmsgque\fP specific user-help to stderr 
.PP
\fBParameters:\fP
.RS 4
\fItool\fP the name of the tool (e.g. argv[0]) or NULL. 
.RE
.PP
\fBReturns:\fP
.RS 4
the help messages as string
.RE
.PP
If \fItool\fP != NULL, the function will display a header like: 
.PP
.nf
  tool [ARGUMENT]... syntax:
    aclient [OPTION]... @ tool [OPTION]... @...

.fi
.PP
 on the help page. 
.SS "struct \fBMqBufferLS\fP* MqInitCreate (void)\fC [read]\fP"
.PP
setup and return the \fIinit\fP object 
.PP
\fBReturns:\fP
.RS 4
a pointer to the initialization buffer 
.RE
.PP
\fBAttention:\fP
.RS 4
.IP "\(bu" 2
every usage of this function will free the data of the previous \fIinit\fP object
.IP "\(bu" 2
the data have to fit to the underlying programming language
.PP
The data is used as prefix to setup the argument vector for \fIspawn\fP. The following example demonstrate the usage of \fBMqInitCreate\fP: 
.PP
.nf
struct MqBufferLS * initB = MqInitCreate();
MqBufferLAppendC(initB, 'myExec');
MqBufferLAppendC(initB, 'myExecArgument_1');
...

.fi
.PP
 
.RE
.PP

.SS "void MqInitSysAPI (\fBMqForkF\fP forkF, \fBMqVForkF\fP vforkF)"
.PP
helper to set the application specific \fCfork\fP functions 
.PP
\fBAttention:\fP
.RS 4
by default the OS specific functions are used 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqLinkCreate (struct \fBMqS\fP *const  context, struct \fBMqBufferLS\fP ** argsP)"
.PP
create a parent \fBlibmsgque\fP object link 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIargsP\fP command-line arguments will be freed and set to \fCNULL\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqLinkCreateChild (struct \fBMqS\fP *const  context, struct \fBMqS\fP *const  parent, struct \fBMqBufferLS\fP ** argsP)"
.PP
create a child \fBlibmsgque\fP object link 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIparent\fP the parent object link 
.br
\fIargsP\fP command-line arguments will be freed and set to \fCNULL\fP on error 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP

.SS "void MqLinkDelete (struct \fBMqS\fP *const  context)"
.PP
delete a \fBlibmsgque\fP object 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqProcessEvent (struct \fBMqS\fP *const  context, \fBMQ_TIME_T\fP timeout, enum \fBMqWaitOnEventE\fP const  wait)"
.PP
Waiting for an incoming packet on all open msgque object links. 
.PP
This function is used to wait for (e.g. \fBMQ_WAIT_ONCE\fP) or check (e.g. \fBMQ_WAIT_NO\fP) for an incoming event. If an event occurs the header of the Msgque packet is parsed and the according service-handle is called. if \fBMQ_WAIT_FOREVER\fP is set the function will never return, accept for an error or on exit. This function is usually used on a server to enter the event-loop and wait for incoming service requests.
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItimeout\fP \fBtime_t\fP type value for timeout in seconds. A value of \fC-1\fP is used as \fIdefault\fP using \fBMQ_TIMEOUT\fP seconds. 
.br
\fIwait\fP should the code wait forever (e.g. \fBMQ_WAIT_FOREVER\fP), just wait for the next event (e.g. \fBMQ_WAIT_ONCE\fP) or just return after one single test (\fBMQ_WAIT_NO\fP)' 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP
.RE
.PP
\fBAttention:\fP
.RS 4
The \fItimeout\fP argument is only used if \fBMQ_WAIT_ONCE\fP is set.
.RE
.PP
A typical server looks like: 
.PP
.nf
...
MqErrorCheck(MqLinkCreate(ctx,argv,alfa);
...
MqErrorCheck(MqProcessEvent(ctx, MQ_TIMEOUT, MQ_WAIT_FOREVER);
...
MqLinkDelete(ctx);
...

.fi
.PP
 
.SS "enum \fBMqErrorE\fP MqServiceCreate (struct \fBMqS\fP *const  context, \fBMQ_CST\fP const  token, \fBMqTokenF\fP const  proc, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP datafreeF)"
.PP
create a service handle 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItoken\fP a 4 byte string used to identify the remote service 
.br
\fIproc\fP an external (non libmsgque) function to provide the service 
.br
\fIdata\fP an external (non libmsgque) pointer to a data structure linked to the \fBMqTokenF\fP function 
.br
\fIdatafreeF\fP function to free \fIdata\fP pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceDelete (struct \fBMqS\fP const *const  context, \fBMQ_CST\fP const  token)"
.PP
delete service handle 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItoken\fP a 4 byte string used to identify the remote service 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqServiceProxy (struct \fBMqS\fP *const  context, \fBMQ_CST\fP const  token, \fBMQ_SIZE\fP const  id)"
.PP
use a proxy to proxy the incomming trafic to the outgoing trafic 
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItoken\fP a 4 byte string used to identify the remote service 
.br
\fIid\fP the slave identifer, only used if \fIcontext\fP is a \fImaster\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_ERROR\fP or \fBMQ_CONTINUE\fP
.RE
.PP
If \fIcontext\fP is a \fImaster\fP context than the data is send to \fIslave\fP with \fIid\fP. If \fIcontext\fP is a \fIslave\fP context than the data is send to the \fImaster\fP of the \fIslave\fP. 
.SH "Variable Documentation"
.PP 
.SS "\fBMqFactorySelectorF\fP \fBMqFactorySelector\fP"
.PP
name of a procedure to return \fImain\fP like entry-points 
.PP
Definition at line 992 of file msgque.h.
.SS "struct \fBMqBufferLS\fP* \fBMqInitBuf\fP"
.PP
the prefix arguments of the starting application 
.PP
Definition at line 988 of file msgque.h.
.SH "Author"
.PP 
Generated automatically by Doxygen for tclmsgque from the source code.
