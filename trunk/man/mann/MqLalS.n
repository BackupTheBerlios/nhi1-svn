.TH "MqLalS" n "11 Oct 2010" "Version 4.5" "libmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MqLalS \- Interface between \fBMqS\fP and the Operating-System.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <msgque.h>\fP
.PP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "\fBMQ_PTR\fP(* \fBSysCalloc\fP )(struct \fBMqS\fP *const context, \fBMQ_SIZE\fP nmemb, \fBMQ_SIZE\fP size)"
.br
.R "\fBcalloc\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "\fBMQ_PTR\fP(* \fBSysMalloc\fP )(struct \fBMqS\fP *const context, \fBMQ_SIZE\fP size)"
.br
.R "\fBmalloc\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "\fBMQ_PTR\fP(* \fBSysRealloc\fP )(struct \fBMqS\fP *const context, \fBMQ_PTR\fP buf, \fBMQ_SIZE\fP size)"
.br
.R "\fBrealloc\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "void(* \fBSysFreeP\fP )(\fBMQ_PTR\fP tgt)"
.br
.R "\fBfree\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysServerSpawn\fP )(struct \fBMqS\fP *const context, char **argv, \fBMQ_CST\fP name, struct \fBMqIdS\fP *idP)"
.br
.R "\fBspawn server create\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysServerThread\fP )(struct \fBMqS\fP *const context, struct \fBMqFactoryS\fP factory, struct \fBMqBufferLS\fP **argvP, struct \fBMqBufferLS\fP **alfaP, \fBMQ_CST\fP name, int state, struct \fBMqIdS\fP *idP)"
.br
.R "\fBthread server create\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysServerFork\fP )(struct \fBMqS\fP *const context, struct \fBMqFactoryS\fP factory, struct \fBMqBufferLS\fP **argvP, struct \fBMqBufferLS\fP **alfaP, \fBMQ_CST\fP name, struct \fBMqIdS\fP *idP)"
.br
.R "\fBfork server create\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysFork\fP )(struct \fBMqS\fP *const context, struct \fBMqIdS\fP *idP)"
.br
.R "\fBfork\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysGetTimeOfDay\fP )(struct \fBMqS\fP *const context, struct mq_timeval *tv, struct mq_timezone *tz)"
.br
.R "\fBgettimeofday\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysWait\fP )(struct \fBMqS\fP *const context, const struct \fBMqIdS\fP *idP)"
.br
.R "\fBwait for process or thread\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysUSleep\fP )(struct \fBMqS\fP *const context, unsigned int const usec)"
.br
.R "\fBusleep\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysSleep\fP )(struct \fBMqS\fP *const context, unsigned int const sec)"
.br
.R "\fBsleep\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "\fBMQ_STR\fP(* \fBSysBasename\fP )(\fBMQ_CST\fP const in, \fBMQ_BOL\fP includeExtension)"
.br
.R "\fBbasename\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysIgnorSIGCHLD\fP )(struct \fBMqS\fP *const context)"
.br
.R "\fBignor SIGCHLD\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysAllowSIGCHLD\fP )(struct \fBMqS\fP *const context)"
.br
.R "\fBallow SIGCHLD\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysDaemonize\fP )(struct \fBMqS\fP *const context, \fBMQ_CST\fP pidfile)"
.br
.R "\fBdaemonize\fP the current process and save the resulting pid into the \fIpidfile\fP  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysUnlink\fP )(struct \fBMqS\fP *const context, const \fBMQ_STR\fP fileName)"
.br
.R "\fBunlink\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "void(* \fBSysExit\fP )(int isThread, int num)"
.br
.R "\fBexit\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "void(* \fBSysAbort\fP )(void)"
.br
.R "\fBabort\fP syscall with \fBMqS\fP error plugin  "
.ti -1c
.RI "enum \fBMqErrorE\fP(* \fBSysGetEnv\fP )(struct \fBMqS\fP *const context, \fBMQ_CST\fP name, \fBMQ_STR\fP *ret)"
.br
.R "\fBgetenv\fP syscall with \fBMqS\fP error plugin  "
.in -1c
.SH "Detailed Description"
.PP 
Interface between \fBMqS\fP and the Operating-System. 
.PP
Definition at line 4031 of file msgque.h.
.SH "Field Documentation"
.PP 
.SS "void(* \fBMqLalS::SysAbort\fP)(void)"
.PP
\fBabort\fP syscall with \fBMqS\fP error plugin  
.PP
\fBExample:\fP  
.PP
.nf
static void SysAbort (void) {
  abort();
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysAllowSIGCHLD\fP)(struct \fBMqS\fP *const context)"
.PP
\fBallow SIGCHLD\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysAllowSIGCHLD (
  struct MqS * const context
)
{
#ifdef MQ_IS_POSIX
  if (unlikely ((signal(SIGCHLD, SIG_DFL)) == SIG_ERR)) {
    return MqErrorSys (signal);
  }
#endif
  return MQ_OK;
}

.fi
.PP
  
.SS "\fBMQ_STR\fP(* \fBMqLalS::SysBasename\fP)(\fBMQ_CST\fP const in, \fBMQ_BOL\fP includeExtension)"
.PP
\fBbasename\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIin\fP name of the string to extract the basename from (value of \fIin\fP will not be changed) 
.br
\fIincludeExtension\fP add extension like '.exe' to the filename (\fBMQ_YES\fP or \fBMQ_NO\fP) 
.RE
.PP
\fBReturns:\fP
.RS 4
the basename of \fIin\fP (it is save to modify the basename for additional needs) 
.RE
.PP
\fBAttention:\fP
.RS 4
the memory of the basename string returned is owned by the caller and have to be freed
.RE
.PP
\fBExample:\fP  
.PP
.nf
static MQ_STR SysBasename (
  MQ_CST const in,
  MQ_BOL includeExtension
)
{
#if defined(_MSC_VER)
  char drive[10];
  char dir[512];
  char * fname = (char *) MqSysMalloc(MQ_ERROR_PANIC, 138);
  char ext[10];
  if (_splitpath_s(in, drive, 10, dir, 512, fname, 128, ext, 10) != 0)
    MqPanicV(MQ_ERROR_PANIC, __func__, 1, 'unable to extract basename from '%s'', in);
  if (includeExtension)
    return strcat(fname,ext);
  else
    return fname;
#else
  if (in == NULL) return mq_strdup('');
  // double mq_strdup is necessary because LINUX may modify the input string
  // and FREEBSD modify the output string in future call's to 'basename'
  // ... Is This POSIX ?
  MQ_STR t1 = mq_strdup((MQ_STR) in);
  const MQ_STR orig = mq_strdup(basename(t1));
  free (t1);
  if (includeExtension == MQ_NO) {
    // delete the extension like '.EXE'
    MQ_STR end;
    for (end = orig + strlen(orig); end > orig; end--) {
      if (*end != '.') continue;
      *end = '\0';
      break;
    }
  }
  return orig;
#endif
}

.fi
.PP
  
.SS "\fBMQ_PTR\fP(* \fBMqLalS::SysCalloc\fP)(struct \fBMqS\fP *const context, \fBMQ_SIZE\fP nmemb, \fBMQ_SIZE\fP size)"
.PP
\fBcalloc\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fInmemb\fP the number of members in the memory block 
.br
\fIsize\fP the size of the new memory block 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the new memory block initialized with '0'
.RE
.PP
\fBExample:\fP  
.PP
.nf
static MQ_PTR SysCalloc (
  struct MqS * const context,
  MQ_SIZE nmemb,
  MQ_SIZE size
)
{
  MQ_PTR ptr = calloc (nmemb, size);
  if (unlikely (ptr == NULL))
    MqErrorC (context, __func__, errno, strerror (errno));
  return ptr;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysDaemonize\fP)(struct \fBMqS\fP *const context, \fBMQ_CST\fP pidfile)"
.PP
\fBdaemonize\fP the current process and save the resulting pid into the \fIpidfile\fP  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIpidfile\fP file to save the process identifer, can be used to kill the process later 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysDaemonize (
  struct MqS * const context,
  MQ_CST pidfile
) 
{
#if defined(MQ_IS_POSIX)
  int fd, fpid;
  struct MqIdS id;

  // step 0 -> open the pidfile
  if ((fpid = open(pidfile, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1) 
    return MqErrorSys (open);

  // step 1 -> delete initial process
  MqErrorCheck(MqSysFork(context, &id));
  if (id.val != 0UL)
    _exit(0);

  // step 2 -> create a new session
  if (setsid() == -1)
    return MqErrorSys (setsid);

  // step 3 -> fork the new process, parent write the pid
  MqErrorCheck(MqSysFork(context, &id));
  if (id.val != 0UL) {
    MQ_BUF buf = context->temp;
    MqBufferSetV(buf,'%lu',id.val);
    write(fpid,buf->cur.C,buf->cursize);
    _exit(0);
  }

  // step 4 -> close the fpid after writing
  if (close(fpid) == -1)
    return MqErrorSys (close);

  // step 5 -> close default io
  fd = open('/dev/null', O_RDONLY);
  if (fd != 0) {
    dup2(fd, 0);
    close(fd);
  }
  fd = open('/dev/null', O_WRONLY);
  if (fd != 1) {
    dup2(fd, 1);
    close(fd);
  }
  fd = open('/dev/null', O_WRONLY);
  if (fd != 2) {
    dup2(fd, 2);
    close(fd);
  }

error:
  return MqErrorStack(context);
#else
  return MqErrorDb(MQ_ERROR_NOT_SUPPORTED);
#endif
}

.fi
.PP
  
.SS "void(* \fBMqLalS::SysExit\fP)(int isThread, int num)"
.PP
\fBexit\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIisThread\fP exit a thread? 
.br
\fInum\fP exit code 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static void SysExit (
  int isThread,                     
  int num                           
) {
  if (isThread) {
#if defined(MQ_HAS_THREAD)
# if defined(HAVE_PTHREAD)
    pthread_detach(pthread_self());
    pthread_exit(NULL);
# elif defined(MQ_IS_WIN32)
   _endthreadex(num);
# endif
#endif   /* MQ_HAS_THREAD */
  }
  exit(num);
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysFork\fP)(struct \fBMqS\fP *const context, struct \fBMqIdS\fP *idP)"
.PP
\fBfork\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIidP\fP process handle 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysFork (
  struct MqS * const context,
  struct MqIdS * idP
)
{
#ifdef HAVE_FORK
  if (unlikely (((*idP).val = (mqpid_t) mq_fork()) == -1)) {
    return MqErrorSys (fork);
  }
  (*idP).type = MQ_ID_PROCESS;
  return MQ_OK;
#else
  return MqErrorDb(MQ_ERROR_NOT_SUPPORTED);
#endif
}

.fi
.PP
  
.SS "void(* \fBMqLalS::SysFreeP\fP)(\fBMQ_PTR\fP tgt)"
.PP
\fBfree\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fItgt\fP the memory block to delete and set to NULL
.RE
.PP
\fBExample:\fP  
.PP
.nf
static void SysFreeP (
  MQ_PTR ptr
)
{
  if ( likely((ptr) != (NULL)) ) free(ptr);
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysGetEnv\fP)(struct \fBMqS\fP *const context, \fBMQ_CST\fP name, \fBMQ_STR\fP *ret)"
.PP
\fBgetenv\fP syscall with \fBMqS\fP error plugin  
.PP
Environment variables are out of control by the programmer and are sources of error. The following code is used to secure read, write and delete environment variables and integrate the error cases into the msgque error-handling.
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIname\fP the name of the environment variable (z.B. \fCHOME\fP) 
.br
\fIret\fP point to the resulting buffer space used to store the data of the environment variable 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysGetEnv (
  struct MqS * const context,
  MQ_CST name,
  MQ_STR *ret
)
{
  if ((*ret = (MQ_STR) getenv (name)) == NULL) {
    return MqErrorV (context, __func__, errno, 'can not read the environment variable \'%s\'', name);
  }
  return MQ_OK;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysGetTimeOfDay\fP)(struct \fBMqS\fP *const context, struct mq_timeval *tv, struct mq_timezone *tz)"
.PP
\fBgettimeofday\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fItv\fP the timeval object 
.br
\fItz\fP the timezone object 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysGetTimeOfDay (
  struct MqS * const context,
  struct mq_timeval * tv,
  struct mq_timezone * tz
)
{
  if (unlikely (gettimeofday (tv, tz) == -1)) {
    return MqErrorSys (gettimeofday);
  }
  return MQ_OK;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysIgnorSIGCHLD\fP)(struct \fBMqS\fP *const context)"
.PP
\fBignor SIGCHLD\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysIgnorSIGCHLD (
  struct MqS * const context
)
{
#ifdef MQ_IS_POSIX
  if (unlikely ((signal(SIGCHLD, SIG_IGN)) == SIG_ERR)) {
    return MqErrorSys (signal);
  }
#endif
  return MQ_OK;
}

.fi
.PP
  
.SS "\fBMQ_PTR\fP(* \fBMqLalS::SysMalloc\fP)(struct \fBMqS\fP *const context, \fBMQ_SIZE\fP size)"
.PP
\fBmalloc\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIsize\fP the size of the new memory block 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the new memory block
.RE
.PP
\fBExample:\fP  
.PP
.nf
static MQ_PTR SysMalloc (
  struct MqS * const context,
  MQ_SIZE size
)
{
  MQ_PTR ptr = malloc (size);
  if (unlikely (ptr == NULL))
    MqErrorC (context, __func__, errno, strerror (errno));
  return ptr;
}

.fi
.PP
  
.SS "\fBMQ_PTR\fP(* \fBMqLalS::SysRealloc\fP)(struct \fBMqS\fP *const context, \fBMQ_PTR\fP buf, \fBMQ_SIZE\fP size)"
.PP
\fBrealloc\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIbuf\fP the \fBold\fP memory block to extend 
.br
\fIsize\fP the size of the new memory block 
.RE
.PP
\fBReturns:\fP
.RS 4
a pointer to the new memory block
.RE
.PP
\fBExample:\fP  
.PP
.nf
static MQ_PTR SysRealloc (
  struct MqS * const context,
  MQ_PTR buf,
  MQ_SIZE size
)
{
  MQ_PTR ptr = realloc (buf, size);
  if (unlikely (ptr == NULL))
    MqErrorC (context, __func__, errno, strerror (errno));
  return ptr;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysServerFork\fP)(struct \fBMqS\fP *const context, struct \fBMqFactoryS\fP factory, struct \fBMqBufferLS\fP **argvP, struct \fBMqBufferLS\fP **alfaP, \fBMQ_CST\fP name, struct \fBMqIdS\fP *idP)"
.PP
\fBfork server create\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIfactory\fP server configuration (memory will be freed) 
.br
\fIargvP\fP command-line arguments befor \fBMQ_ALFA\fP, owned by SysServerThread 
.br
\fIalfaP\fP command-line arguments after \fBMQ_ALFA\fP, owned by SysServerThread 
.br
\fIname\fP the name of the thread 
.br
\fIidP\fP the process identifer 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysServerFork (
  struct MqS * const context,   
  struct MqFactoryS   factory,  
  struct MqBufferLS ** argvP,   
  struct MqBufferLS ** alfaP,   
  MQ_CST  name,                 
  struct MqIdS * idP            
)
{
#if defined(HAVE_FORK)
  
  // fork setup !before! a fork is created
  if (context->setup.fForkInit) (*context->setup.fForkInit)(context);

  // this is used for a filter pipeline like '| atool split .. @ cut ... @ join ...'
  // argv[0] is set by the tool (cut or join) and need !not! be set by name
  MqErrorCheck(MqSysFork(context,idP));
  if ((*idP).val == 0UL) {
    struct MqS * newctx;
    // prevent the 'client-context' from deleting in the new process
    // reason: perl has a garbage collection, after fork this 'context' is in the
    // new process but with an invalid 'event-link' (pIoCreate was done but pIoconnect not)
    // and 'pEventCreate' can not set the 'MqContextDelete_LOCK'
    context->bits.MqContextDelete_LOCK = MQ_YES;
    // create the new context
    MqErrorCheck1(pCallFactory (context, MQ_FACTORY_NEW_FORK, factory, &newctx));
    // add my configuration
    newctx->statusIs = (enum MqStatusIsE) (newctx->statusIs | MQ_STATUS_IS_FORK);
    // the new CONTEXT is always a SERVER
    newctx->setup.isServer = MQ_YES;
    // join argvP alfaP
    if (alfaP != NULL && *alfaP != NULL) {
      MqBufferLAppendC(*argvP, MQ_ALFA_STR);
      MqBufferLMove(*argvP, alfaP);
    }
    // create link
    MqErrorCheck1(MqLinkCreate(newctx,argvP));
    // the MqProcessEvent is necessary because 'ParentCreate' have to come back
    // ifNot: java create object will fail
    if (newctx->setup.isServer == MQ_YES)
      MqProcessEvent(newctx, MQ_TIMEOUT_USER, MQ_WAIT_FOREVER);
error1:
    MqExit(newctx);
  }
  MqBufferLDelete (argvP);
  MqBufferLDelete (alfaP);
  // do not create a 'defunc' process
  MqErrorCheck (MqSysIgnorSIGCHLD(context));
  return MQ_OK;

error:
  return MqErrorDbV (MQ_ERROR_CAN_NOT_START_SERVER, name);
#else
  return MqErrorDb (MQ_ERROR_NOT_SUPPORTED);
#endif   /* HAVE_FORK */
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysServerSpawn\fP)(struct \fBMqS\fP *const context, char **argv, \fBMQ_CST\fP name, struct \fBMqIdS\fP *idP)"
.PP
\fBspawn server create\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIargv\fP command-line arguments 
.br
\fIname\fP the name of the process 
.br
\fIidP\fP the process identifer 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysServerSpawn (
  struct MqS * const context,
  char * * argv,
  MQ_CST  name,
  struct MqIdS * idP
)
{
  pid_t pid;
  
  // spawn setup !before! a spawn is created
  if (context->setup.fSpawnInit) (*context->setup.fSpawnInit)(context);

#if defined(HAVE_POSIX_SPAWN)
  if (unlikely (posix_spawnp(&pid, name, NULL, NULL, (char *const *) argv, __environ) != 0)) {
    goto error;
  }
  goto ok;

#elif (defined(HAVE_FORK) || defined(HAVE_VFORK))  && defined(HAVE_EXECVP)

  // fork to create the child
  if (mq_vfork != NULL) {
    if (unlikely ((pid = mq_vfork()) == -1)) goto error;
  } else if (mq_fork != NULL) {
    if (unlikely ((pid = mq_fork()) == -1)) goto error;
  } else {
    goto error;
  }
      
  if (pid == 0) {
    // this is the child
    if (execvp(name, argv) == -1) {
      _exit (EXIT_FAILURE);
    }
    // the child will never reach this
  }
  goto ok;

#elif defined(MQ_IS_WIN32)
  char buf[2048];
  char *nbuf=buf;

  // build command-line
  for (;*argv != '\0'; argv++) {
    nbuf += sprintf(nbuf, '\'%s\' ', *argv);
  }

  // start process
  if (unlikely ((pid = _spawnlp (_P_NOWAIT, name, buf, NULL)) == -1)) {
    //printC(strerror(errno))
    goto error;
  }
  goto ok;

#else
# error unable to SysServerSpawn
#endif

ok:
  (*idP).val = (mqpid_t)pid;
  (*idP).type = MQ_ID_PROCESS;
  return MQ_OK;

error:
  return MqErrorDbV (MQ_ERROR_CAN_NOT_START_SERVER, name);
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysServerThread\fP)(struct \fBMqS\fP *const context, struct \fBMqFactoryS\fP factory, struct \fBMqBufferLS\fP **argvP, struct \fBMqBufferLS\fP **alfaP, \fBMQ_CST\fP name, int state, struct \fBMqIdS\fP *idP)"
.PP
\fBthread server create\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIfactory\fP server configuration (memory will be freed) 
.br
\fIargvP\fP command-line arguments befor \fBMQ_ALFA\fP, owned by SysServerThread 
.br
\fIalfaP\fP command-line arguments after \fBMQ_ALFA\fP, owned by SysServerThread 
.br
\fIname\fP the name of the thread 
.br
\fIstate\fP detachstate of the thread \fCPTHREAD_CREATE_DETACHED\fP or \fCPTHREAD_CREATE_JOINABLE\fP 
.br
\fIidP\fP the thread identifer 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
struct SysServerThreadCreateS {
  struct MqS * tmpl;
  struct MqFactoryS   factory;
  struct MqBufferLS * argv;
  struct MqBufferLS * alfa;
};

static mqthread_ret_t mqthread_stdcall sSysServerThreadCreate (
  void * data
) 
{
  struct SysServerThreadCreateS * argP = (struct SysServerThreadCreateS *) data;
  // save data local
  struct MqS * tmpl  = argP->tmpl;
  struct MqFactoryS factory = argP->factory;
  struct MqBufferLS * argv  = argP->argv;
  struct MqBufferLS * alfa  = argP->alfa;
  struct MqS * newctx;
  // cleanup
  free(argP);
  // create the new context
  MqErrorCheck(pCallFactory (tmpl, MQ_FACTORY_NEW_THREAD, factory, &newctx));
  // add my configuration
  newctx->statusIs = (enum MqStatusIsE) (newctx->statusIs | MQ_STATUS_IS_THREAD);
  // the new CONTEXT is always a SERVER
  newctx->setup.isServer = MQ_YES;
  // join argvP alfaP
  if (alfa != NULL) {
    MqBufferLAppendC(argv, MQ_ALFA_STR);
    MqBufferLMove(argv, &alfa);
  }
  // create link
  MqErrorCheck(MqLinkCreate(newctx, &argv));
  //MqDLogC(msgque,0,'THREAD exit');
  // the MqProcessEvent is necessary because 'ParentCreate' have to come back
  // ifNot: java create object will fail
  if (newctx->setup.isServer == MQ_YES) {
    MqProcessEvent(newctx, MQ_TIMEOUT_USER, MQ_WAIT_FOREVER);
  }
error:
  MqBufferLDelete (&argv);
  MqExit(newctx);
  return (mqthread_ret_t) NULL;
}
#endif  // MQ_HAS_THREAD

static enum MqErrorE SysServerThread (
  struct MqS * const context,
  struct MqFactoryS factory,
  struct MqBufferLS ** argvP,
  struct MqBufferLS ** alfaP,
  MQ_CST  name,         
  int state,            
  struct MqIdS * idP    
)
{
#if defined(MQ_HAS_THREAD)
  mqthread_t threadId;
#if defined(HAVE_PTHREAD)
  int ret;
#endif

  // fill thread data
  struct SysServerThreadCreateS * argP = (struct SysServerThreadCreateS *) MqSysMalloc(MQ_ERROR_PANIC,sizeof(*argP));
  argP->factory = factory;
  argP->argv = *argvP;
  argP->alfa = *alfaP;
  argP->tmpl = context;

  // pointers are owned by SysServerThread
  *argvP = NULL;
  *alfaP = NULL;

  // after a 'thread' no 'fork' is possible
  MqConfigSetIgnoreFork (context, MQ_YES);

#if defined(HAVE_PTHREAD)

  // thread attributes
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, state);
  
  // thread setup !before! a thread was created
  if (context->setup.fThreadInit) (*context->setup.fThreadInit)(context);

  // start thread
  do {
    ret = pthread_create(&threadId,&attr,sSysServerThreadCreate,argP);
  } while (ret == EAGAIN);

  // cleanup attribute
  pthread_attr_destroy(&attr);

  if (unlikely(ret != 0)) {
    MqErrorDbV (MQ_ERROR_CAN_NOT_START_SERVER, name);
    goto error;
  }

#elif defined(MQ_IS_WIN32)

  if (unlikely ( (threadId = _beginthreadex(NULL, 0, sSysServerThreadCreate, argP, 0, NULL)) == 0)) {
    MqErrorDbV (MQ_ERROR_CAN_NOT_START_SERVER, name);
    MqErrorSysAppend (_beginthreadex);
    goto error;
  }

#endif

  // save tid
  (*idP).val = (mqthread_t)threadId;
  (*idP).type = MQ_ID_THREAD;

  return MQ_OK;

error:
  MqBufferLDelete (&argP->argv);
  MqBufferLDelete (&argP->alfa);
  MqSysFree (argP);
  return MQ_ERROR;
#else
  return MqErrorDb(MQ_ERROR_NOT_SUPPORTED);
#endif   /* MQ_HAS_THREAD */
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysSleep\fP)(struct \fBMqS\fP *const context, unsigned int const sec)"
.PP
\fBsleep\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIsec\fP the seconds to sleep 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysSleep (
  struct MqS * const context,
  unsigned int const sec
)
{
#if defined(MQ_IS_POSIX)
  if (unlikely (sleep (sec))) {
    return MqErrorSys (sleep);
  }
#elif defined (MQ_IS_WIN32)
  Sleep (sec * 1000);
#else
#   error not supported
#endif
  return MQ_OK;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysUnlink\fP)(struct \fBMqS\fP *const context, const \fBMQ_STR\fP fileName)"
.PP
\fBunlink\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIfileName\fP name of the file to \fIunlink\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysUnlink (
  struct MqS * const context,
  const MQ_STR fileName
)
{
#if defined(MQ_IS_POSIX)
  struct stat buf;
  if (unlikely (stat (fileName, &buf) == -1)) {
    switch (errno) {
      case ENOENT:
        return MQ_OK;
      default:
        return MqErrorV (context, __func__, errno,
          'can not access file <%s> ERR<%s>', fileName, strerror (errno));
    }
  }
  if (unlikely (unlink (fileName) == -1 && errno != ENOENT)) {
    return MqErrorV (context, __func__, errno,
                     'can not delete file <%s> ERR<%s>', fileName, strerror (errno));
  }
  return MQ_OK;
#else
  return MqErrorDb(MQ_ERROR_NOT_SUPPORTED);
#endif
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysUSleep\fP)(struct \fBMqS\fP *const context, unsigned int const usec)"
.PP
\fBusleep\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIusec\fP the micro (10^-6) seconds to sleep 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysUSleep (
  struct MqS * const context,
  unsigned int const usec
)
{
#if defined(MQ_IS_POSIX)
  if (unlikely (usleep (usec))) {
    return MqErrorSys (usleep);
  }
#elif defined (MQ_IS_WIN32)
  Sleep ((usec + 500) / 1000);
#else
#   error not supported
#endif
  return MQ_OK;
}

.fi
.PP
  
.SS "enum \fBMqErrorE\fP(* \fBMqLalS::SysWait\fP)(struct \fBMqS\fP *const context, const struct \fBMqIdS\fP *idP)"
.PP
\fBwait for process or thread\fP syscall with \fBMqS\fP error plugin  
.PP
\fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIidP\fP process or thread handle 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBMqErrorObject\fP
.RE
.PP
\fBExample:\fP  
.PP
.nf
static enum MqErrorE SysWait (
  struct MqS * const context,
  const struct MqIdS *idP
)
{
  errno = 0;
  switch (idP->type) {
    case MQ_ID_PROCESS: {
/*
  we don't wait for a process because this is buggy (for example BSD wait forever)
#if defined(MQ_IS_POSIX)
      if ( waitpid (idP->val.process, NULL, 0) == -1) {
        return MqErrorSys (waitpid);
      }
#elif defined(MQ_IS_WIN32)
      if ( _cwait (NULL, idP->val.process, _WAIT_CHILD) == -1) {
        return MqErrorSys (waitpid);
      }
#endif
*/
      break;
    }
#if defined(MQ_HAS_THREAD)
    case MQ_ID_THREAD: {
# if defined(HAVE_PTHREAD)
      if ( pthread_join ((mqthread_t)idP->val, NULL)) {
        return MqErrorSys (pthread_join);
      }
# elif defined(MQ_IS_WIN32)
      if ( WaitForSingleObject((HANDLE)idP->val, INFINITE ) == WAIT_FAILED) {
        return MqErrorSys(WaitForSingleObject);
      }
# endif
      break;
    }
#endif   /* MQ_HAS_THREAD */
    case MQ_ID_UNUSED: {
      break;
    }
  }
  return MQ_OK;
}

.fi
.PP
  

.SH "Author"
.PP 
Generated automatically by Doxygen for libmsgque from the source code.
