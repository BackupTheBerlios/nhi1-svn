.TH "Mq_Config_C_API" n "Mon Jan 10 2011" "Version 4.8" "csmsgque" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Mq_Config_C_API \- 
.PP
configuration of a context  

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBMqCallbackS\fP"
.br
.RI "\fIused for callback function pointer management \fP"
.ti -1c
.RI "struct \fBMqLinkSetupS\fP"
.br
.RI "\fIused to Create/Delete of object \fP"
.ti -1c
.RI "struct \fBMqIoUdsConfigS\fP"
.br
.RI "\fIconfigure a context to use a \fIuds-client-server-link\fP \fP"
.ti -1c
.RI "struct \fBMqIoTcpConfigS\fP"
.br
.RI "\fIconfigure a context to use a \fItcp-client-server-link\fP \fP"
.ti -1c
.RI "struct \fBMqIoPipeConfigS\fP"
.br
.RI "\fIconfigure a context to use a \fIpipe-client-server-link\fP \fP"
.ti -1c
.RI "struct \fBMqIoConfigS\fP"
.br
.RI "\fIconfiguration data which belong to \fIMqIoS\fP \fP"
.ti -1c
.RI "struct \fBMqConfigS\fP"
.br
.RI "\fIend-user configuration data, also available as command-line options \fP"
.ti -1c
.RI "struct \fBMqSetupS\fP"
.br
.RI "\fIapplication-programmer configuration data \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBMqErrorE\fP(* \fBMqCreateF\fP )(struct \fBMqS\fP *, struct \fBMqBufferLS\fP **)"
.br
.RI "\fIthe prototype for a ContextCreate function \fP"
.ti -1c
.RI "typedef void(* \fBMqDeleteF\fP )(struct \fBMqS\fP *const context)"
.br
.RI "\fIthe prototype for a ContextDelete function \fP"
.ti -1c
.RI "typedef enum \fBMqErrorE\fP(* \fBMqTokenF\fP )(struct \fBMqS\fP *const context, \fBMQ_PTR\fP const data)"
.br
.RI "\fIprototype for an object method function \fP"
.ti -1c
.RI "typedef void(* \fBMqTokenDataFreeF\fP )(struct \fBMqS\fP const *const context, \fBMQ_PTR\fP *dataP)"
.br
.RI "\fIprototype for a free additional token data function \fP"
.ti -1c
.RI "typedef void(* \fBMqTokenDataCopyF\fP )(struct \fBMqS\fP *const context, \fBMQ_PTR\fP *dataP)"
.br
.RI "\fIprototype for a copy additional token data function \fP"
.ti -1c
.RI "typedef void(* \fBMqHelpF\fP )(\fBMQ_CST\fP)"
.br
.RI "\fIapplication specific help function type \fP"
.ti -1c
.RI "typedef void(* \fBMqMarkF\fP )(\fBMQ_PTR\fP data)"
.br
.RI "\fIprototype for a Garbage-Collection mark function \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBMqStartE\fP { \fBMQ_START_DEFAULT\fP =  0, \fBMQ_START_FORK\fP =  1, \fBMQ_START_THREAD\fP =  2, \fBMQ_START_SPAWN\fP =  3 }"
.br
.RI "\fIUser preferences on HOWTO start a new entity. \fP"
.ti -1c
.RI "enum \fBMqStatusIsE\fP { \fBMQ_STATUS_IS_INITIAL\fP =  0, \fBMQ_STATUS_IS_DUP\fP =  1<<0, \fBMQ_STATUS_IS_THREAD\fP =  1<<1, \fBMQ_STATUS_IS_FORK\fP =  1<<2, \fBMQ_STATUS_IS_SPAWN\fP =  1<<3 }"
.br
.RI "\fIInformation about how the \fIcontext\fP was created. \fP"
.ti -1c
.RI "enum \fBMqIoComE\fP { \fBMQ_IO_PIPE\fP =  0, \fBMQ_IO_UDS\fP =  1, \fBMQ_IO_TCP\fP =  2 }"
.br
.RI "\fIwhat kind of socket interface to use? \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBMqSetup\fP (void)"
.br
.ti -1c
.RI "void \fBMqCleanup\fP (void)"
.br
.ti -1c
.RI "void \fBMqConfigReset\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIclean the \fBMqS.config\fP data \fP"
.ti -1c
.RI "void \fBMqConfigDup\fP (struct \fBMqS\fP *const to, struct \fBMqS\fP const *const from)"
.br
.RI "\fIcopy the \fBMqS.config\fP data \fP"
.ti -1c
.RI "void \fBMqSetupDup\fP (struct \fBMqS\fP *const to, struct \fBMqS\fP const *const from)"
.br
.RI "\fIcopy the \fBMqS.setup\fP data \fP"
.ti -1c
.RI "void \fBMqConfigSetName\fP (struct \fBMqS\fP *const context, \fBMQ_CST\fP data)"
.br
.RI "\fIset the \fBMqConfigS.name\fP value and cleanup old value \fP"
.ti -1c
.RI "void \fBMqConfigUpdateName\fP (struct \fBMqS\fP *const context, \fBMQ_CST\fP data)"
.br
.ti -1c
.RI "void \fBMqConfigSetSrvName\fP (struct \fBMqS\fP *const context, \fBMQ_CST\fP data)"
.br
.RI "\fIset the \fBMqConfigS.srvname\fP value and cleanup old value \fP"
.ti -1c
.RI "void \fBMqConfigSetBuffersize\fP (struct \fBMqS\fP *const context, \fBMQ_INT\fP data)"
.br
.RI "\fIset the \fBMqIoConfigS.buffersize\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetDebug\fP (struct \fBMqS\fP *const context, \fBMQ_INT\fP data)"
.br
.RI "\fIset the \fBMqConfigS.debug\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetTimeout\fP (struct \fBMqS\fP *const context, \fBMQ_TIME_T\fP data)"
.br
.RI "\fIset the \fBMqIoConfigS.timeout\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIsSilent\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqConfigS.isSilent\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIsServer\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqSetupS.isServer\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIsString\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqConfigS.isString\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIgnoreExit\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqSetupS.ignoreExit\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIgnoreFork\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqConfigS.ignoreFork\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetIgnoreThread\fP (struct \fBMqS\fP *const context, \fBMQ_BOL\fP data)"
.br
.RI "\fIset the \fBMqConfigS.ignoreThread\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetStartAs\fP (struct \fBMqS\fP *const context, enum \fBMqStartE\fP data)"
.br
.RI "\fIset the \fBMqConfigS.startAs\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetSetup\fP (struct \fBMqS\fP *const context, \fBMqCreateF\fP fChildCreate, \fBMqDeleteF\fP fChildDelete, \fBMqCreateF\fP fParentCreate, \fBMqDeleteF\fP fParentDelete, \fBMqExitF\fP fProcessExit, \fBMqExitF\fP fThreadExit)"
.br
.RI "\fIset various attributes from \fBMqConfigS\fP struct \fP"
.ti -1c
.RI "void \fBMqConfigSetEvent\fP (struct \fBMqS\fP *const context, \fBMqTokenF\fP fCall, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP fFree, \fBMqTokenDataCopyF\fP fCopy)"
.br
.RI "\fIset the \fBMqSetupS.Event\fP \fP"
.ti -1c
.RI "void \fBMqConfigSetServerSetup\fP (struct \fBMqS\fP *const context, \fBMqTokenF\fP fCall, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP fFree, \fBMqTokenDataCopyF\fP fCopy)"
.br
.RI "\fIset the \fBMqSetupS.ServerSetup\fP \fP"
.ti -1c
.RI "void \fBMqConfigSetServerCleanup\fP (struct \fBMqS\fP *const context, \fBMqTokenF\fP fTok, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP fFree, \fBMqTokenDataCopyF\fP fCopy)"
.br
.RI "\fIset the \fBMqSetupS.ServerCleanup\fP \fP"
.ti -1c
.RI "void \fBMqConfigSetBgError\fP (struct \fBMqS\fP *const context, \fBMqTokenF\fP fTok, \fBMQ_PTR\fP data, \fBMqTokenDataFreeF\fP fFree, \fBMqTokenDataCopyF\fP fCopy)"
.br
.RI "\fIset the \fBMqSetupS.BgError\fP \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqConfigSetIoUdsFile\fP (struct \fBMqS\fP *const ctx, \fBMQ_CST\fP file)"
.br
.RI "\fIconfigure a context to use a \fIuds-client-server-link\fP  \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqConfigSetIoTcp\fP (struct \fBMqS\fP *const ctx, \fBMQ_CST\fP host, \fBMQ_CST\fP port, \fBMQ_CST\fP myhost, \fBMQ_CST\fP myport)"
.br
.RI "\fIconfigure a context to use a \fItcp-client-server-link\fP  \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqConfigSetIoPipeSocket\fP (struct \fBMqS\fP *const context, \fBMQ_SOCK\fP socket)"
.br
.RI "\fIset the \fIpipe\fP configuration data \fP"
.ti -1c
.RI "enum \fBMqErrorE\fP \fBMqConfigSetDaemon\fP (struct \fBMqS\fP *const ctx, \fBMQ_CST\fP pidfile)"
.br
.RI "\fIstart the \fIserver-context\fP as daemon \fP"
.ti -1c
.RI "int \fBMqConfigGetIsServer\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIdoes the \fIcontext\fP object is a \fIserver\fP ? \fP"
.ti -1c
.RI "int \fBMqConfigGetIsString\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIdoes the \fIcontext\fP object is a \fIstring\fP ? \fP"
.ti -1c
.RI "int \fBMqConfigGetIsSilent\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIdoes the \fIcontext\fP object is \fIsilent\fP ? \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetName\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the \fIname\fP of the \fIcontext\fP object \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetSrvName\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the \fIsrvname\fP of the \fIcontext\fP object \fP"
.ti -1c
.RI "\fBMQ_INT\fP \fBMqConfigGetBuffersize\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the minimum of the \fIread/send\fP \fIbuffersize\fP value of the \fIcontext\fP object \fP"
.ti -1c
.RI "\fBMQ_INT\fP \fBMqConfigGetDebug\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the \fIdebug\fP value of the \fIcontext\fP object \fP"
.ti -1c
.RI "\fBMQ_TIME_T\fP \fBMqConfigGetTimeout\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the \fItimeout\fP value of the \fIcontext\fP object \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetIoUdsFile\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIreturn the \fBMqIoUdsConfigS.file\fP value \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetIoTcpHost\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIget the \fBMqIoTcpConfigS.host\fP configuration data \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetIoTcpPort\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIget the \fBMqIoTcpConfigS.port\fP configuration data \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetIoTcpMyHost\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIget the \fBMqIoTcpConfigS.myhost\fP configuration data \fP"
.ti -1c
.RI "\fBMQ_CST\fP \fBMqConfigGetIoTcpMyPort\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIget the \fBMqIoTcpConfigS.myport\fP configuration data \fP"
.ti -1c
.RI "\fBMQ_SOCK\fP \fBMqConfigGetIoPipeSocket\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIget the \fIpipe\fP configuration data \fP"
.ti -1c
.RI "enum \fBMqStartE\fP \fBMqConfigGetStartAs\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIreturn the \fBMqConfigS.startAs\fP value \fP"
.ti -1c
.RI "enum \fBMqStatusIsE\fP \fBMqConfigGetStatusIs\fP (struct \fBMqS\fP *const context)"
.br
.RI "\fIreturn the \fBMqS.statusIs\fP value \fP"
.ti -1c
.RI "void \fBMqConfigSetSelf\fP (struct \fBMqS\fP *const context, void *self)"
.br
.RI "\fIset the \fBMqS.self\fP value \fP"
.ti -1c
.RI "void * \fBMqConfigGetSelf\fP (struct \fBMqS\fP const *const context)"
.br
.RI "\fIget the \fBMqS.self\fP value \fP"
.ti -1c
.RI "struct \fBMqBufferLS\fP * \fBMqInitCreate\fP (void)"
.br
.RI "\fIInitialize the process \fIstartup-prefix\fP argument. \fP"
.ti -1c
.RI "struct \fBMqBufferLS\fP * \fBMqInitGet\fP (void)"
.br
.RI "\fIget the process \fIstartup-prefix\fP argument \fP"
.in -1c
.SH "Detailed Description"
.PP 
configuration of a context 

The configuration is done persistent using \fIconfig-api\fP functions or on link-setup using \fIcommand-line-arguments\fP. 
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBMqErrorE\fP( * \fBMqCreateF\fP)(struct \fBMqS\fP *,struct \fBMqBufferLS\fP **)"
.PP
the prototype for a ContextCreate function This function is the MqS.fCreate and MqS.fThreadCreate parameter and is used to :
.IP "1." 4
create a \fIchild\fP context
.IP "2." 4
create a \fIparent\fP context as the thread entry point
.PP

.PP
Definition at line 420 of file msgque.h.
.SS "typedef void( * \fBMqDeleteF\fP)(struct \fBMqS\fP *const context)"
.PP
the prototype for a ContextDelete function This function is the MqS.fDelete and MqS.fThreadDelete parameter and is used to:
.IP "1." 4
delete a \fIchild\fP context
.IP "2." 4
delete a \fIparent\fP context as the thread exit point
.PP

.PP
Definition at line 433 of file msgque.h.
.SS "typedef void( * \fBMqHelpF\fP)(\fBMQ_CST\fP)"
.PP
application specific help function type 
.PP
Definition at line 464 of file msgque.h.
.SS "typedef void( * \fBMqMarkF\fP)(\fBMQ_PTR\fP data)"
.PP
prototype for a Garbage-Collection mark function 
.PP
Definition at line 471 of file msgque.h.
.SS "typedef void( * \fBMqTokenDataCopyF\fP)(struct \fBMqS\fP *const context, \fBMQ_PTR\fP *dataP)"
.PP
prototype for a copy additional token data function 
.PP
Definition at line 456 of file msgque.h.
.SS "typedef void( * \fBMqTokenDataFreeF\fP)(struct \fBMqS\fP const *const context, \fBMQ_PTR\fP *dataP)"
.PP
prototype for a free additional token data function 
.PP
Definition at line 448 of file msgque.h.
.SS "typedef enum \fBMqErrorE\fP( * \fBMqTokenF\fP)(struct \fBMqS\fP *const context, \fBMQ_PTR\fP const data)"
.PP
prototype for an object method function 
.PP
Definition at line 440 of file msgque.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBMqIoComE\fP"
.PP
what kind of socket interface to use? 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMQ_IO_PIPE \fP\fP
.TP
\fB\fIMQ_IO_UDS \fP\fP
.TP
\fB\fIMQ_IO_TCP \fP\fP

.PP
Definition at line 520 of file msgque.h.
.SS "enum \fBMqStartE\fP"
.PP
User preferences on HOWTO start a new entity. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMQ_START_DEFAULT \fP\fP
use application-context default entity creation 
.TP
\fB\fIMQ_START_FORK \fP\fP
create entity as \fIfork\fP 
.TP
\fB\fIMQ_START_THREAD \fP\fP
create entity as \fIthread\fP 
.TP
\fB\fIMQ_START_SPAWN \fP\fP
create entity as \fIspawn\fP process 
.PP
Definition at line 489 of file msgque.h.
.SS "enum \fBMqStatusIsE\fP"
.PP
Information about how the \fIcontext\fP was created. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIMQ_STATUS_IS_INITIAL \fP\fP
context is the \fIfirst\fP context 
.TP
\fB\fIMQ_STATUS_IS_DUP \fP\fP
context is created as a duplicate of an other context 
.TP
\fB\fIMQ_STATUS_IS_THREAD \fP\fP
context is created as a thread 
.TP
\fB\fIMQ_STATUS_IS_FORK \fP\fP
context is created as a fork 
.TP
\fB\fIMQ_STATUS_IS_SPAWN \fP\fP
context is created as a spawn 
.PP
Definition at line 497 of file msgque.h.
.SH "Function Documentation"
.PP 
.SS "void MqCleanup (void)"
.SS "void MqConfigDup (struct \fBMqS\fP *constto, struct \fBMqS\fP const *constfrom)"
.PP
copy the \fBMqS.config\fP data 
.SS "\fBMQ_INT\fP MqConfigGetBuffersize (struct \fBMqS\fP const *constcontext)"
.PP
get the minimum of the \fIread/send\fP \fIbuffersize\fP value of the \fIcontext\fP object \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.config.buffersize\fP(R/S) value 
.RE
.PP

.SS "\fBMQ_INT\fP MqConfigGetDebug (struct \fBMqS\fP const *constcontext)"
.PP
get the \fIdebug\fP value of the \fIcontext\fP object \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.config.debug\fP value 
.RE
.PP

.SS "\fBMQ_SOCK\fP MqConfigGetIoPipeSocket (struct \fBMqS\fP *constcontext)"
.PP
get the \fIpipe\fP configuration data \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the pipe socket 
.RE
.PP

.SS "\fBMQ_CST\fP MqConfigGetIoTcpHost (struct \fBMqS\fP *constcontext)"
.PP
get the \fBMqIoTcpConfigS.host\fP configuration data 
.SS "\fBMQ_CST\fP MqConfigGetIoTcpMyHost (struct \fBMqS\fP *constcontext)"
.PP
get the \fBMqIoTcpConfigS.myhost\fP configuration data 
.SS "\fBMQ_CST\fP MqConfigGetIoTcpMyPort (struct \fBMqS\fP *constcontext)"
.PP
get the \fBMqIoTcpConfigS.myport\fP configuration data 
.SS "\fBMQ_CST\fP MqConfigGetIoTcpPort (struct \fBMqS\fP *constcontext)"
.PP
get the \fBMqIoTcpConfigS.port\fP configuration data 
.SS "\fBMQ_CST\fP MqConfigGetIoUdsFile (struct \fBMqS\fP *constcontext)"
.PP
return the \fBMqIoUdsConfigS.file\fP value 
.SS "int MqConfigGetIsServer (struct \fBMqS\fP const *constcontext)"
.PP
does the \fIcontext\fP object is a \fIserver\fP ? \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fC(context->setup.isServer == MQ_YES)\fP value 
.RE
.PP

.SS "int MqConfigGetIsSilent (struct \fBMqS\fP const *constcontext)"
.PP
does the \fIcontext\fP object is \fIsilent\fP ? \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fC(context->config.isSilent == MQ_YES)\fP value 
.RE
.PP

.SS "int MqConfigGetIsString (struct \fBMqS\fP const *constcontext)"
.PP
does the \fIcontext\fP object is a \fIstring\fP ? \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fC(context->config.isString == MQ_YES)\fP value 
.RE
.PP

.SS "\fBMQ_CST\fP MqConfigGetName (struct \fBMqS\fP const *constcontext)"
.PP
get the \fIname\fP of the \fIcontext\fP object \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.config.name\fP value 
.RE
.PP
\fBAttention:\fP
.RS 4
the \fIstring\fP is owned by \fBlibmsgque\fP -> do not free !! 
.RE
.PP

.SS "void* MqConfigGetSelf (struct \fBMqS\fP const *constcontext)"
.PP
get the \fBMqS.self\fP value \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP

.SS "\fBMQ_CST\fP MqConfigGetSrvName (struct \fBMqS\fP const *constcontext)"
.PP
get the \fIsrvname\fP of the \fIcontext\fP object \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.config.srvname\fP value 
.RE
.PP
\fBAttention:\fP
.RS 4
the \fIstring\fP is owned by \fBlibmsgque\fP -> do not free !! 
.RE
.PP

.SS "enum \fBMqStartE\fP MqConfigGetStartAs (struct \fBMqS\fP *constcontext)"
.PP
return the \fBMqConfigS.startAs\fP value 
.SS "enum \fBMqStatusIsE\fP MqConfigGetStatusIs (struct \fBMqS\fP *constcontext)"
.PP
return the \fBMqS.statusIs\fP value 
.SS "\fBMQ_TIME_T\fP MqConfigGetTimeout (struct \fBMqS\fP const *constcontext)"
.PP
get the \fItimeout\fP value of the \fIcontext\fP object \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fCcontext.config.timeout\fP value 
.RE
.PP

.SS "void MqConfigReset (struct \fBMqS\fP *constcontext)"
.PP
clean the \fBMqS.config\fP data 
.SS "void MqConfigSetBgError (struct \fBMqS\fP *constcontext, \fBMqTokenF\fPfTok, \fBMQ_PTR\fPdata, \fBMqTokenDataFreeF\fPfFree, \fBMqTokenDataCopyF\fPfCopy)"
.PP
set the \fBMqSetupS.BgError\fP 
.SS "void MqConfigSetBuffersize (struct \fBMqS\fP *constcontext, \fBMQ_INT\fPdata)"
.PP
set the \fBMqIoConfigS.buffersize\fP value 
.SS "enum \fBMqErrorE\fP MqConfigSetDaemon (struct \fBMqS\fP *constctx, \fBMQ_CST\fPpidfile)"
.PP
start the \fIserver-context\fP as daemon A \fIdaemon\fP is a \fIserver-process\fP without any link to the \fIparent-process\fP. A \fIdaemon-process\fP has closed all default IO (e.g stdout, stdin, stderr) and forked into the background. (default: no daemon) 
.PP
\fBAttention:\fP
.RS 4
this option require the \fBfork\fP system-call and is \fBnot\fP compatible with threads. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.br
\fIpidfile\fP write the PID of the daemon into this file (default: NULL, do not start as daemon) 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "void MqConfigSetDebug (struct \fBMqS\fP *constcontext, \fBMQ_INT\fPdata)"
.PP
set the \fBMqConfigS.debug\fP value 
.SS "void MqConfigSetEvent (struct \fBMqS\fP *constcontext, \fBMqTokenF\fPfCall, \fBMQ_PTR\fPdata, \fBMqTokenDataFreeF\fPfFree, \fBMqTokenDataCopyF\fPfCopy)"
.PP
set the \fBMqSetupS.Event\fP 
.SS "void MqConfigSetIgnoreExit (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqSetupS.ignoreExit\fP value 
.SS "void MqConfigSetIgnoreFork (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqConfigS.ignoreFork\fP value 
.SS "void MqConfigSetIgnoreThread (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqConfigS.ignoreThread\fP value 
.SS "enum \fBMqErrorE\fP MqConfigSetIoPipeSocket (struct \fBMqS\fP *constcontext, \fBMQ_SOCK\fPsocket)"
.PP
set the \fIpipe\fP configuration data \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIsocket\fP the name of the known socket 
.RE
.PP
\fBReturns:\fP
.RS 4
the \fBMqErrorE\fP return status \fBMQ_OK\fP, \fBMQ_CONTINUE\fP or \fBMQ_ERROR\fP and an \fBErrorObject\fP
.RE
.PP
This is configuration option is only useful for a \fI\fP(x)inetd setup to use the stdin (socket=0) as send/recv communication socket 
.SS "enum \fBMqErrorE\fP MqConfigSetIoTcp (struct \fBMqS\fP *constctx, \fBMQ_CST\fPhost, \fBMQ_CST\fPport, \fBMQ_CST\fPmyhost, \fBMQ_CST\fPmyport)"
.PP
configure a context to use a \fItcp-client-server-link\fP  \fBParameters:\fP
.RS 4
\fIhost\fP client: name of the remote interface (default: localhost)
.br
 server: name of the local interface (default: listen on \fIall\fP interfaces) 
.br
\fIport\fP client: name of the remote port
.br
 server: name of the local port 
.br
\fImyhost\fP client: name of the local interface 
.br
\fImyport\fP client: name of the local port 
.RE
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "enum \fBMqErrorE\fP MqConfigSetIoUdsFile (struct \fBMqS\fP *constctx, \fBMQ_CST\fPfile)"
.PP
configure a context to use a \fIuds-client-server-link\fP  The \fIuds-socket\fP (http://en.wikipedia.org/wiki/Unix_domain_socket) is usually 50% faster than a local tcp communication but only available on UNIX. 
.PP
\fBParameters:\fP
.RS 4
\fIfile\fP name of a \fIuds-socket-file\fP (default: \fInull\fP) 
.RE
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIctx\fP the context returned by \fBContextCreate\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
an \fBERROR OBJECT\fP on error 
.RE
.PP

.SS "void MqConfigSetIsServer (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqSetupS.isServer\fP value 
.SS "void MqConfigSetIsSilent (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqConfigS.isSilent\fP value 
.SS "void MqConfigSetIsString (struct \fBMqS\fP *constcontext, \fBMQ_BOL\fPdata)"
.PP
set the \fBMqConfigS.isString\fP value 
.SS "void MqConfigSetName (struct \fBMqS\fP *constcontext, \fBMQ_CST\fPdata)"
.PP
set the \fBMqConfigS.name\fP value and cleanup old value 
.SS "void MqConfigSetSelf (struct \fBMqS\fP *constcontext, void *self)"
.PP
set the \fBMqS.self\fP value \fBParameters:\fP
.RS 4
\fIcontext\fP the initial \fBMqS\fP object created by \fBMqContextCreate\fP 
.br
\fIself\fP a pointer to the managed context usually \fIself\fP or \fIthis\fP 
.RE
.PP

.SS "void MqConfigSetServerCleanup (struct \fBMqS\fP *constcontext, \fBMqTokenF\fPfTok, \fBMQ_PTR\fPdata, \fBMqTokenDataFreeF\fPfFree, \fBMqTokenDataCopyF\fPfCopy)"
.PP
set the \fBMqSetupS.ServerCleanup\fP 
.SS "void MqConfigSetServerSetup (struct \fBMqS\fP *constcontext, \fBMqTokenF\fPfCall, \fBMQ_PTR\fPdata, \fBMqTokenDataFreeF\fPfFree, \fBMqTokenDataCopyF\fPfCopy)"
.PP
set the \fBMqSetupS.ServerSetup\fP 
.SS "void MqConfigSetSetup (struct \fBMqS\fP *constcontext, \fBMqCreateF\fPfChildCreate, \fBMqDeleteF\fPfChildDelete, \fBMqCreateF\fPfParentCreate, \fBMqDeleteF\fPfParentDelete, \fBMqExitF\fPfProcessExit, \fBMqExitF\fPfThreadExit)"
.PP
set various attributes from \fBMqConfigS\fP struct 
.SS "void MqConfigSetSrvName (struct \fBMqS\fP *constcontext, \fBMQ_CST\fPdata)"
.PP
set the \fBMqConfigS.srvname\fP value and cleanup old value 
.SS "void MqConfigSetStartAs (struct \fBMqS\fP *constcontext, enum \fBMqStartE\fPdata)"
.PP
set the \fBMqConfigS.startAs\fP value 
.SS "void MqConfigSetTimeout (struct \fBMqS\fP *constcontext, \fBMQ_TIME_T\fPdata)"
.PP
set the \fBMqIoConfigS.timeout\fP value 
.SS "void MqConfigUpdateName (struct \fBMqS\fP *constcontext, \fBMQ_CST\fPdata)"
.SS "struct \fBMqBufferLS\fP* MqInitCreate (void)\fC [read]\fP"
.PP
Initialize the process \fIstartup-prefix\fP argument. The \fIstartup-prefix\fP have to be the name of the executable, found in the \fCPATH\fP environment variable, and additional arguments like the script name or the required startup options. The \fIstartup-prefix\fP is used for two different purpose:
.IP "\(bu" 2
To start a new entity using the \fBstartAs\fP '--spawn' command-line option.
.IP "\(bu" 2
To replace the \fIcommand-line-argument\fP \fC'... @ SELF ...'\fP with \fC'... @ startup-prefix ...'\fP at \fBLinkCreate\fP.
.PP
Every use of this function will free the data of the previous \fIstartup-prefix\fP. By default the \fIstartup-prefix\fP is set during package loading or during \fBLinkCreate\fP and have \fBnot\fP to be initialized again. 
.SS "struct \fBMqBufferLS\fP* MqInitGet (void)\fC [read]\fP"
.PP
get the process \fIstartup-prefix\fP argument \fBReturns:\fP
.RS 4
a pointer to the initialization buffer (Only C-API) 
.RE
.PP

.SS "void MqSetup (void)"
.SS "void MqSetupDup (struct \fBMqS\fP *constto, struct \fBMqS\fP const *constfrom)"
.PP
copy the \fBMqS.setup\fP data \fIMqSetupDup\fP is an important function, because every new created object need to fill the \fBMqSetupS\fP data. The typical software flow is:
.br
.IP "\(bu" 2
\fICall-Factory\fP -> \fBMqContextCreate\fP (default setup) -> \fIObject-Specific-Setup\fP -> \fBMqSetupDup\fP
.PP
\fBMqSetupDup\fP has code to protect setup data filled in \fIObject-Specific-Setup\fP 
.SH "Author"
.PP 
Generated automatically by Doxygen for csmsgque from the source code.
