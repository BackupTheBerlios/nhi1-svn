#!/usr/bin/env bash
set -u
#set -uxv

#%# ----------------------------------------------------------------------
declare -x  G_FileName="${1##*/}"
declare -x  G_Dirname="${1%/*}"; shift
declare -xa G_Args=("${@:-}")
declare -x  G_Shell=${G_Shell:-}
#%%# ---------------------------------------------------------------------
declare -x  G_Date=${G_Date:-'$Date: 2007-01-24 12:14:05 +0100 (Wed, 24 Jan 2007) $'}
declare -x  G_Revision=${G_Revision:-'$Revision: 11578 $'}
declare -x  G_Author=${G_Author:-'$Author: mqm $'}
declare -x  G_Source=${G_Source:-'$URL: svn://mpsun07/home/otto/SetupEnv/SetupEnv.bash $'}
#%%%# --------------------------------------------------------------------
declare -x  G_Description=${G_Description:-"environment retrieval and setup tool"}

function get_setup_usage() {
  cat<<"EOF" 1>&2
setup-usage: SetupEnv <<"EOF" ... EOF

Scan and process environment variables provided as commandline arguments:
  > SetupEnv "$0" "${@:-}"
The configuration of the tool is read from stdin and the parsed commandline
optionx is written to stdout.
The configuration is parsed by bash and recignize the following token:

Variables:
  G_Shell......... the type of the calling shell (bash,csh,tcl,...)
  G_Date.......... the date of the revision ($Date: ... $
  G_Revision...... the revision number ($Revision: ... $)
  G_Author........ the author ($Author: ... $)
  G_Source........ the file source ($URL: ... $)
  G_Description... the long description of the usage
  G_HelpProc...... an external function to be called for additional help

Functions:
  G_Option
    lookup <environment-variable-name>
      > used to look a single environment data-item from the file:
      > global-data-file and/or local-data-file
    global-data-file <filename>
      > global environment-database used by all SetupEnv tools
    local-data-file <filename>
      > local environment-database used by this specific SetupEnv tool
      > use argument 'default' to generate an default-local-database
      > name
    local-setup-file <filename>
      > file used to source additional configuration data
    print-config
      > print configuration after setup
    call-in-loop
      > loop over the SetupEnv to run external tests
  G_Argument <string>
    The String has the form :
      > Option:Variable:InitValue:Description?:Type?:ListEntry1?:ListEntry2?:...
    with

      Option ........ Command-Line option in short '-' or long '--' format
      Variable ...... Environment variable
      InitValue ..... Initial value for Env-Variable
      Description ... Description of Env-Variable
      Type .......... Flag which descripts the variable
	B) Boolean    -> A boolean variable, default '0' or '1'
	E) Extern     -> Should the Variable be exported
	L) List       -> This is a 'List' with values following after
      List .......... List entries, only use with Type (B)oolean or (L)ist.
                      As Type (B)oolean only 2 List-Arguments are supported

EOF
  exit 0
}

#

declare -i Debug=0
Debug()		{ 
  (( ! $Debug )) && return
  printf "Debug: %30s => $(date)\n" "$1" 1>&2
}

##
Debug "Define Procedures" ################################################################
##

## Procedures
Echo() 		{ 
  case $G_ShellType in
    1|2)  echo "echo -e \"${1}\";"  ;;
    3)	  echo "puts \"$1\";"	;;
  esac
}

Eval() 		{ 
  case $G_ShellType in
    1|2)  echo "eval \"$1\"\;"	;;
    3)	  echo "eval \"$1\"\;"	;;
  esac
}
Error() 	{ Print "$G_FileName ERROR: $1\n" 	; echo "exit ${2:-1};" ; exit ${2:-1} ; }
Error2() 	{ Print "$G_FileName ERROR: $1\n" 	; echo "ERROR $1" ; exit ${2:-1} ; }
Error3() 	{ Print "$G_FileName ERROR: $1\n" 	; exit ${2:-1} ; }
Warning() 	{ Print "$G_FileName WARNING: $1\n" 	; export SE_SUCCESS ; SE_SUCCESS=1 ; }
Exit() 		{ Print "$1\n" 				; echo "exit 0;" ; exit 0 ; }
Weiter()	{ declare Tmp="";Print  "\n\n   continue with keypress   "; read Tmp 1>&2 ;}
Print()		{ printf "$@" 1>&2; }

#XPrint()	{ for __I; do eval echo -en "\"$__I<\$$__I>\", " 1>&2; done; Print "" ; }

##
Debug "print functions" ##########################################################
##
function Shift {
  (( $# < 1 )) && return
  declare -i num=$1
  case $G_ShellType in
    1)	declare -i i=0
	while (( i < num )) ; do
	  echo "shift;"
	done
    ;;
    2)	echo "shift $num;";;
    3)	let num-=1; echo "set \$argv [lreplace \$argv 0 $num];";;
  esac
}
##
function print_variable {
  (( $# < 2 )) && return
  declare a=$1;shift
  case $G_ShellType in
    1)	echo "set $a = $*;" 	;;
    2)	echo "$a='$*';"		;;
    3)	echo "set $a {$*}:" 	;;
  esac
}
##
function print_extern {
  (( $# < 1 )) && return
  case $G_ShellType in
    1)	echo "setenv $1;" 	;;
    2)	echo "export $1;"	;;
    3)	echo "global $1;" 	;;
  esac
}
function print_all_variables {
  declare -i i=0
  while (( i < SE_NOptions ))
  do
    [[ -z ${SE_Defaults[$i]} ]] && { let i+=1; continue; }
    print_variable "${SE_Variables[$i]}" "${SE_Defaults[$i]}"
    let i+=1
  done
  (( SE_LOOP == 1 )) && {
    print_extern "G_LOOP"
    print_variable "G_LOOP" "$((G_LOOP+1))"
  }
}
function print_array {
  eval declare -i len=\${#$1[*]}
  declare val
  declare -i i=0
  echo "S: print array -$1- <$len>" 1>&2
  while (( i < len )) ; do
    eval val=\${$1[$i]}
    printf "%2i) <$val>\n" $i 1>&2
    let i+=1
  done
  echo "E: print array -$1-" 1>&2
}
function print_a_array {
  eval declare -a keys=\${!$1[@]}
  declare val
  echo "S: print array -$1- <hash>" 1>&2
  for k in ${keys[@]}; do
    eval val=\${$1[$k]}
    printf "%10s) <$val>\n" $k 1>&2
  done
  echo "E: print array -$1-" 1>&2
}

##
Debug "set functions" ##########################################################
##

function set_option {
  declare -i I="$1"
  declare    V="$2"
  declare    E="${SE_Options[$I]:-%no%}"
  if (( ${#V} == 0 )) ; then
    SE_Options[$I]="${SE_Variables[$I]}"
    [[ $E == "%no%" ]] && let SE_NLOptions+=1
  elif (( ${#V} > 1 )) ; then
    SE_Options[$I]="$V"
    [[ $E == "%no%" ]] && let SE_NLOptions+=1
  else
    SE_Options[$I]="$V"
  fi
}

function set_defaults {
  declare I=$1
  declare D=$2
  ## special bei tables, _*_ wird expandiert
  [[ "$D" == _*_ ]] && {
    D="$(eval_command $D)"
    [[ $? != 0 ]] && Error "[FKT] set_defaults"
  }
  ## check the value
  if [[ $D != "?" && -n ${SE_List[$I]} ]] ; then
    declare -i idx=0
    declare -a tmpl
    IFS="|"
    tmpl=(${SE_List[$I]})
    unset IFS
    if [[ $D == "%#:"* ]] ; then
      idx=${D##%#:}
      D=${tmpl[$idx]}
    else
      declare -i idx=0
      declare -i max=${#tmpl[*]}
      while ((idx < max)) ; do
	[[ "$D" == "${tmpl[$idx]}" ]] && break
	let idx+=1
      done
      (( idx >= max )) && {
	Error "[FKT] set_defaults: '-${SE_Options[$I]} $D' is not part of index '${SE_List[$I]}'"
      }
    fi
  fi
  ## save values
  SE_Defaults[$I]="$D"
}

function set_description {
  declare	I=$1
  declare	V=$2
  declare -i	len=${#V}

  if ((${#SE_List[SE_NOptions]} > 0)) ; then
    let len=len+${#SE_List[$SE_NOptions]}+4
  fi
  (( len > SE_NDescriptions )) && SE_NDescriptions=len
  SE_Descriptions[$I]=$V
}

##
Debug "scan functions" ##########################################################
##
function GetValue {
  ## are needed?
  declare V=$1;shift
  declare I=${SE_IDX[$V]:--1}
  (( I == -1 )) && { Warning "[CONFIG] - unknown variable \"$V\"" ; return ; }
  echo "${SE_Defaults[$I]}"
}
function system {
  declare V=$1;shift
  declare T=$1;shift
  [[ $T != "=" ]] && Warning "[SYNTAX] - '=' was expected and not found in .ENV file."
  eval $V=\"$@\"
  SE_System=($V)
  print_variable $V $@
}
function value { 
  ## are needed?
  declare V=$1;shift
  declare I=${SE_IDX[$V]:--1}
  (( I == -1 )) && return
  ## make processing
  declare T=$1;shift
  [[ $T != "=" ]] && Warning "[SYNTAX] - '=' was expected and not found in .ENV file."
  (( $# >= 1 )) && set_defaults $I "$*"
}
function config { 
  ## are needed?
  declare V=$1;shift
  declare -i I=${SE_IDX[$V]:--1}
  (( I == -1 )) && return
  ## make processing
  declare T=$1;shift
  [[ $T != "=" ]] && Warning "[SYNTAX] - '=' was expected and not found in .ENV file."
  declare O=$1;shift
  declare T=$1;shift
  [[ $T != "-" ]] && Warning "[SYNTAX] - '-' was expected and not found in .ENV file."
  set_option $I "$O"
  set_description $I "$*"
}
function cmd { 
  ## are needed?
  declare V=$1;shift
  ## make processing
  declare T=$1;shift
  [[ $T != "=" ]] && Warning "[SYNTAX] - '=' was expected and not found in .ENV file."
  SE_Cmd_Tokens[$SE_IDX_MAX_COMMANDS]="$V"
  SE_Cmd_Values[$SE_IDX_MAX_COMMANDS]="$@"
  export SE_IDX[$V]=$SE_IDX_MAX_COMMANDS
  let SE_IDX_MAX_COMMANDS+=1
}
function cmdtxt { 
  ## are needed?
  declare V=$1;shift
  declare -i I=${SE_IDX[$V]:--1}
  (( I == -1 )) && return
  ## make processing
  declare T=$1;shift
  [[ $T != "=" ]] && Warning "[SYNTAX] - '=' was expected and not found in .ENV file."
  SE_Cmd_Text[$I]="$@"
}

##
Debug "misc functions" #################################################################
##

function query_make {
  ## Test on BUILDPATH
  [[ ${BUILDPATH:-""} == "" ]] && Error2 "No BUILDPATH environment variable"
  ## Test on BUILDPATH
  [[ -d $BUILDPATH ]] || Error2 "BUILDPATH is not a directory"
  ## Check for existence of Makefile if it is needed.
  [[ -r $BUILDPATH/Makefile ]] || Error2 "[ENVIRONMENT] - Makefile not found. Please run imake."
  ## execute command
  echo "$(cd $BUILDPATH;make -r $1 2>/dev/null)"
}
function eval_command {
  ## create index
  declare -i I=${SE_IDX[$1]:--1}
  ## check if command is available
  (( I == -1 )) && { echo "$1"; return; }
  ## make eval
  R="$(${SE_Cmd_Values[$I]})"
  ## test on error
  [[ $? != 0 ]] && Error2 "[EXEC] - Error during proccess of Target <$1>"
  ## test on output
  case $R in
    Nothing)	echo	"$1"	;;
    *)		echo	"$R"	;;
  esac
}
function check_on_command {
  declare -i i=0
  declare D=""
  while (( i < SE_NOptions ))
  do
    [[ ${SE_Defaults[$i]} == "ERROR" ]] &&
      Error "[CHECK ON COMMAND] occurs during process of a command"
    [[ ${SE_Defaults[$i]} == _*_ ]] && {
      D="$(eval_command ${SE_Defaults[$i]})"
      [[ $? != 0 ]] && Error "[FKT] check_on_command"
      set_defaults $i "$D"
    }
    let i+=1
  done
}

function setup_ENV_file {
  declare SE_Value=""
  function cmd 	{ :;}
  function system { :;}
  function config { :;}
  function value { SE_Value="$SE_Value${SE_Value:+,}:$1::" ; }
  [[ -f $1 ]] && . $1
  echo "$SE_Value"
}

function G_Argument {
  declare option="$1"
## be sure to get the right 'format'
  [[ "$option" != *$NIFS* ]] && continue
## declare
  declare option
  declare opt
  declare var
  declare def
  declare dfi
## delete all spaces at the begin and end
  option=${option%%+([[:space:]])}
  option=${option##+([[:space:]])}
  IFS=$NIFS
  set -- $option
  opt=$1
  var=$2
  def=$3
  dfi=${4:-"No text for <$var>"}
  typ=${5:-}
  #Print "opt<$opt>, var<$var>, def<$def>, dfi<$dfi>, typ<$typ>"
## 1. name of the option
  # POST
## 2. name of the variable
  SE_Variables[$SE_NOptions]="$var"
  SE_IDX[$var]=$SE_NOptions
  SE_INV[$opt]=$SE_NOptions
## 3. the default
  [[ $SE_LOOP == 1 && $G_LOOP != 0 ]] && {
    def=${!var:-$def}
  }
  if [[ -z "$def" ]] ; then
    if (( $# > 5 )) ; then
      def=$6
    elif [[ $typ == *B* ]] ; then
      def=1 
    fi
  fi
## 4. the description
  # POST
## 5. the type
  SE_Type[$SE_NOptions]=$typ
  [[ $typ == *E* || $SE_LOOP == 1 ]] && print_extern $var
## 6. set the List values
  IFS="|"
  if (($# > 5)) ; then
    shift 5
    SE_List[$SE_NOptions]="$*"
  elif [[ $typ == *B* ]] ; then
    SE_List[$SE_NOptions]="1${IFS}0"
  else
    SE_List[$SE_NOptions]=""
  fi
## POST operation
  set_option	  $SE_NOptions "$opt"
  set_defaults    $SE_NOptions "$def"
  set_description $SE_NOptions "$dfi"
## finish
  SE_NOptions+=1
}

function source { 
## Soll verhindern das eine Datei 2x eingelesen wird
  [[ -f $1 ]] && {
  ## ermittelt den absoluten pfad einer datei
    declare Tmp=$(cd ${1%/*};pwd)/${1##*/}
    [[ ":$SE_Lock:" == *:$Tmp:* ]] && return
    . $1 ${1%/*} 
    SE_Lock="$Tmp:$SE_Lock"
  }
}

function command_usage {
  (( SE_IDX_MAX_COMMANDS == 0 )) && return
  declare -i	 i=0
  Print "\n  list of available commands:\n"
  while (( i < SE_IDX_MAX_COMMANDS ))
  do
    if [[ ${SE_Cmd_Text[$i]:-} != "" ]] ; then
      printf "    %10s : ${SE_Cmd_Text[$i]}\n" "${SE_Cmd_Tokens[$i]}" 1>&2
    else
      printf "    %10s : no decription available\n" "${SE_Cmd_Tokens[$i]}" 1>&2
    fi
    let i+=1
  done
}

function variable_usage {
  (( SE_NOptions == 0 )) && return
  Print "\n  environment database parameter:\n"
  declare -i	 i=0
  printf "    %13s : %4s : description\n" "variable" "type" 1>&2
  printf "    %13s : %4s : -----------\n" "--------" "----" 1>&2
  while (( i < SE_NOptions ))
  do
    if [[ -n ${SE_List[$i]} ]] ; then
      printf "    %13s : %4s : ${SE_Descriptions[$i]} (${SE_List[$i]})\n" "${SE_Variables[$i]}" "${SE_Type[$i]}" 1>&2
    else
      printf "    %13s : %4s : ${SE_Descriptions[$i]}\n" "${SE_Variables[$i]}" "${SE_Type[$i]}" 1>&2
    fi
    let i+=1
  done
  Print "\n  type definition:\n\n    <B>  boolean variable\n    <E>  export  variable\n    <L>  list    variable" 
}

function get_environment_usage {
  ## work
  Print "\nvariable-usage: $G_FileName"
  command_usage
  variable_usage
  Exit "\n"
}

function get_detail_user_usage {
  if [[ -n "${G_HelpProc:-}" ]] ; then
    Eval "$G_HelpProc 1>&2"
    Exit ""
  else
    Error "the user-detail-usage is not installed, use 'G_HelpProc' to add"
  fi
}

function get_user_usage {
  declare Ret=""
  declare -i i=0
  declare -i max=$SE_NDescriptions+5
  declare -i max2=$SE_NDescriptions+15
  declare -i max3=$SE_NDescriptions

  declare space
  declare space3

  ## work
  Print "\nusage: $G_FileName ?Options? $SE_Args"
  (( SE_NOptions > SE_NLOptions )) && { Print "\n  Custom short options:\n" ; }
  while (( i < SE_NOptions ))
  do
    (( ${#SE_Options[$i]} > 1 )) && { let i+=1 ; continue ; }
    if [[ -n ${SE_List[$i]} ]] ; then
      space="-${SE_Options[$i]}   ${SE_Descriptions[$i]} (${SE_List[$i]})"
    else
      space="-${SE_Options[$i]}   ${SE_Descriptions[$i]}"
    fi
    Print "    %-${max}s =  ${SE_Defaults[$i]:0:30}\n" "$space"
    i+=1
  done
  (( SE_NLOptions > 0 )) && { Print "\n  Custom long options:\n" ; }
  let i=0
  while (( i < SE_NOptions ))
  do
    (( ${#SE_Options[$i]} < 2 )) && { let i+=1 ; continue ; }
    if [[ -n ${SE_List[$i]} ]] ; then
      space3="${SE_Descriptions[$i]} (${SE_List[$i]})"
    else
      space3="${SE_Descriptions[$i]}"
    fi
    Print "    %-${max2}s\n         %-${max3}s =  ${SE_Defaults[$i]:0:30}\n"  "--${SE_Options[$i]}" "$space3"
    i+=1
  done
  Print "\n  Global options:\n"
  for t in  "-c:clean screen" \
	    "-v:get the version information" \
	    "-i(+):use (not) the interactive mode" \
	    "-s(+):save (not) the configuration" \
	    "-p(+):print (not) the configuration" \
	    "--help,-h:get user usage" \
	    "--help-environment:get environment database usage" \
	    "--help-setup:get setup usage"
  do
    IFS=":"; set -- $t; unset IFS
    Print "\n    %-18s : %s" "$1" "$2"
  done
  Exit '\n'
}

function parse_commandline {
## global options
  set -- "${G_Args[@]}"
  (( ! $# )) && return

  declare -i i=0
  declare o=""
  declare SE_HELP=""
  declare -i num=$#
## step through the options
  while (( $# > 0 )) ; do
    ## Setup default options
      case $1 in
	-i) shift; let SE_INTERACTIV=1; continue ;;
	+i) shift; let SE_INTERACTIV=0; continue ;;
	-c) shift; Print "$clear"; continue ;;
	-s) shift; let SE_SAVE=1; continue ;;
	+s) shift; let SE_SAVE=0; continue ;;
	-p) shift; let SE_PrintCfg=1; continue ;;
	+p) shift; let SE_PrintCfg=0; continue ;;
	-v) shift; Exit "$G_Date - $G_Revision"	; continue ;;
	-h|--help) shift; let SE_HELP=1; continue ;;
	--help-environment) shift; let SE_HELP=2; continue ;;
	--help-setup) shift; let SE_HELP=3; continue ;;
	--help-detail) shift; let SE_HELP=4; continue ;;
      esac
    ## Setup OptionString
      o="${1##+([-+])}"
      if [[ "$o" != "$1" ]] ; then
	i=${SE_INV[$o]:--1}
      else
	i=-1
      fi

      if (( i != -1 )) ; then
	if (( ${#o} > 1 )) ; then
	  if [[ ${SE_Type[$i]} == *B* ]] ; then
	    [[ "$1" == "--$o" ]] && {
	      set_defaults $i "%#:0"; shift 1; continue 2
	    }
	    [[ "$1" == "++$o" ]] && {
	      set_defaults $i "%#:1"; shift 1; continue 2
	    }
	  else
	    [[ "$1" == "--$o" ]] && {
	      set_defaults $i "$2"; shift 2; continue 2
	    }
	  fi
	else
	  if [[ ${SE_Type[$i]} == *B* ]] ; then
	    [[ "$1" == "-$o" ]] && {
	      set_defaults $i "%#:0"; shift 1; continue 2
	    }
	    [[ "$1" == "+$o" ]] && {
	      set_defaults $i "%#:1"; shift 1; continue 2
	    }
	  else
	    [[ "$1" == "-$o" ]] && {
	      set_defaults $i "$2"; shift 2; continue 2
	    }
	  fi
	fi
	Error "unknown option '$1'"
      fi

    ## nothing found just break the loop
      break
  done

  ## all remaining positional parameters are put out
  SE_Args="${@:-}"
  Shift $((num - $#))
  ## Help needed
  case $SE_HELP in
    1)	get_user_usage;;
    2)	get_environment_usage;;
    3)	get_setup_usage;;
    4)	get_detail_user_usage;;
  esac
}

function create_mask {
## something to do
  (( SE_NOptions == 0 )) && return
## declare
  declare -i i=0
## make output
  while (( i < SE_NOptions ))
  do
    if [[ -n ${SE_List[$i]} ]] ; then
      just="${SE_Descriptions[$i]} (${SE_List[$i]})"
    else
      just="${SE_Descriptions[$i]}"
    fi
    Print "%-${SE_NDescriptions}s = ${SE_Defaults[$i]:0:30}\n" "$just"
    let i+=1
  done
}

function read_variable {
  (( $1 < 0 || $1 >= SE_NOptions )) && return
  declare tmp=""
  declare -a tmpl
  if [[ ${SE_Type[$1]} == *B* ]] ; then
    IFS="|"; tmpl=(${SE_List[$1]}); unset IFS
    if [[ ${SE_Defaults[$1]} == "${tmpl[0]}" ]] ; then 
      tmp=${tmpl[1]}
    else
      tmp=${tmpl[0]}
    fi
  elif [[ ${SE_Type[$1]} == *L* ]] ; then
    IFS="|"; tmpl=(${SE_List[$1]}); unset IFS
    declare def=${SE_Defaults[$1]}
    if [[ $def == "?" ]] ; then
      tmp=${tmpl[0]}
    else
      declare -i idx=0
      declare -i max=${#tmpl[*]}
      declare -i next
      while ((idx < max)) ; do
	if ((idx == max-1)) ; then
	  let next=0
	else
	  let next=idx+1
	fi
	[[ "$def" == "${tmpl[$idx]}" ]] && {
	  tmp=${tmpl[$next]}
	  break
	}
	let idx=next
      done
    fi
  else
    IFS=$SE_IFS3
    Print "\n<${SE_Defaults[$1]}>\n\nnothing <> for preserving the value\nmarks <\"\"> for clean the value\n"
    read -e -p '==> ' tmp
    IFS=$SE_IFS
    [[ $tmp == "" ]] && return
    [[ $tmp == '""' ]] && tmp=""
  fi
  set_defaults $1 "$tmp"
}

function print_configuration {
## something to do
  (( SE_PrintCfg == 0 || SE_NOptions == 0 )) && return
  Print "\n  $G_FileName - Configuration\n"
  Print "===================================================\n"
  create_mask
  Print "===================================================\n"
}

function print_var {
## something to do
  (( SE_PrintVar == 0 || SE_NOptions == 0 )) && return
## output
  ## declare
  declare -i  i=0
  declare     R=""
  declare     T=""
## work
  while (( i < SE_NOptions ))
  do
    if [[ -z ${SE_Defaults[$i]} ]] ; then
      if [[ " ${SE_System[*]:-} " == *" ${SE_Variables[$i]} "* ]] ; then
	T=${!SE_Variables[$i]}
      else
	T=""
      fi
    else
      T=${SE_Defaults[$i]}
    fi
    R="$R${R:+ }$T"
    let i+=1
  done
  echo "$R"
}

function save_local {
## something to do
  (( SE_NOptions == 0 )) && return
## files exists
  [[ -f $SE_LENV && ! -h $SE_LENV && ! -w $SE_LENV ]] && \
    Error3 "Can't write file <$SE_LENV>"
  [[ -f $SE_LENV ]] && rm $SE_LENV
  echo "# files created at: $(date)" > $SE_LENV
## declare
  declare -i i=0
  while (( i < SE_NOptions ))
  do
    echo "value ${SE_Variables[$i]} = \"${SE_Defaults[$i]}\"" >> $SE_LENV
    let i+=1
  done
}

function interactive {
## something to do
  (( SE_NOptions == 0 )) && return
  declare -i i
## init
  REPLY=1
## make select
  COLUMNS=1
  exec 0</dev/tty
#set -x
  while [[ -n $REPLY ]]
  do
    IFS=$SE_IFS3
    Print "$clear"
    Print "Please check the following items:"
    Print "CTRL-H del char, CTRL-W del word,  CTRL-D for finish\n"
    Print " c) continue\n q) quit\n p) print commands\n"
    while true ; do
      i=0
    ## print screen
      for m in $(create_mask 2>&1); do
	Print "%2i) %s\n" $i "$m"
	let i+=1
      done
    ## read the commands
      Print "\nPlease select a number between [1] and [$SE_NOptions]\n"
      read -e -rp "=> "
    ## check the 'read' value
      case $REPLY in
	[0-9])	    read_variable $REPLY;;
	[1-9][0-9]) read_variable $REPLY;;
	c)	    REPLY="";;
	q)	    Print "$clear" ; Exit "quitting ..." ;;
	p)	    command_usage ; Weiter;;
      esac
      break
    done
    IFS=${SE_IFS}
  done
## make output
  Print "$clear"
}


## 
## Main #####################################################################
##

## Init
SE_NL="
"
SE_TAB="	"
SE_WS=" "
SE_IFS=$IFS
SE_IFS2="$SE_TAB$SE_NL"
SE_IFS3="$SE_NL"
NIFS=":"

## kein glob
set -f
shopt -s extglob

## 
Debug "declare" #####################################################################
##

declare	    SE_Args
declare	-a  SE_CmdLine

declare -i  i=0
declare -i  SE_INTERACTIV=0
declare -i  SE_SAVE=0
declare -i  SE_LOOP=0
declare -i  G_LOOP=${G_LOOP:-0}
declare	    SE_Setup='.ENV.local'
declare	    SE_LENV=''
declare -i  SE_SUCCESS=0
declare -i  SE_PrintCfg=0
declare -i  SE_PrintVar=0
declare -i  SE_IDX_MAX_COMMANDS=0

declare -i  SE_NOptions=0
declare -i  SE_NLOptions=0
declare -i  SE_NDescriptions=0
declare -a  SE_Options[30]
declare -a  SE_Variables[30]
declare -a  SE_Defaults[30]			## Hält die Ergebnisse der Variablen
declare -a  SE_Descriptions[30]
declare -a  SE_System[30]			## System Variable
declare -a  SE_Type[30]
declare -a  SE_List[30]				## argument's for SE_Type=L
declare	    SE_Lock=''				## Fkt <source>

declare -Ax SE_IDX
declare -Ax SE_INV

declare clear="$(tput clear)"
(( $Debug == 1 )) && clear=""

##
Debug "Reading Commandline" ################################################################
##

function G_Option {
  case "$1" in
    lookup)
      G_Argument "$NIFS$2$NIFS$NIFS"
      SE_PrintVar=1
    ;;
    global-data-file)
      G_ENV="$2"
    ;;
    local-setup-file)
      SE_Setup="$2"
    ;;
    local-data-file)
      if [[ "$2" == "default" ]] ; then
	SE_LENV="./.${G_FileName//./}.ENV"
      else
	SE_LENV="$2"
      fi
      SE_SAVE=1
    ;;
    print-config)
      SE_PrintCfg=1
    ;;
    call-in-loop)
      SE_LOOP=1
    ;;
    *)
      get_setup_usage
    ;;
  esac
}

. /dev/stdin

## get the shell-type
case $G_Shell in
  csh|tcsh)	G_ShellType=1	;;
  ksh|bash|sh)	G_ShellType=2   ;;
  tclsh|wish)	G_ShellType=3   ;;
  *)		Error "unknown shell '$G_Shell' only 'csh,tcsh,ksh,bash,sh,tclsh,wish' is supported"
esac

##
Debug "Setup local .ENV file" ###########################################################
##

## Absoluter Pfad für SE_Setup
## Mit dem Inhalt der Datei SE_Setup wird
## KonfigZeile <-C> aufgebaut
#[[ -n "$SE_Setup" ]] && {
#  [[ "$SE_Setup" != /* ]] && SE_Setup=$PWD/$SE_Setup
#  IFS=","
#  [[ ! -f $SE_Setup ]] && Error "File <$SE_Setup> not found"
#  SE_CmdLine=($(setup_ENV_file "$SE_Setup"))
#  IFS=$SE_IFS
#  G_Args+=(-i -s)
#  SE_LENV="$SE_Setup"
#}

##
Debug "Environment Variables" ####################################################################
##

source "${G_ENV:-}"
source "${SE_LENV:-}"

##
Debug "Parse Command Line" ##############################################################
##

#print_array SE_Options
#print_array SE_Variables
#print_array SE_Defaults
#print_array SE_Descriptions

parse_commandline

##
Debug "ErrorCheck" ###############################################################################
##
## check on error
[[ $SE_SUCCESS != 0 ]] && {
Error "\
[STATUS] - retrieving environmental data failed.
Please correct above WARNINGs
Exiting ..."
}

##
Debug "process" ################################################################################
##

## check if a command was not substitute
check_on_command

## what status ?
(( SE_INTERACTIV == 1 )) && interactive

## save .LOCAL
if (( SE_SAVE == 1 )) ; then
  save_local
else
  [[ $SE_PrintVar == 0 && -f "$SE_LENV" ]] && rm "$SE_LENV"
fi

## message
print_configuration

## message
print_var

## print the environment
print_all_variables
	
exit 0
# ----------------------------------------------------------------------
# vim: shiftwidth=4 tabstop=4
