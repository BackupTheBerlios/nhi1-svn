/**
\defgroup \self\ext \self

The \b \lang \b Application-Server and \b Programming-Language-Micro-Kernel Project

\section \NS{syn} SYNOPSIS
<B>\package</B>

\section \NS{idx} INDEX

\RNS{context}\n
\RNS{config}\n
\RNS{ClientServerLink}\n
\RNS{service}\n
\RNS{SendData}\n
\RNS{ReadData}\n
\RNS{SlaveContext}\n
\RNS{BufferObject}\n
\RNS{ErrorObject}\n
\RNS{filter}\n
\RNS{ContextLocalStorage}

\section	\NS{desc}				INTRODUCTION
\copydoc Mq_C_API

\section	\NS{context}				CONTEXT API
\RNSA{ContextCreate}\n
\RNSA{ContextDelete}\n
\RNSA{Exit}\n \if TCL \RNSA{Main}\n \endif
\RNSA{LogC}\n \if HAS_LOGV \RNSA{LogV}\n \endif \if HAS_LOGVL \RNSA{LogVL}\n \endif

\copydoc Mq_Context_C_API

\subsection	\NS{ContextCreate}			\ContextCreate
\copydoc MqContextCreate

\b Example: create an \e application-context with \e mydata as \e application-specific-data:
\object_example

\subsection	\NS{ContextDelete}			\ContextDelete
\copydoc MqContextDelete

\subsection	\NS{Exit}				\Exit
\copydoc MqExitP

\subsection	\NS{LogC}				\LogC
\copydoc MqLogC

\if HAS_LOGV
\subsection	\NS{LogV}				\LogV
\copydoc MqLogV
\endif

\if HAS_LOGVL
\subsection	\NS{LogVL}				\LogVL
\copydoc MqLogVL
\endif

\if TCL
\subsection	\NS{Main}				\Main
Tcl has a special requirement, for every new \e server-thread a new interpreter is created and
this interpreter source the toplevel file for initialization. This file is set on library startup and
can be changed with \RNSA{Init}. The problem is the server startup code from the toplevel. For internal
purpose this code should only be executed on \e application-startup (like the C \b main function) 
and not for every thread again, use \RNSA{Main} to achieve this.
\verbatim
package require TclMsgque
...
proc ServerSetup {ctx} ...
proc ServerCleanup {ctx} ...
...
tclmsgque Main {
  set srv [tclmsgque MqS]
  $srv ConfigSetServerSetup ServerSetup
  $srv ConfigSetServerCleanup ServerCleanup
  $srv ConfigSetFactory
  if {[catch {
    $srv LinkCreate {*}$argv
    $srv ProcessEvent -wait FOREVER
  }]} {
    $srv ErrorSet
  }
  $srv Exit
}
\endverbatim
\endif


\section	\NS{config}				CONFIG API
\RNSA{Init}\n
\RNSC{buffersize}, \RNSC{debug}, \RNSC{timeout}\n
\RNSC{name}, \RNSC{srvname}, \RNSC{ident}\n
\RNSC{isSilent}, \RNSC{isString}, \RNSC{isServer}\n
\RNSC{tcp}, \RNSC{uds}, \RNSC{pipe}\n
\RNSC{startAs}, \RNSC{daemon}, \RNSC{ignoreExit}\n
\RNSC{IServerSetup}, \RNSC{IServerCleanup}\n
\RNSC{IFactory}, \RNSC{IBgError}, \RNSC{IEvent}\n

\copydoc Mq_Config_C_API

\subsection \NS{Init} static: \Init
\copydoc MqInitCreate

\b Example: initialize the \e stratup-prefix with \e myExecutable and \e myFirstArgument \init_example

\configsection{buffersize, --buffersize}
\copydoc MqIoConfigS::buffersize

\configsection{debug, --debug}
\copydoc MqConfigS::debug

\configsection{timeout, --timeout}
\copydoc MqIoConfigS::timeout

\configsection{name, --name}
\copydoc MqConfigS::name

\configsection{srvname, --srvname}
\copydoc MqConfigS::srvname

\configsection{ident}
\copydoc MqSetupS::ident

\configsection{isSilent,--silent}
\copydoc MqConfigS::isSilent

\configsection{isString,--string}
\copydoc MqConfigS::isString

\configsection{isServer}
\copydoc MqSetupS::isServer

\configsection{tcp,--tcp --host --port --myhost --myport}
\copydoc MqIoTcpConfigS
\retException

\configsection{uds,--uds --file}
\copydoc MqIoUdsConfigS
\retException

\configsection{pipe,--pipe --socket}
\copydoc MqIoPipeConfigS
\retException

\configsection{startAs,--thread --spawn --fork}
\copydoc MqConfigS::startAs

\configsection{daemon, --daemon}
\if DAEMON
\copydoc MqConfigSetDaemon
\else
This option is \b not available for \self.
\endif

\configsection{ignoreExit}
\copydoc MqSetupS::ignoreExit

\interface{IServerSetup}
\copydetails MqSetupS::ServerSetup

\interface{IServerCleanup}
\copydetails MqSetupS::ServerCleanup

\interface{IFactory}
\copydetails MqSetupS::Factory
\b Example: \config_IFactory_example

\interface{IBgError}
\copydetails MqSetupS::BgError

\interface{IEvent}
\copydetails MqSetupS::Event

\section	\NS{ClientServerLink}			LINK API
\RNSA{LinkCreate}\n
\RNSA{LinkCreateChild}\n
\RNSA{LinkDelete}\n
\RNSA{LinkConnect}\n
\RNSA{LinkGetParent}\n
\RNSA{LinkIsParent}\n
\RNSA{LinkGetCtxId}\n
\RNSA{LinkIsConnected}\n
\RNSA{LinkGetTargetIdent}\n

\copydoc Mq_Link_C_API

\subsection	  \NS{LinkCreate}			\LinkCreate
\if LinkCreate2
\subsection	  \NS{LinkCreate2}			\LinkCreate2
\endif
\if LinkCreate3
\subsection	  \NS{LinkCreate3}			\LinkCreate3
\endif
\if LinkCreate4
\subsection	  \NS{LinkCreate4}			\LinkCreate4
\endif
\if LinkCreate5
\subsection	  \NS{LinkCreate5}			\LinkCreate5
\endif
\copydoc MqLinkCreate

\subsection	  \NS{LinkCreateChild}			\LinkCreateChild
\if LinkCreateChild2
\subsection	  \NS{LinkCreateChild2}			\LinkCreateChild2
\endif
\if LinkCreateChild3
\subsection	  \NS{LinkCreateChild3}			\LinkCreateChild3
\endif
\if LinkCreateChild4
\subsection	  \NS{LinkCreateChild4}			\LinkCreateChild4
\endif
\if LinkCreateChild5
\subsection	  \NS{LinkCreateChild5}			\LinkCreateChild5
\endif
\copydoc MqLinkCreateChild

\subsection	  \NS{LinkDelete}			\LinkDelete
\copydoc MqLinkDelete

\subsection	  \NS{LinkConnect}			\LinkConnect
\copydoc MqLinkConnect

\subsection	  \NS{LinkGetParent}			\LinkGetParent
\copydoc MqLinkGetParent

\subsection	  \NS{LinkGetCtxId}			\LinkGetCtxId
\copydoc MqLinkGetCtxId

\subsection	  \NS{LinkIsParent}			\LinkIsParent
\copydoc MqLinkIsParent

\subsection	  \NS{LinkIsConnected}			\LinkIsConnected
\copydoc MqLinkIsConnected

\subsection	  \NS{LinkGetTargetIdent}		\LinkGetTargetIdent
\copydoc MqLinkGetTargetIdent

\section	\NS{service}				SERVICE API
\RNSA{ServiceIdentifier}\n
\RNSA{ServiceCallback}\n
\RNSA{ServiceGetToken}\n
\RNSA{ServiceIsTransaction}\n
\RNSA{ServiceGetFilter}\n
\RNSA{ServiceCreate}\n
\RNSA{ServiceDelete}\n
\RNSA{ProcessEvent}\n

\copydoc Mq_Service_C_API

\b Example: define the service \e SRV1 on the \e server-link-setup: \service_example

\subsection	  \NS{ServiceIdentifier}		TOKEN IDENTIFIER
\copydoc MQ_TOK

\subsection	  \NS{ServiceCallback}			SERVICE CALLBACK
\copydoc MqServiceCallbackF
\if CSHARP
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>void Callback()</I>.
\elseif VB
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>Sub Callback()</I>.
\elseif JAVA
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I>
\elseif PYTHON
The callback is implemented using \ServiceInterface method <I>Service(ctx)</I>
\elseif TCL
The callback is implemented as callback using <I>proc Service {ctx} ...</I>
\elseif PERL
The callback is implemented as callback using <I>sub Service {my ctx = shift;...}</I>
\elseif CC
The callback is implemented using \ServiceInterface method <I>Service(MqC ctx)</I> or
as callback using <I>void CallbackF()</I>.
\elseif C
The callback is implemented as a set of functions and data suitable for #MqCallbackS.
\else
UNKNOWN
\endif

\subsection	  \NS{ServiceGetToken}			\ServiceGetToken
\copydoc MqServiceGetToken

\subsection	  \NS{ServiceIsTransaction}		\ServiceIsTransaction
\copydoc MqServiceIsTransaction

\subsection	  \NS{ServiceGetFilter}			\ServiceGetFilter
\copydoc MqServiceGetFilter

\subsection	  \NS{ServiceCreate}			\ServiceCreate
\if ServiceCreate2
\subsection	  \NS{ServiceCreate2}			\ServiceCreate2
\endif
\copydoc MqServiceCreate

\subsection       \NS{ServiceProxy}			\ServiceProxy
\copydoc MqServiceProxy

\subsection	  \NS{ServiceDelete}			\ServiceDelete
\copydoc MqServiceDelete

\subsection	  \NS{ProcessEvent}			\ProcessEvent
\copydoc MqProcessEvent

\section	\NS{SendData}				SEND API
\RNSA{SendSTART}\n
\RNSA{SendEND}\n
\RNSA{SendEND_AND_WAIT}\n
\RNSA{SendEND_AND_CALLBACK}\n
\RNSA{SendRETURN}\n
\RNSA{SendERROR}\n
\RNSA{SendTYPE}\n
\RNSA{SendN}\n
\RNSA{SendBDY}\n
\RNSA{SendL_START}\n
\RNSA{SendL_END}\n
\RNSA{SendT_START}\n
\RNSA{SendT_END}\n

\copydoc Mq_Send_C_API
\b Example: send an integer and a list of double, string and a \e byte-array: \send_example

\subsection	  \NS{SendSTART}			\SendSTART
\copydoc MqSendSTART

\subsection	  \NS{SendEND}				\SendEND
\copydoc MqSendEND

\subsection	  \NS{SendEND_AND_WAIT}			\SendEND_AND_WAIT
\copydoc MqSendEND_AND_WAIT

\subsection	  \NS{SendEND_AND_CALLBACK}		\SendEND_AND_CALLBACK
\if SendEND_AND_CALLBACK2
\subsection	  \NS{SendEND_AND_CALLBACK2}		\SendEND_AND_CALLBACK2
\endif
\copydoc MqSendEND_AND_CALLBACK

\subsection	  \NS{SendRETURN}			\SendRETURN
\copydoc MqSendRETURN

\subsection	  \NS{SendERROR}			\SendERROR
\copydoc MqSendERROR

\subsection	  \NS{SendTYPE}				\SendTYPE
\copydoc MqSendY

\subsection	  \NS{SendN}				\SendN
\copydoc MqSendN

\subsection	  \NS{SendBDY}				\SendBDY
\copydoc MqSendBDY

\subsection	  \NS{SendL_START}			\SendL_START
\copydoc MqSendL_START

\subsection	  \NS{SendL_END}			\SendL_END
\copydoc MqSendL_END

\subsection	  \NS{SendT_START}			\SendT_START
\copydoc MqSendT_START
\b Example: make a \e service-call with \e transaction-support: \SendT_example

\subsection	  \NS{SendT_END}			\SendT_END
\copydoc MqSendT_END

\section	  \NS{ReadData}				READ API
\RNSA{ReadTYPE}\n
\RNSA{ReadN}\n
\RNSA{ReadBDY}\n
\RNSA{ReadU}\n
\RNSA{ReadL_START}\n
\RNSA{ReadL_END}\n
\RNSA{ReadT_START}\n
\RNSA{ReadT_END}\n
\RNSA{ReadProxy}\n
\RNSA{ReadGetNumItems}\n
\RNSA{ReadItemExists}\n
\RNSA{ReadUndo}\n

\copydoc Mq_Read_C_API
\b Example: read an integer and a list of double, string and a \e byte-array: \read_example

\subsection	  \NS{ReadTYPE}				\ReadTYPE
\copydoc MqReadY

\subsection	  \NS{ReadN}				\ReadN
\copydoc MqReadN

\subsection	  \NS{ReadBDY}				\ReadBDY
\copydoc MqReadBDY

\subsection	  \NS{ReadU}				\ReadU
\copydoc MqReadU

\subsection	  \NS{ReadL_START}			\ReadL_START
\if ReadL_START2
\subsection	  \NS{ReadL_START2}			\ReadL_START2
\endif
\if ReadL_START3
\subsection	  \NS{ReadL_START3}			\ReadL_START3
\endif
\copydoc MqReadL_START

\subsection	  \NS{ReadL_END}			\ReadL_END
\copydoc MqReadL_END

\subsection	  \NS{ReadT_START}			\ReadT_START
\if ReadT_START2
\subsection	  \NS{ReadT_START2}			\ReadT_START2
\endif
\if ReadT_START3
\subsection	  \NS{ReadT_START3}			\ReadT_START3
\endif
\copydoc MqReadT_START
\b Example: read the results from a \e service-call with \e transaction-support: \ReadT_example

\subsection	  \NS{ReadT_END}			\ReadT_END
\copydoc MqReadT_END

\subsection	  \NS{ReadProxy}			\ReadProxy
\copydoc MqReadProxy

\subsection	  \NS{ReadGetNumItems}			\ReadGetNumItems
\copydoc MqReadGetNumItems

\subsection	  \NS{ReadItemExists}			\ReadItemExists
\copydoc MqReadItemExists

\subsection	  \NS{ReadUndo}				\ReadUndo
\copydoc MqReadUndo

\section        \NS{SlaveContext}			SLAVE API
\RNSA{SlaveWorker}\n
\RNSA{SlaveCreate}\n
\RNSA{SlaveDelete}\n
\RNSA{SlaveGet}\n
\RNSA{SlaveGetMaster}\n
\RNSA{SlaveIs}\n

\copydetails Mq_Slave_C_API

\subsection	  \NS{SlaveWorker}			\SlaveWorker
\if LinkCreate2
\subsection	  \NS{SlaveWorker2}			\SlaveWorker2
\endif
\if LinkCreate3
\subsection	  \NS{SlaveWorker3}			\SlaveWorker3
\endif
\if LinkCreate4
\subsection	  \NS{SlaveWorker4}			\SlaveWorker4
\endif
\if LinkCreate5
\subsection	  \NS{SlaveWorker5}			\SlaveWorker5
\endif
\if LinkCreate6
\subsection	  \NS{SlaveWorker6}			\SlaveWorker6
\endif
\copydoc MqSlaveWorker

\b example create a worker with id 7 and name "MyWorker" as thread.
\SlaveWorker_example

\subsection	  \NS{SlaveCreate}			\SlaveCreate
\copydoc MqSlaveCreate

\subsection	  \NS{SlaveDelete}			\SlaveDelete
\copydoc MqSlaveDelete

\subsection	  \NS{SlaveGet}				\SlaveGet
\copydoc MqSlaveGet

\subsection	  \NS{SlaveGetMaster}			\SlaveGetMaster
\copydoc MqSlaveGetMaster

\subsection	  \NS{SlaveIs}				\SlaveIs
\copydoc MqSlaveIs

\section        \NS{BufferObject}			BUFFER API
\RNSA{BufferIdentifer}\n
\RNSA{BufferGetTYPE}\n
\RNSA{BufferType}\n

\copydoc MqBufferS

\b Example: read a \e buffer-object and check for \e string-type. 
\buffer_example

\subsection	  \NS{BufferIdentifer}			TYPE IDENTIFIER
\copydoc MqTypeE

\subsection	  \NS{BufferGetTYPE}			\BufferGetTYPE
return the data form the buffer using the \RNS{BufferIdentifer}.

\subsection	  \NS{BufferType}			\BufferType
return the type as single character of the item stored in the buffer object.


\section	\NS{ErrorObject}			EXCEPTION OBJECT
\RNSA{ErrorGetText}\n
\RNSA{ErrorGetNum}\n
\RNSA{ErrorC}\n
\RNSA{ErrorSet}\n
\RNSA{ErrorSetCONTINUE}\n
\RNSA{ErrorIsEXIT}\n
\RNSA{ErrorReset}\n
\RNSA{ErrorRaise}\n
\RNSA{ErrorPrint}\n

The \e exception-object (\ErrorObject) is used to transport the \e error from the
\libmsgque context using the \e programming-language error-handling-code.

\b Example: catch an error and write the message to stdout: \error_example

\subsection	\NS{ErrorGetText}			\ErrorGetText
\copydoc MqErrorGetText

\subsection	\NS{ErrorGetNum}			\ErrorGetNum
\copydoc MqErrorGetNum

\subsection	\NS{ErrorC}				\ErrorC
\copydoc MqErrorC

\subsection	\NS{ErrorSet}				\ErrorSet
convert a \ErrorObject into a \self conform error using the \e ctx object. This method is used to enable
additional error processing capabilities from \RNSA{LinkDelete} or \RNSA{Exit} after the exception was
caught and before the application exit or the object is deleted.

\subsection	\NS{ErrorSetCONTINUE}			\ErrorSetCONTINUE
\copybrief MqErrorSetCONTINUE

\subsection	\NS{ErrorIsEXIT}			\ErrorIsEXIT
\copydoc MqErrorIsEXIT

\b Example: catch and ignore an EXIT return-code: \ErrorIsEXIT_example

\subsection	\NS{ErrorReset}				\ErrorReset
\copydoc MqErrorReset

\subsection	\NS{ErrorRaise}				\ErrorRaise
convert the error from an \e context into an \RNS{ErrorObject} and raise the object.

\subsection	\NS{ErrorPrint}				\ErrorPrint
\copydoc MqErrorPrint

\section	\NS{ContextLocalStorage}		CONTEXT LOCAL STORAGE API
\if DATA
The CONTEXT LOCAL STORAGE is required to bind the \e application-specific-data to the \self context

\subsection	\NS{DictSet}				\DictSet
Add \e data using \e key into the local storage and return the \e data afterwards.

\subsection	\NS{DictGet}				\DictGet
return the \e data associated with \e key or \DictUndef if \e key does not exists.

\subsection	\NS{DictExists}				\DictExists
return \yes if \e key exists or \no if not.

\subsection	\NS{DictUnset}				\DictUnset
Remove the \e key and the associated \e data from the local storage.
\else
The \e application-specific-data is available as \e class-data-member.
\endif
\if PERL
The following code is valid for an object reference:
\code
undef $ctx->DictUnset($key);
\endcode
\endif

\section	\NS{filter}				FILTER MODE
\copydoc Mq_Filter_C_API

\section	\NS{portability}			PORTABILITY ISSUES
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc
or i686 processor from the VritualBox emulator.

\section	\NS{example}				EXAMPLES

\subsection \NS{e1} 1. create a server to multiplicate 2 double values and return the result
\if PYTHON
\dontinclude mulserver.py
\skip import
\until Exit
Start \e mulserver.py using \e TCP port \e 7777 and create a \e fork for every incoming connection
\verbatim
> python mulserver.py --tcp --port 7777 --fork
\endverbatim
\elseif JAVA
\include mulserver.java
Start \e mulserver.java using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> java example.mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CSHARP
\include mulserver.cs
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif VB
\dontinclude mulserver.vb
\skip Imports
\until End Module
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif TCL
\dontinclude mulserver.tcl
\skip TclMsgque
\until Exit
\until }
Start \e mulserver.tcl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> tclsh mulserver.tcl --tcp --port 7777 --thread
\endverbatim
\elseif PERL
\dontinclude mulserver.pl
\skip strict
\until Exit
Start \e mulserver.pl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> perl mulserver.pl --tcp --port 7777 --thread
\endverbatim
\elseif C
\include mulserver.c
Start \e mulserver.c using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CC
\include mulserver.cc
Start \e mulserver.cc using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\endif

\subsection \NS{e2} 2. in a client call the service from 1.
\if PYTHON
\dontinclude mulclient.py
\skip import
\until Exit
Use \e mulclient.py to connect to \e mulserver.py using \e TCP port \e 7777:
\verbatim
> python mulclient.py --tcp --port 7777
\endverbatim
\elseif JAVA
\include mulclient.java
Use \e mulclient.java to connect to \e mulserver.java using \e TCP port \e 7777:
\verbatim
> java example.mulclient --tcp --port 7777
\endverbatim
\elseif CSHARP
\include mulclient.cs
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif VB
\dontinclude mulclient.vb
\skip Imports
\until End Module
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif TCL
\dontinclude mulclient.tcl
\skip TclMsgque
\until Exit
Use \e mulclient.tcl to connect to \e mulserver.tcl using \e TCP port \e 7777:
\verbatim
> tclsh mulclient.tcl --tcp --port 7777
\endverbatim
\elseif PERL
\dontinclude mulclient.pl
\skip strict
\until Exit
Use \e mulclient.pl to connect to \e mulserver.pl using \e TCP port \e 7777:
\verbatim
> perl mulclient.pl --tcp --port 7777
\endverbatim
\elseif C
\include mulclient.c
Use \e mulclient.c to connect to \e mulserver.c using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\elseif CC
\include mulclient.cc
Use \e mulclient.cc to connect to \e mulserver.cc using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\endif

\subsection \NS{e3} 3. create a filter to wrap every column in a '<>' pair
\if PYTHON
\dontinclude manfilter.py
\skip import
\until Exit
Use \e manfilter.py in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ python manfilter.py @ atool join -d :
\endverbatim
\elseif JAVA
\include manfilter.java
Use \e manfilter.java in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ java example.manfilter @ atool join -d :
\endverbatim
\elseif CSHARP
\include manfilter.cs
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif VB
\dontinclude manfilter.vb
\skip Imports
\until End Module
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif TCL
\dontinclude manfilter.tcl
\skip TclMsgque
\until Exit
Use \e manfilter.tcl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ tclsh manfilter.tcl @ atool join -d :
\endverbatim
\elseif PERL
\dontinclude manfilter.pl
\skip strict
\until Exit
Use \e manfilter.pl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ perl manfilter.pl @ atool join -d :
\endverbatim
\elseif C
\include manfilter.c
Use \e manfilter.c in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\elseif CC
\include manfilter.cc
Use \e manfilter.cc in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\endif

\section	\NS{also}				SEE ALSO
\lang, C: libmsgque(n), C++: ccmsgque(n), C#: csmsgque(n), JAVA: javamsgque(n), PYTHON: pymsgque(n), 
TCL: tclmsgque(n), PERL: perlmsgque(n), VB.NET: vbmsgque(n)

\section	\NS{keywords}				KEYWORDS
\lang, unix, socket, message, msgque


*/

