/**
\defgroup \self \self

The \b \lang Application-Server Project

\section \NS{syn} SYNOPSIS
<B>\package</B>

\section \NS{idx} INDEX

\RNS{object}\n
\RNS{config}\n
\RNS{link}\n
\RNS{service}\n
\RNS{send}\n
\RNS{read}\n
\RNS{slave}\n
\RNS{buffer}\n
\RNS{error}\n
\if DATA \RNS{data} \endif

\section	\NS{desc}				INTRODUCTION
The msgque project is an infrastructure to link software together to act like a single software. 
To link mean distributing work from one software to an other software an wait or not wait for an 
answer. The linking is done using unix or inet domain sockets and is based on packages send from one software 
to an other software and back. The msgque project is used to handle all the different aspects for 
setup and maintain the link and is responsible for:
  - starting and stopping the server application
  - starting and stopping the communication interface
  - sending and receiving package data
  - reading and writing data from or into a package
  - setup and maintain the event-handling for an asynchronous transfer
  - propagate the error messages from the server to the client
  .


\section	\NS{object}				OBJECT CREATION AND DELETION

\subsection     \NS{MqS}				\MqS
The \e object is the user visible part of a \self application link.

\subsection	\NS{ObjectCreate}			\ObjectCreate
Create an object ready to be used with \RNSA{LinkCreate} to setup an application link.
Use the \RNSC{isConnected} to check if a link is already available.

\if CC
\code
class MyClass : public MqC ... { ... }
int main (int argc, MQ_CST argv[]) {
  MyClass ctx; ...
}
\endcode
\elseif JAVA
\code
final class MyClass extends MqS ... { ... }
public static void main(String[] args) {
  MyClass ctx = new MyClass(); ...
}
\endcode
\elseif CSHARP
\code
sealed class MyClass : MqS ... { ... }
static void Main(string[] args)
  MyClass ctx = new MyClass(); ...
}
\endcode
\elseif VB
\code
Private NotInheritable Class MyClass
  Inherits MqS
End Class
Sub Main(ByVal args() As String)
  Dim ctx AS New MyClass()
End Sub
\endcode
\elseif PYTHON
\code
class MyClass(MqS):
  ...
ctx = MyClass()
...
\endcode
\endif

\subsection	\NS{ObjectDelete}			\ObjectDelete
Delete the entire object including the application link using \RNSA{LinkDelete}. The
object can \b not be reused.


\section	\NS{config}				OBJECT CONFIGURATION
The configuration of an object is done using the functions starting with \c MqConfig...
or by using command-line arguments.

\subsection \NS{Init} static: \Init
Initialize the process startup argument prefix. The startup-prefix have to be the
name of the executable found in the \c PATH and additional arguments like
a script name or required startup options. 
The startup-prefix is used for two different purpose:
 - To start a new entity using the \RNSC{startAs} "--spawn" command-line option
 - To replace the \RNSA{LinkCreate} "SELF" argument after the \e "@" command-line argument
 .
\if TCL
The startup-prefix is initially set by \self during package loading.
\elseif PERL
The startup-prefix is initially set by \self during package loading.
\elseif PYTHON
The startup-prefix is initially set by \self during package loading.
\elseif CSHARP
The startup-prefix is initially set by \self during package loading.
\elseif VB
The startup-prefix is initially set by \self during package loading.
\elseif CC
The startup-prefix is initially set by \self during package loading.
\code
struct MqBufferLS * init = MqInitCreate();
MqBufferLAppendC(init, "myExecutable");
MqBufferLAppendC(init, "myFirstArgument");
\endcode
\attention the memory is owned by \self -> do \e not free the memory
\elseif C
\return a pointer to the init object.
\attention the prefix have to fit to the underlying programming language

To initialize the startup-prefix the following code have to be used:
\code
struct MqBufferLS * init = MqInitCreate();
MqBufferLAppendC(init, "myExecutable");
MqBufferLAppendC(init, "myFirstArgument");
\endcode
\attention the memory is owned by \self -> do \e not free the memory
\elseif JAVA
The startup-prefix is \e not set by default.
\endif

\configsection{buffersize, --buffersize}
The send and receive buffersize in bytes (default: 4KB)

\configsection{debug, --debug}
Debug a message-queue application. Valid values are 0 <= \e NUM <= 9 using 0 for "no
debugging" and 9 for "maximum debugging". (default: 0)

\configsection{timeout, --timeout}
User defined timeout used for connection setup and data sending (default: 90 seconds)

\configsection{name, --name}
Use \e STRING as basename of the new message-queue object. The name shows up in the debugging output
and is used as prefix for the new created command. (default: the name of the executable)

\configsection{srvname, --srvname}
Use \e STRING as a client specific prefix in the server debugging output. This is used to
link debugging and error messages on the server to a specific client connection.
(default: empty)

\configsection{ident}
Use \config_type_ident as an application specific identifier set by the programmer and checked with
\c \config_check_ident against the \e identifier of the link target. The goal is to change the behavior 
of the application depending on the result.
(default: empty)

\configsection{isSilent,--silent}
Write (\no) or don't write (\yes) any output to stdout or stderr. (default: write to stdout or stderr)

\configsection{isString,--string}
Use (\yes), as much as possible, strings in the data-package. Convert any native data-type,
like integer or double, into a string (sending) and back to native (receiving). (default: use binary)

\configsection{ignoreExit}
\copydetails MqSetupS::ignoreExit

\configsection{startAs,--thread --spawn --fork}
Start a new server as \e thread or \e spawn a new process or \e fork a new process. 
This arguments are used with:
 - a server-context to start a new instance after a client connection request 
 - on a server to create a worker with: \RNSA{SlaveWorker}
 - on a client/server together with the \b "SELF" command-line argument: \RNSA{LinkCreate}
 .
\param[in] startAs 0=default, 1=fork, 2=thread and 3=spawn

\ifnot JAVA
\ifnot CSHARP
\ifnot VB
\configsection{daemon, --daemon}
Close all default IO (e.g stdout, stdin, stderr) and fork the server into the background. (default: no daemon)
\attention this option require the \b fork system-call and is \b not compatible with threads.
\param[in] pidfile the name of the file to write the PID into
\endif
\endif
\endif

\configsection{tcp,--tcp --host --port --myhost --myport}
Configure a \e tcp socket link.
\param host 
 client: name of the remote host (default: localhost)\n
 server: name of the local interface (default: listen on \e all interfaces)
\param port
 client: name of the remote port\n
 server: name of the local port
\param myhost client: name of the local interface
\param myport client: name of the local port
\attention named ports are supported as well

\configsection{uds,--uds --file}
Use a \e uds (http://en.wikipedia.org/wiki/Unix_domain_socket) socket link. 
The uds communication is usually 50% faster than a local tcp communication but
only available on UNIX.
\param[in] file the name of the \e uds file

\configsection{pipe,--pipe --socket}
Start a \e pipe server to listen on \e socket. This is the \b default mode to start a server.
The \e socket option is special because it is used for internal purpose to submit the socket from the 
client to the server started as pipe by the client. 
\param[in] socket the file-descriptor number. The only public usage for this option is to serve as
interface for an existing tool like (x)inetd. The (x)inetd tool is a \e UNIX service to listen on a tcp/ip port
and start for every connection the proper entry from the file \e /etc/(x)inetd.conf with the file-descriptor
\e 0 as send/recv socket handle.

\configsection{master}
return the \e master if \e ctx is a slave-context or \e NULL if \e ctx is not a slave-context.
!Only a SLAVE has a master!

\configsection{filter}
Get the \e filter object from a filter pipeline using the following order: \throw
-# return the \e #MqConfigS::master if non NULL
-# return the \e #MqSlaveGet with \e id if non NULL
-# return a "filter not available" error
.

\configsection{ctxId}
return an identifier as integer and is \e unique per parent-context. The \e parent-context is always \c 0
and every new \e child-context get a new identifier by adding 1.

\configsection{isConnected}
Is the \self context connected ? A context is connected if the \RNSA{LinkCreate} command
was successful and a context is NOT connected if a) the object has just been created or
b) the link was deleted with \RNSA{LinkDelete}

\configsection{isTransaction}
Return \yes if a transaction is ongoing. This function is only usefull in a service, read more in \RNS{filter}.

\configsection{isServer}
True if object is a \e server object (default: \no, be a client)

\configsection{isParent}
True if object is a \e parent object (default: \yes, be a parent)

\configsection{isSlave}
True if object is a \e slave object (default: \no, not be a slave)

\interface{IServerSetup}
Interface to define a \e server \self object. This Interface define the
ServerSetup callback called at \RNSA{LinkCreate} to define the services 
or to initialize context specific variables.
This interface set the \RNSC{isServer} configuration value to \yes.

\interface{IServerCleanup}
Interface to define a \e server \self object. This Interface define the
ServerCleanup callback called at \RNSA{LinkDelete} to free context specific variables.
This interface set the \RNSC{isServer} configuration value to \yes.

\interface{IFactory}
The factory pattern is used to create a new application object (read more at: \ref #MqSetupS::Factory)
Without the \e Factory pattern only the initial startup context is available to serve
incoming requests. In general every server need to provide a \e Factory pattern.
\if PYTHON
\code
class Server(MqS):
  def __init__(self):
    self.ConfigSetName("server")
    self.ConfigSetFactory(lambda: Server())
...
\endcode
\elseif CC
\code
class Server: public MqC, public IFactory, ... {
  private:
    MqC* Factory() const { return new Server(); }
  ...
}
\endcode
\elseif CSHARP
\code
sealed class Server : MqS, IFactory ... {
  MqS IFactory.Call () {
    return new Server();
  }
  ...
}
\endcode
\elseif VB
\code
Private NotInheritable Class Server
  Inherits MqS
  Implements IFactory
  Public Function Factory() As csmsgque.MqS Implements csmsgque.IFactory.Call
    Return New Server()
  End Function
  ...
End Class
\endcode
\elseif JAVA
\code
final class Server extends MqS implements IFactory, ... {
  public MqS Factory() {
    return new Server();
  }
  ...
}
\endcode
\endif

\interface{IBgError}
Define an asynchronous error handler. This handler is used for handle errors send with \RNSA{SendERROR}.
Use \RNSA{ErrorGetNum} and \RNSA{ErrorGetText} to access the error.

\interface{IEvent}
\copydetails #MqSetupS::Event

\section	\NS{link}				LINK CREATION AND DELETION
To create and to destroy a link is the main purpose of the \self library. A link is a 
client/server connection used to perform various tasks.

\subsection	  \NS{LinkCreate}			\LinkCreate
\if LinkCreate2
\subsection	  \NS{LinkCreate2}			\LinkCreate2
\endif
\if LinkCreate3
\subsection	  \NS{LinkCreate3}			\LinkCreate3
\endif
\if LinkCreate4
\subsection	  \NS{LinkCreate4}			\LinkCreate4
\endif
\if LinkCreate5
\subsection	  \NS{LinkCreate5}			\LinkCreate5
\endif
Create a \e parent-context using the \RNS{config}. 
A parent-context is responsible to setup the client/server link:
 - the \e client-parent-context create the \e server-parent-context
 - the \e server-parent-context wait for a \e client-parent-context connection request
 .
\param[in] ctx the object from \RNS{object}
\param[in] args command-line arguments including the \b "@" item for the \e --pipe setup
\attention if the first argument after the \b "@" item is the string \b "SELF" an independent
server of the current server is started. This is not a \RNS{slave}. The "SELF" argument is
replaced by an application default setting (if available) or by arguments set with \RNSA{Init}.

\subsection	  \NS{LinkCreateChild}			\LinkCreateChild
\if LinkCreateChild2
\subsection	  \NS{LinkCreateChild2}			\LinkCreateChild2
\endif
\if LinkCreateChild3
\subsection	  \NS{LinkCreateChild3}			\LinkCreateChild3
\endif
\if LinkCreateChild4
\subsection	  \NS{LinkCreateChild4}			\LinkCreateChild4
\endif
\if LinkCreateChild5
\subsection	  \NS{LinkCreateChild5}			\LinkCreateChild5
\endif
Create a \e child-context from a \self \e parent-context and command-line arguments. 
A child is using the same process or thread as the parent but a different namespace. With a 
different namespace a child is able to act on different services on the shared server.
\param[in] ctx the object from \RNS{object}
\param[in] parent the parent object
\param[in] args all command-line arguments including the \b "@" token

\subsection	  \NS{LinkDelete}			\LinkDelete
Close the client/server link and delete the underlying communication object.
All depending objects will be deleted as well like depending \e child-context
and \e slave-context local and on the remote site of the link.

\subsection	  \NS{Exit}				\Exit
Shutdown the entire communication and exit the current process or thread.

\section	\NS{service}				ADDING SERVICES
\copydoc MqServiceAPI

\b Example: define the service \e SRV1 on the \e server-link-setup: \service_example

\subsection	  \NS{ServiceIdentifier}			TOKEN IDENTIFIER
The \e token identifier is a 4 byte string and identifies the service. The \e token is
set by the programmer to identify different services. \self is using some special \e token
for \e internal or \e common usage:
 - <B>_???</B> - all \e token starting with a \b "_" are for \b internal usage only
 - \b +ALL - used in \RNSA{ServiceCreate} and \RNSA{ServiceDelete} to listen on \b all token not handled by other \e token more precise
 - \b -ALL - used in \RNSA{ServiceDelete} to delete \b all token
 - \b +FTR - used for \RNS{filter-one}
 - \b +EOF - used for \RNS{filter-one}
 .

\subsection	  \NS{ServiceCallback}			SERVICE CALLBACK
A service is using a callback to act on an incoming service request. The callback is
linked to a \RNS{ServiceIdentifier} with \RNSA{ServiceCreate} or as argument to the
\RNSA{SendEND_AND_CALLBACK} function.
\if CSHARP
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>void Callback()</I>.
\elseif VB
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>Sub Callback()</I>.
\elseif JAVA
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I>
\elseif PYTHON
The callback is implemented using \ServiceInterface method <I>Service(ctx)</I>
\elseif TCL
The callback is implemented as TCL procedure using <I>Service {ctx}</I>
\elseif PERL
The callback is implemented as \self \e sub reference
\elseif CC
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using t type <I>void CallbackF()</I>.
\elseif C
The callback is implemented as a set of functions and data suitable for #MqCallbackS.
\else
UNKNOWN
\endif

\subsection	  \NS{ServiceGetToken}			\ServiceGetToken
\copydoc MqServiceGetToken

\subsection	  \NS{ServiceCreate}			\ServiceCreate
\if ServiceCreate2
\subsection	  \NS{ServiceCreate2}			\ServiceCreate2
\endif
\copydoc MqServiceCreate

\subsection       \NS{ServiceProxy}			\ServiceProxy
\copydoc MqServiceProxy

\subsection	  \NS{ServiceDelete}			\ServiceDelete
\copydoc MqServiceDelete

\subsection	  \NS{ProcessEvent}			\ProcessEvent
\copydoc MqProcessEvent

\section	\NS{send}				SEND DATA
\copydoc MqSendAPI
\b Example: send an integer and a list of double, string and a \e byte-array: \send_example

\subsection	  \NS{SendSTART}			\SendSTART
\copydoc MqSendSTART

\subsection	  \NS{SendEND}				\SendEND
\copydoc MqSendEND

\subsection	  \NS{SendEND_AND_WAIT}			\SendEND_AND_WAIT
\copydoc MqSendEND_AND_WAIT

\subsection	  \NS{SendEND_AND_CALLBACK}		\SendEND_AND_CALLBACK
\if SendEND_AND_CALLBACK2
\subsection	  \NS{SendEND_AND_CALLBACK2}		\SendEND_AND_CALLBACK2
\endif
\copydoc MqSendEND_AND_CALLBACK

\subsection	  \NS{SendRETURN}			\SendRETURN
\copydoc MqSendRETURN

\subsection	  \NS{SendERROR}			\SendERROR
\copydoc MqSendERROR

\subsection	  \NS{Send_TYPE}			\Send_TYPE
\copydoc MqSendY

\subsection	  \NS{SendN}				\SendN
\copydoc MqSendN

\subsection	  \NS{SendBDY}				\SendBDY
\copydoc MqSendBDY

\subsection	  \NS{SendL_START}			\SendL_START
\copydoc MqSendL_START

\subsection	  \NS{SendL_END}			\SendL_END
\copydoc MqSendL_END

\section	\NS{read}				READ DATA
\copydoc MqReadAPI
\b Example: read an integer and a list of double, string and a \e byte-array: \read_example

\subsection	  \NS{Read_TYPE}			\Read_TYPE
\copydoc MqReadY

\subsection	  \NS{ReadN}				\ReadN
\copydoc MqReadN

\subsection	  \NS{ReadBDY}				\ReadBDY
\copydoc MqReadBDY

\subsection	  \NS{ReadU}				\ReadU
\copydoc MqReadU

\subsection	  \NS{ReadProxy}			\ReadProxy
\copydoc MqReadProxy

\subsection	  \NS{ReadGetNumItems}			\ReadGetNumItems
\copydoc MqReadGetNumItems

\subsection	  \NS{ReadItemExists}			\ReadItemExists
\copydoc MqReadItemExists

\subsection	  \NS{ReadUndo}				\ReadUndo
\copydoc MqReadUndo

\subsection	  \NS{ReadL_START}			\ReadL_START
\if ReadL_START2
\subsection	  \NS{ReadL_START2}			\ReadL_START2
\endif
\if ReadL_START3
\subsection	  \NS{ReadL_START3}			\ReadL_START3
\endif
\copydoc MqReadL_START

\subsection	  \NS{ReadL_END}			\ReadL_END
\copydoc MqReadL_END

\section        \NS{slave}				SLAVE OBJECT
\copydetails MqSlaveAPI

\subsection	  \NS{SlaveWorker}			\SlaveWorker
\if LinkCreate2
\subsection	  \NS{SlaveWorker2}			\SlaveWorker2
\endif
\if LinkCreate3
\subsection	  \NS{SlaveWorker3}			\SlaveWorker3
\endif
\if LinkCreate4
\subsection	  \NS{SlaveWorker4}			\SlaveWorker4
\endif
\if LinkCreate5
\subsection	  \NS{SlaveWorker5}			\SlaveWorker5
\endif
\if LinkCreate6
\subsection	  \NS{SlaveWorker6}			\SlaveWorker6
\endif
\copydoc MqSlaveWorker

\b example create a worker with id 7 and name "MyWorker" as thread.
\SlaveWorker_example

\subsection	  \NS{SlaveCreate}			\SlaveCreate
\copydoc MqSlaveCreate

\subsection	  \NS{SlaveDelete}			\SlaveDelete
\copydoc MqSlaveDelete

\subsection	  \NS{SlaveGet}				\SlaveGet
\copydoc MqSlaveGet

\section        \NS{buffer}				BUFFER OBJECT
The \BufferObject object is created by \RNSA{ReadU} and id used to save a <B>typeless temporary data item</B> 
from the \self data package. The lifetime of the \BufferObject is only the current callback up to the next
read operation of the same context.
\if CSHARP
\code
MqBufferS buf = ctx.ReadU();
if (buf.Type == 'C')
  Console.WriteLine(buf.C);
\endcode
\elseif VB
\code
Dim buf As MqBufferS = ctx.ReadU()
If buf.Type == "C"c
  Console.WriteLine(buf.C)
\endcode
\elseif JAVA
\code
MqBufferS buf = ctx.ReadU();
if (buf.GetType() == 'C')
  System.out.println(buf.GetC());
\endcode
\elseif PYTHON
\code
buf = ctx.ReadU()
if buf.GetType() == 'C' :
  print(buf.GetC())
\endcode
\elseif TCL
\code
set buf [$ctx ReadU]
if {[$buf GetType] == 'C'} {
  puts [$buf GetC]
}
\endcode
\elseif PERL
\code
$buf = $ctx->ReadU();
if {$buf->GetType() eq 'C'} {
  print $buf->GetC();
}
\endcode
\elseif CC
\self support 2 different buffer objects:
 -# the \e libmsgque original buffer called #MQ_BUF or #MqBufferS
 -# a \self wrapper called \c MqBufferC
 .
Both objects are linked:
\code
MqBufferC buf = ctx.ReadU();
MQ_BUF buf2 = buf.GetU();
\endcode
1. Example:
\code
MqBufferC buf = ctx.ReadU();
if (buf.GetType() == MQ_STRT)
  printf(buf.GetC());
\endcode
2. Example:
\code
MQ_BUF buf = ctx.ReadU();
if (buf->type == MQ_STRT)
  printf(buf->cur.C);
\endcode
\elseif C
\code
MQ_BUF buf = MqReadU(ctx);
if (buf->type == MQ_STRT)
  printf(buf->cur.C);
\endcode
\else
UNKNOWN
\endif

\subsection	  \NS{BufferIdentifer}			TYPE IDENTIFIER
A \self buffer data package is type safe, this mean that every item has a type prefix and every
\RNS{Read_TYPE} or \RNS{BufferGet_TYPE} have to match the previous \RNS{Send_TYPE} with the same \e TYPE.
One exception, the cast from and to string (TYPE=C) is allowed. 
The following type identifier's are available:
 - \c Y : 1 byte signed character 
 - \c O : 1 byte boolean character using \yes for yes or true or \no for no or wrong
 - \c S : 2 byte signed short
 - \c I : 4 byte signed integer
 - \c W : 8 byte signed long long integer
 - \c F : 4 byte float
 - \c D : 8 byte double
 - \c B : unsigned char array used for binary data
 - \c C : string data using a \c \\0 at the end
 - \c L : list type able to hold a list of all items from above
 - \c U : typeless buffer able to hold a single item from above
 .

\subsection	  \NS{BufferGet_TYPE}			\BufferGet_TYPE
return the data form the buffer using the \RNS{BufferIdentifer}. \throw

\subsection	  \NS{BufferType}			\BufferType
return the type as single character of the item stored in the buffer object.


\section	\NS{error}				EXCEPTION OBJECT

The exception object is used to transport a \self error using the \ErrorObject.

\b Example: catch an error and write the message to stdout: \error_example

\subsection	\NS{ErrorGetText}			\ErrorGetText
return the error message from the error object.

\subsection	\NS{ErrorGetNum}			\ErrorGetNum
return the error number from the error object. The number can be used as exit-code.

\subsection	\NS{ErrorC}				\ErrorC
create a \self error object but do \b not raise the \RNS{error}

\subsection	\NS{ErrorSet}				\ErrorSet
convert a \ErrorObject into a \self conform error using the \e ctx object. This method is used to enable
additional error processing capabilities from \RNSA{LinkDelete} or \RNSA{Exit} after the exception was
caught and before the application exit or the object is deleted.

\subsection	\NS{ErrorSetCONTINUE}			\ErrorSetCONTINUE
\copybrief MqErrorSetCONTINUE

\subsection	\NS{ErrorReset}				\ErrorReset
clear the \self error object.

\subsection	\NS{ErrorRaise}				\ErrorRaise
convert and raise an \self error object into a \lang \RNS{error}.

\subsection	\NS{ErrorPrint}				\ErrorPrint
print an \self error object to stderr and \e clear the \self error

\if DATA

\section	\NS{data}				CONTEXT LOCAL STORAGE
The CONTEXT LOCAL STORAGE is required to bind user data to the \self context

\subsection	\NS{DictSet}				\DictSet
Add \e data using \e key into the local storage and return the \e data afterwards.

\subsection	\NS{DictGet}				\DictGet
return the \e data associated with \e key or \DictUndef if \e key does not exists.

\subsection	\NS{DictExists}				\DictExists
return \yes if \e key exists or \no if not.

\subsection	\NS{DictUnset}				\DictUnset
Remove the \e key and the associated \e data from the local storage.
\if PERL
The following code is valid for an object reference:
\code
$ctx->DictUnset($key)->DESTROY();
\endcode
\endif

\endif

\section	\NS{filter}				FILTER MODE
The filter mode is related to a special usage of the \self software called a command pipeline.
To define a filter create a \e server with \RNSC{isServer} or use \RNSC{IServerSetup}
and add the required services. 

\subsection	\NS{filter-one}				ONE-DIRECTIONAL FILTER
A one-directional filter has a \e data-flow from the \e left to the \e right and is well known from the \b unix shell 
to link different commands together: \verbatim
    command1 | command2 | command3
\endverbatim
A \self command pipeline is created with the special character \b @ instead of \b | : 
\verbatim
    msgcmd1 @ msgcmd2 @ msgcmd3
\endverbatim
with every command have to use \libmsgque.
To define a \self filter create a service handle with \RNSA{ServiceCreate} or 
\RNSA{ServiceProxy} for the both special token: 
 - \b +FTR : required to act on filter data rows. Every filter input data is a list of filter data rows and every row is a list of filter data columns. Every row is send to the following filter-command as \b +FTR service request.
 - \b +EOF : required to act on End-Of-Filter data and is called after all \b +FTR data was send. Sometimes the filter data can not be served as \b +FTR data (example: sorting of the input rows need to read all rows before the data can be send to the next filter command) and the \b +EOF token is used to continue send \b +FTR data rows.
 .
and send every data item with \RNSA{SendEND_AND_WAIT}.

\subsection	\NS{filter-bi}				BI-DIRECTIONAL FILTER
A bi-directional filter has a \e data-flow in both directions and is used in a \e classical client/server application: \verbatim
    client ... <--> ... server
\endverbatim to add an additional feature like a protocol-tunnelling: \verbatim
    client @ mq2tunnel ... <--> ... tunnel2mq @ server
\endverbatim or to convert the protocol into an other protocol: \verbatim
    client @ mq2soap ... <--> ... soap-server
\endverbatim
To define a \e bi-directional filter a couple of commands provide support:
 - \RNSA{ServiceCreate} : use the token \b +ALL to act on \e all services
 - \RNSA{config_filter,ConfigGetFilter}: to get the filter context (other site)
 - \RNSA{ServiceGetToken,ServiceGetToken}: to get the current token
 - \RNSA{config_isTransaction,ConfigGetIsTransaction} : to check if a transaction is ongoing
 - \RNSA{ReadBDY} : to read the entire body as \e byte-array
 - \RNSA{SendBDY} : to send the entire body
 .

\section	\NS{portability}			PORTABILITY ISSUES
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc processor
or i686 processor from the VritualBox emulator.

\section	\NS{example}				EXAMPLES

\subsection \NS{e1} 1. create a server to multiplicate 2 double values and return the result
\if PYTHON
\dontinclude mulserver.py
\skip import
\until Exit
Start \e mulserver.py using \e TCP port \e 7777 and create a \e fork for every incoming connection
\verbatim
> python mulserver.py --tcp --port 7777 --fork
\endverbatim
\elseif JAVA
\include mulserver.java
Start \e mulserver.java using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> java example.mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CSHARP
\include mulserver.cs
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif VB
\dontinclude mulserver.vb
\skip Imports
\until End Module
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif TCL
\dontinclude mulserver.tcl
\skip TclMsgque
\until Exit
\until }
Start \e mulserver.tcl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> tclsh mulserver.tcl --tcp --port 7777 --thread
\endverbatim
\elseif PERL
\dontinclude mulserver.pl
\skip strict
\until Exit
Start \e mulserver.pl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> perl mulserver.pl --tcp --port 7777 --thread
\endverbatim
\elseif C
\include mulserver.c
Start \e mulserver.c using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CC
\include mulserver.cc
Start \e mulserver.cc using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\endif

\subsection \NS{e2} 2. in a client call the service from 1.
\if PYTHON
\dontinclude mulclient.py
\skip import
\until Exit
Use \e mulclient.py to connect to \e mulserver.py using \e TCP port \e 7777:
\verbatim
> python mulclient.py --tcp --port 7777
\endverbatim
\elseif JAVA
\include mulclient.java
Use \e mulclient.java to connect to \e mulserver.java using \e TCP port \e 7777:
\verbatim
> java example.mulclient --tcp --port 7777
\endverbatim
\elseif CSHARP
\include mulclient.cs
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif VB
\dontinclude mulclient.vb
\skip Imports
\until End Module
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif TCL
\dontinclude mulclient.tcl
\skip TclMsgque
\until Exit
Use \e mulclient.tcl to connect to \e mulserver.tcl using \e TCP port \e 7777:
\verbatim
> tclsh mulclient.tcl --tcp --port 7777
\endverbatim
\elseif PERL
\dontinclude mulclient.pl
\skip strict
\until Exit
Use \e mulclient.pl to connect to \e mulserver.pl using \e TCP port \e 7777:
\verbatim
> perl mulclient.pl --tcp --port 7777
\endverbatim
\elseif C
\include mulclient.c
Use \e mulclient.c to connect to \e mulserver.c using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\elseif CC
\include mulclient.cc
Use \e mulclient.cc to connect to \e mulserver.cc using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\endif

\subsection \NS{e3} 3. create a filter to wrap every column in a '<>' pair
\if PYTHON
\dontinclude manfilter.py
\skip import
\until Exit
Use \e manfilter.py in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ python manfilter.py @ atool join -d :
\endverbatim
\elseif JAVA
\include manfilter.java
Use \e manfilter.java in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ java example.manfilter @ atool join -d :
\endverbatim
\elseif CSHARP
\include manfilter.cs
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif VB
\dontinclude manfilter.vb
\skip Imports
\until End Module
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif TCL
\dontinclude manfilter.tcl
\skip TclMsgque
\until Exit
Use \e manfilter.tcl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ tclsh manfilter.tcl @ atool join -d :
\endverbatim
\elseif PERL
\dontinclude manfilter.pl
\skip strict
\until Exit
Use \e manfilter.pl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ perl manfilter.pl @ atool join -d :
\endverbatim
\elseif C
\include manfilter.c
Use \e manfilter.c in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\elseif CC
\include manfilter.cc
Use \e manfilter.cc in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\endif

\section	\NS{also}				SEE ALSO
\lang, C: libmsgque(n), C++: ccmsgque(n), C#: csmsgque(n), JAVA: javamsgque(n), PYTHON: pymsgque(n), 
TCL: tclmsgque(n), PERL: perlmsgque(n)

\section	\NS{keywords}				KEYWORDS
\lang, unix, socket, message, msgque


*/


