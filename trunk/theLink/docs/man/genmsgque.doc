/**
\defgroup \self \self

The \b \lang \b Application-Server and \b Programming-Language-Micro-Kernel Project

\section \NS{syn} SYNOPSIS
<B>\package</B>

\section \NS{idx} INDEX

\RNS{context}\n
\RNS{config}\n
\RNS{link}\n
\RNS{service}\n
\RNS{send}\n
\RNS{read}\n
\RNS{slave}\n
\RNS{buffer}\n
\RNS{error}\n
\if DATA \RNS{data} \endif

\section	\NS{desc}				INTRODUCTION
\copydoc Mq_C_API

\section	\NS{context}				CONTEXT API
\RNSA{ContextCreate}\n
\RNSA{ContextDelete}\n
\RNSA{Exit}\n

\copydoc Mq_Context_C_API

\subsection	\NS{ContextCreate}			\ContextCreate
\copydoc MqContextCreate

\b Example: create an \e application-context with \e mydata as \e application-specific-data:
\object_example

\subsection	\NS{ContextDelete}			\ContextDelete
\copydoc MqContextDelete

\subsection	\NS{Exit}				\Exit
\copydoc MqExit


\section	\NS{config}				CONFIG API
\RNSA{Init}\n
\RNSC{buffersize}, \RNSC{debug}, \RNSC{timeout}\n
\RNSC{name}, \RNSC{srvname}, \RNSC{ident}\n
\RNSC{isSilent}, \RNSC{isString}, \RNSC{isServer}\n
\RNSC{tcp}, \RNSC{uds}, \RNSC{pipe}\n
\RNSC{startAs}, \RNSC{daemon}, \RNSC{ignoreExit}\n
\RNSC{IServerSetup}, \RNSC{IServerCleanup}\n
\RNSC{IFactory}, \RNSC{IBgError}, \RNSC{IEvent}\n

The configuration of an object is done using the functions starting with \c MqConfig...
or by using command-line arguments.

\subsection \NS{Init} static: \Init
\copydoc MqInitCreate

\b Example: initialize the \e stratup-prefix with \e myExecutable and \e myFirstArgument \init_example

\configsection{buffersize, --buffersize}
The send and receive buffersize in bytes (default: 4KB)

\configsection{debug, --debug}
Debug a message-queue application. Valid values are 0 <= \e NUM <= 9 using 0 for "no
debugging" and 9 for "maximum debugging". (default: 0)

\configsection{timeout, --timeout}
User defined timeout used for connection setup and data sending (default: 90 seconds)

\configsection{name, --name}
Use \e STRING as basename of the new message-queue object. The name shows up in the debugging output
and is used as prefix for the new created command. (default: the name of the executable)

\configsection{srvname, --srvname}
Use \e STRING as a client specific prefix in the server debugging output. This is used to
link debugging and error messages on the server to a specific client connection.
(default: empty)

\configsection{ident}
Use \config_type_ident as an application specific identifier set by the programmer and checked with
\c \config_check_ident against the \e identifier of the link target. The goal is to change the behavior 
of the application depending on the result.
(default: empty)

\configsection{isSilent,--silent}
Write (\no) or don't write (\yes) any output to stdout or stderr. (default: write to stdout or stderr)

\configsection{isString,--string}
Use (\yes), as much as possible, strings in the data-package. Convert any native data-type,
like integer or double, into a string (sending) and back to native (receiving). (default: use binary)

\configsection{isServer}
True if object is a \e server object (default: \no, be a client)

\configsection{tcp,--tcp --host --port --myhost --myport}
Configure a \e tcp socket link.
\param host 
 client: name of the remote host (default: localhost)\n
 server: name of the local interface (default: listen on \e all interfaces)
\param port
 client: name of the remote port\n
 server: name of the local port
\param myhost client: name of the local interface
\param myport client: name of the local port
\attention named ports are supported as well

\configsection{uds,--uds --file}
Use a \e uds (http://en.wikipedia.org/wiki/Unix_domain_socket) socket link. 
The uds communication is usually 50% faster than a local tcp communication but
only available on UNIX.
\param[in] file the name of the \e uds file

\configsection{pipe,--pipe --socket}
Start a \e pipe server to listen on \e socket. This is the \b default mode to start a server.
The \e socket option is special because it is used for internal purpose to submit the socket from the 
client to the server started as pipe by the client. 
\param[in] socket the file-descriptor number. The only public usage for this option is to serve as
interface for an existing tool like (x)inetd. The (x)inetd tool is a \e UNIX service to listen on a tcp/ip port
and start for every connection the proper entry from the file \e /etc/(x)inetd.conf with the file-descriptor
\e 0 as send/recv socket handle.

\configsection{startAs,--thread --spawn --fork}
Start a new server as \e thread or \e spawn a new process or \e fork a new process. 
This arguments are used with:
 - a server-context to start a new instance after a client connection request 
 - on a server to create a worker with: \RNSA{SlaveWorker}
 - on a client/server together with the \b "SELF" command-line argument: \RNSA{LinkCreate}
 .
\param[in] startAs 0=default, 1=fork, 2=thread and 3=spawn

\configsection{daemon, --daemon}
\if DAEMON
Close all default IO (e.g stdout, stdin, stderr) and fork the server into the background. (default: no daemon)
\attention this option require the \b fork system-call and is \b not compatible with threads.
\param[in] pidfile the name of the file to write the PID into
\else
This configuration is \b not available for \self.
\endif

\configsection{ignoreExit}
\copydetails MqSetupS::ignoreExit

\interface{IServerSetup}
Interface to define a \e server \self object. This Interface define the
ServerSetup callback called at \RNSA{LinkCreate} to define the services 
or to initialize context specific variables.
This interface set the \RNSC{isServer} configuration value to \yes.

\interface{IServerCleanup}
Interface to define a \e server \self object. This Interface define the
ServerCleanup callback called at \RNSA{LinkDelete} to free context specific variables.
This interface set the \RNSC{isServer} configuration value to \yes.

\interface{IFactory}
The factory pattern is used to create a new application object (read more at: \ref #MqSetupS::Factory)
Without the \e Factory pattern only the initial startup context is available to serve
incoming requests. In general every server need to provide a \e Factory pattern.
\if PYTHON
\code
class Server(MqS):
  def __init__(self):
    self.ConfigSetName("server")
    self.ConfigSetFactory(lambda: Server())
...
\endcode
\elseif CC
\code
class Server: public MqC, public IFactory, ... {
  private:
    MqC* Factory() const { return new Server(); }
  ...
}
\endcode
\elseif CSHARP
\code
sealed class Server : MqS, IFactory ... {
  MqS IFactory.Call () {
    return new Server();
  }
  ...
}
\endcode
\elseif VB
\code
Private NotInheritable Class Server
  Inherits MqS
  Implements IFactory
  Public Function Factory() As csmsgque.MqS Implements csmsgque.IFactory.Call
    Return New Server()
  End Function
  ...
End Class
\endcode
\elseif JAVA
\code
final class Server extends MqS implements IFactory, ... {
  public MqS Factory() {
    return new Server();
  }
  ...
}
\endcode
\endif

\interface{IBgError}
Define an asynchronous error handler. This handler is used for handle errors send with \RNSA{SendERROR}.
Use \RNSA{ErrorGetNum} and \RNSA{ErrorGetText} to access the error.

\interface{IEvent}
\copydetails #MqSetupS::Event

\section	\NS{link}				LINK API
\RNSA{LinkCreate}\n
\RNSA{LinkCreateChild}\n
\RNSA{LinkGetParent}\n
\RNSA{LinkIsParent}\n
\RNSA{LinkGetCtxId}\n
\RNSA{LinkIsConnected}\n

\copydoc Mq_Link_C_API

\subsection	  \NS{LinkCreate}			\LinkCreate
\if LinkCreate2
\subsection	  \NS{LinkCreate2}			\LinkCreate2
\endif
\if LinkCreate3
\subsection	  \NS{LinkCreate3}			\LinkCreate3
\endif
\if LinkCreate4
\subsection	  \NS{LinkCreate4}			\LinkCreate4
\endif
\if LinkCreate5
\subsection	  \NS{LinkCreate5}			\LinkCreate5
\endif
\copydoc MqLinkCreate

\subsection	  \NS{LinkCreateChild}			\LinkCreateChild
\if LinkCreateChild2
\subsection	  \NS{LinkCreateChild2}			\LinkCreateChild2
\endif
\if LinkCreateChild3
\subsection	  \NS{LinkCreateChild3}			\LinkCreateChild3
\endif
\if LinkCreateChild4
\subsection	  \NS{LinkCreateChild4}			\LinkCreateChild4
\endif
\if LinkCreateChild5
\subsection	  \NS{LinkCreateChild5}			\LinkCreateChild5
\endif
\copydoc MqLinkCreateChild

\subsection	  \NS{LinkDelete}			\LinkDelete
\copydoc MqLinkDelete

\subsection	  \NS{LinkGetParent}			\LinkGetParent
\copydoc MqLinkGetParent

\subsection	  \NS{LinkGetCtxId}			\LinkGetCtxId
\copydoc MqLinkGetCtxId

\subsection	  \NS{LinkIsParent}			\LinkIsParent
\copydoc MqLinkIsParent

\subsection	  \NS{LinkIsConnected}			\LinkIsConnected
\copydoc MqLinkIsConnected

\section	\NS{service}				SERVICE API
\RNSA{ServiceIdentifier}\n
\RNSA{ServiceCallback}\n
\RNSA{ServiceGetToken}\n
\RNSA{ServiceIsTransaction}\n
\RNSA{ServiceGetFilter}\n
\RNSA{ServiceCreate}\n
\RNSA{ServiceDelete}\n
\RNSA{ProcessEvent}\n

\copydoc Mq_Service_C_API

\b Example: define the service \e SRV1 on the \e server-link-setup: \service_example

\subsection	  \NS{ServiceIdentifier}			TOKEN IDENTIFIER
The \e token identifier is a 4 byte string and identifies the service. The \e token is
set by the programmer to identify different services. \self is using some special \e token
for \e internal or \e common usage:
 - <B>_???</B> - all \e token starting with a \b "_" are for \b internal usage only
 - \b +ALL - used in \RNSA{ServiceCreate} and \RNSA{ServiceDelete} to listen on \b all token not handled by other \e token more precise
 - \b -ALL - used in \RNSA{ServiceDelete} to delete \b all token
 - \b +FTR - used for \RNS{filter-one}
 - \b +EOF - used for \RNS{filter-one}
 .

\subsection	  \NS{ServiceCallback}			SERVICE CALLBACK
A service is using a callback to act on an incoming service request. The callback is
linked to a \RNS{ServiceIdentifier} with \RNSA{ServiceCreate} or as argument to the
\RNSA{SendEND_AND_CALLBACK} function.
\if CSHARP
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>void Callback()</I>.
\elseif VB
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using a delegate of type <I>Sub Callback()</I>.
\elseif JAVA
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I>
\elseif PYTHON
The callback is implemented using \ServiceInterface method <I>Service(ctx)</I>
\elseif TCL
The callback is implemented as TCL procedure using <I>Service {ctx}</I>
\elseif PERL
The callback is implemented as \self \e sub reference
\elseif CC
The callback is implemented using \ServiceInterface method <I>Service(MqS ctx)</I> or
using t type <I>void CallbackF()</I>.
\elseif C
The callback is implemented as a set of functions and data suitable for #MqCallbackS.
\else
UNKNOWN
\endif

\subsection	  \NS{ServiceGetToken}			\ServiceGetToken
\copydoc MqServiceGetToken

\subsection	  \NS{ServiceIsTransaction}		\ServiceIsTransaction
\copydoc MqServiceIsTransaction

\subsection	  \NS{ServiceGetFilter}			\ServiceGetFilter
\copydoc MqServiceGetFilter

\subsection	  \NS{ServiceCreate}			\ServiceCreate
\if ServiceCreate2
\subsection	  \NS{ServiceCreate2}			\ServiceCreate2
\endif
\copydoc MqServiceCreate

\subsection       \NS{ServiceProxy}			\ServiceProxy
\copydoc MqServiceProxy

\subsection	  \NS{ServiceDelete}			\ServiceDelete
\copydoc MqServiceDelete

\subsection	  \NS{ProcessEvent}			\ProcessEvent
\copydoc MqProcessEvent

\section	\NS{send}				SEND API
\RNSA{SendSTART}\n
\RNSA{SendEND}\n
\RNSA{SendEND_AND_WAIT}\n
\RNSA{SendEND_AND_CALLBACK}\n
\RNSA{SendRETURN}\n
\RNSA{SendERROR}\n
\RNSA{SendTYPE}\n
\RNSA{SendN}\n
\RNSA{SendBDY}\n
\RNSA{SendL_START}\n
\RNSA{SendL_END}\n

\copydoc Mq_Send_C_API
\b Example: send an integer and a list of double, string and a \e byte-array: \send_example

\subsection	  \NS{SendSTART}			\SendSTART
\copydoc MqSendSTART

\subsection	  \NS{SendEND}				\SendEND
\copydoc MqSendEND

\subsection	  \NS{SendEND_AND_WAIT}			\SendEND_AND_WAIT
\copydoc MqSendEND_AND_WAIT

\subsection	  \NS{SendEND_AND_CALLBACK}		\SendEND_AND_CALLBACK
\if SendEND_AND_CALLBACK2
\subsection	  \NS{SendEND_AND_CALLBACK2}		\SendEND_AND_CALLBACK2
\endif
\copydoc MqSendEND_AND_CALLBACK

\subsection	  \NS{SendRETURN}			\SendRETURN
\copydoc MqSendRETURN

\subsection	  \NS{SendERROR}			\SendERROR
\copydoc MqSendERROR

\subsection	  \NS{SendTYPE}			\SendTYPE
\copydoc MqSendY

\subsection	  \NS{SendN}				\SendN
\copydoc MqSendN

\subsection	  \NS{SendBDY}				\SendBDY
\copydoc MqSendBDY

\subsection	  \NS{SendL_START}			\SendL_START
\copydoc MqSendL_START

\subsection	  \NS{SendL_END}			\SendL_END
\copydoc MqSendL_END

\section	  \NS{read}				READ API
\RNSA{ReadTYPE}\n
\RNSA{ReadN}\n
\RNSA{ReadBDY}\n
\RNSA{ReadU}\n
\RNSA{ReadL_START}\n
\RNSA{ReadL_END}\n
\RNSA{ReadProxy}\n
\RNSA{ReadGetNumItems}\n
\RNSA{ReadItemExists}\n
\RNSA{ReadUndo}\n

\copydoc Mq_Read_C_API
\b Example: read an integer and a list of double, string and a \e byte-array: \read_example

\subsection	  \NS{ReadTYPE}				\ReadTYPE
\copydoc MqReadY

\subsection	  \NS{ReadN}				\ReadN
\copydoc MqReadN

\subsection	  \NS{ReadBDY}				\ReadBDY
\copydoc MqReadBDY

\subsection	  \NS{ReadU}				\ReadU
\copydoc MqReadU

\subsection	  \NS{ReadL_START}			\ReadL_START
\if ReadL_START2
\subsection	  \NS{ReadL_START2}			\ReadL_START2
\endif
\if ReadL_START3
\subsection	  \NS{ReadL_START3}			\ReadL_START3
\endif
\copydoc MqReadL_START

\subsection	  \NS{ReadL_END}			\ReadL_END
\copydoc MqReadL_END

\subsection	  \NS{ReadProxy}			\ReadProxy
\copydoc MqReadProxy

\subsection	  \NS{ReadGetNumItems}			\ReadGetNumItems
\copydoc MqReadGetNumItems

\subsection	  \NS{ReadItemExists}			\ReadItemExists
\copydoc MqReadItemExists

\subsection	  \NS{ReadUndo}				\ReadUndo
\copydoc MqReadUndo

\section        \NS{slave}				SLAVE API
\RNSA{SlaveWorker}\n
\RNSA{SlaveCreate}\n
\RNSA{SlaveDelete}\n
\RNSA{SlaveGet}\n
\RNSA{SlaveGetMaster}\n
\RNSA{SlaveIs}\n

\copydetails Mq_Slave_C_API

\subsection	  \NS{SlaveWorker}			\SlaveWorker
\if LinkCreate2
\subsection	  \NS{SlaveWorker2}			\SlaveWorker2
\endif
\if LinkCreate3
\subsection	  \NS{SlaveWorker3}			\SlaveWorker3
\endif
\if LinkCreate4
\subsection	  \NS{SlaveWorker4}			\SlaveWorker4
\endif
\if LinkCreate5
\subsection	  \NS{SlaveWorker5}			\SlaveWorker5
\endif
\if LinkCreate6
\subsection	  \NS{SlaveWorker6}			\SlaveWorker6
\endif
\copydoc MqSlaveWorker

\b example create a worker with id 7 and name "MyWorker" as thread.
\SlaveWorker_example

\subsection	  \NS{SlaveCreate}			\SlaveCreate
\copydoc MqSlaveCreate

\subsection	  \NS{SlaveDelete}			\SlaveDelete
\copydoc MqSlaveDelete

\subsection	  \NS{SlaveGet}				\SlaveGet
\copydoc MqSlaveGet

\subsection	  \NS{SlaveGetMaster}			\SlaveGetMaster
\copydoc MqSlaveGetMaster

\subsection	  \NS{SlaveIs}				\SlaveIs
\copydoc MqSlaveIs

\section        \NS{buffer}				BUFFER API
\RNSA{BufferIdentifer}\n
\RNSA{BufferGetTYPE}\n
\RNSA{BufferType}\n

\copydoc MqBufferS

\b Example: read a \e buffer-object and check for \e string-type. 
\buffer_example

\subsection	  \NS{BufferIdentifer}			TYPE IDENTIFIER
\copydoc MqTypeE

\subsection	  \NS{BufferGetTYPE}			\BufferGetTYPE
return the data form the buffer using the \RNS{BufferIdentifer}. \throw

\subsection	  \NS{BufferType}			\BufferType
return the type as single character of the item stored in the buffer object.


\section	\NS{error}				EXCEPTION OBJECT
\RNSA{ErrorGetText}\n
\RNSA{ErrorGetNum}\n
\RNSA{ErrorC}\n
\RNSA{ErrorSet}\n
\RNSA{ErrorSetCONTINUE}\n
\RNSA{ErrorReset}\n
\RNSA{ErrorRaise}\n
\RNSA{ErrorPrint}\n

The exception object is used to transport a \self error using the \ErrorObject.

\b Example: catch an error and write the message to stdout: \error_example

\subsection	\NS{ErrorGetText}			\ErrorGetText
return the error message from the error object.

\subsection	\NS{ErrorGetNum}			\ErrorGetNum
return the error number from the error object. The number can be used as exit-code.

\subsection	\NS{ErrorC}				\ErrorC
create a \self error object but do \b not raise the \RNS{error}

\subsection	\NS{ErrorSet}				\ErrorSet
convert a \ErrorObject into a \self conform error using the \e ctx object. This method is used to enable
additional error processing capabilities from \RNSA{LinkDelete} or \RNSA{Exit} after the exception was
caught and before the application exit or the object is deleted.

\subsection	\NS{ErrorSetCONTINUE}			\ErrorSetCONTINUE
\copybrief MqErrorSetCONTINUE

\subsection	\NS{ErrorReset}				\ErrorReset
clear the \self error object.

\subsection	\NS{ErrorRaise}				\ErrorRaise
convert and raise an \self error object into a \lang \RNS{error}.

\subsection	\NS{ErrorPrint}				\ErrorPrint
print an \self error object to stderr and \e clear the \self error

\if DATA

\section	\NS{data}				CONTEXT LOCAL STORAGE API
The CONTEXT LOCAL STORAGE is required to bind user data to the \self context

\subsection	\NS{DictSet}				\DictSet
Add \e data using \e key into the local storage and return the \e data afterwards.

\subsection	\NS{DictGet}				\DictGet
return the \e data associated with \e key or \DictUndef if \e key does not exists.

\subsection	\NS{DictExists}				\DictExists
return \yes if \e key exists or \no if not.

\subsection	\NS{DictUnset}				\DictUnset
Remove the \e key and the associated \e data from the local storage.
\if PERL
The following code is valid for an object reference:
\code
$ctx->DictUnset($key)->DESTROY();
\endcode
\endif

\endif

\section	\NS{filter}				FILTER MODE
The filter mode is related to a special usage of the \self software called a command pipeline.
To define a filter create a \e server with \RNSC{isServer} or use \RNSC{IServerSetup}
and add the required services. 

\subsection	\NS{filter-one}				ONE-DIRECTIONAL FILTER
A one-directional filter has a \e data-flow from the \e left to the \e right and is well known from the \b unix shell 
to link different commands together: \verbatim
    command1 | command2 | command3
\endverbatim
A \self command pipeline is created with the special character \b @ instead of \b | : 
\verbatim
    msgcmd1 @ msgcmd2 @ msgcmd3
\endverbatim
with every command have to use \libmsgque.
To define a \self filter create a service handle with \RNSA{ServiceCreate} or 
\RNSA{ServiceProxy} for the both special token: 
 - \b +FTR : required to act on filter data rows. Every filter input data is a list of filter data rows and every row is a list of filter data columns. Every row is send to the following filter-command as \b +FTR service request.
 - \b +EOF : required to act on End-Of-Filter data and is called after all \b +FTR data was send. Sometimes the filter data can not be served as \b +FTR data (example: sorting of the input rows need to read all rows before the data can be send to the next filter command) and the \b +EOF token is used to continue send \b +FTR data rows.
 .
and send every data item with \RNSA{SendEND_AND_WAIT}.

\subsection	\NS{filter-bi}				BI-DIRECTIONAL FILTER
A bi-directional filter has a \e data-flow in both directions and is used in a \e classical client/server application: \verbatim
    client ... <--> ... server
\endverbatim to add an additional feature like a protocol-tunnelling: \verbatim
    client @ mq2tunnel ... <--> ... tunnel2mq @ server
\endverbatim or to convert the protocol into an other protocol: \verbatim
    client @ mq2soap ... <--> ... soap-server
\endverbatim
To define a \e bi-directional filter a couple of commands provide support:
 - \RNSA{ServiceCreate} : use the token \b +ALL to act on \e all services
 - \RNSA{ServiceGetFilter}: to get the filter context (other site)
 - \RNSA{ServiceGetToken}: to get the current token
 - \RNSA{ServiceIsTransaction} : to check if a transaction is ongoing
 - \RNSA{ReadBDY} : to read the entire body as \e byte-array
 - \RNSA{SendBDY} : to send the entire body
 .

\section	\NS{portability}			PORTABILITY ISSUES
The library was tested on Linux, FreeBSD and WindowsXP using a x86_64, ppc processor
or i686 processor from the VritualBox emulator.

\section	\NS{example}				EXAMPLES

\subsection \NS{e1} 1. create a server to multiplicate 2 double values and return the result
\if PYTHON
\dontinclude mulserver.py
\skip import
\until Exit
Start \e mulserver.py using \e TCP port \e 7777 and create a \e fork for every incoming connection
\verbatim
> python mulserver.py --tcp --port 7777 --fork
\endverbatim
\elseif JAVA
\include mulserver.java
Start \e mulserver.java using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> java example.mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CSHARP
\include mulserver.cs
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif VB
\dontinclude mulserver.vb
\skip Imports
\until End Module
Start \e mulserver.exe using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mono mulserver.exe --tcp --port 7777 --thread
\endverbatim
\elseif TCL
\dontinclude mulserver.tcl
\skip TclMsgque
\until Exit
\until }
Start \e mulserver.tcl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> tclsh mulserver.tcl --tcp --port 7777 --thread
\endverbatim
\elseif PERL
\dontinclude mulserver.pl
\skip strict
\until Exit
Start \e mulserver.pl using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> perl mulserver.pl --tcp --port 7777 --thread
\endverbatim
\elseif C
\include mulserver.c
Start \e mulserver.c using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\elseif CC
\include mulserver.cc
Start \e mulserver.cc using \e TCP port \e 7777 and create a \e thread for every incoming connection
\verbatim
> mulserver --tcp --port 7777 --thread
\endverbatim
\endif

\subsection \NS{e2} 2. in a client call the service from 1.
\if PYTHON
\dontinclude mulclient.py
\skip import
\until Exit
Use \e mulclient.py to connect to \e mulserver.py using \e TCP port \e 7777:
\verbatim
> python mulclient.py --tcp --port 7777
\endverbatim
\elseif JAVA
\include mulclient.java
Use \e mulclient.java to connect to \e mulserver.java using \e TCP port \e 7777:
\verbatim
> java example.mulclient --tcp --port 7777
\endverbatim
\elseif CSHARP
\include mulclient.cs
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif VB
\dontinclude mulclient.vb
\skip Imports
\until End Module
Use \e mulclient.exe to connect to \e mulserver.exe using \e TCP port \e 7777:
\verbatim
> mono mulclient.exe --tcp --port 7777
\endverbatim
\elseif TCL
\dontinclude mulclient.tcl
\skip TclMsgque
\until Exit
Use \e mulclient.tcl to connect to \e mulserver.tcl using \e TCP port \e 7777:
\verbatim
> tclsh mulclient.tcl --tcp --port 7777
\endverbatim
\elseif PERL
\dontinclude mulclient.pl
\skip strict
\until Exit
Use \e mulclient.pl to connect to \e mulserver.pl using \e TCP port \e 7777:
\verbatim
> perl mulclient.pl --tcp --port 7777
\endverbatim
\elseif C
\include mulclient.c
Use \e mulclient.c to connect to \e mulserver.c using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\elseif CC
\include mulclient.cc
Use \e mulclient.cc to connect to \e mulserver.cc using \e TCP port \e 7777:
\verbatim
> mulclient --tcp --port 7777
\endverbatim
\endif

\subsection \NS{e3} 3. create a filter to wrap every column in a '<>' pair
\if PYTHON
\dontinclude manfilter.py
\skip import
\until Exit
Use \e manfilter.py in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ python manfilter.py @ atool join -d :
\endverbatim
\elseif JAVA
\include manfilter.java
Use \e manfilter.java in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ java example.manfilter @ atool join -d :
\endverbatim
\elseif CSHARP
\include manfilter.cs
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif VB
\dontinclude manfilter.vb
\skip Imports
\until End Module
Use \e manfilter.exe in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ mono manfilter.exe @ atool join -d :
\endverbatim
\elseif TCL
\dontinclude manfilter.tcl
\skip TclMsgque
\until Exit
Use \e manfilter.tcl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ tclsh manfilter.tcl @ atool join -d :
\endverbatim
\elseif PERL
\dontinclude manfilter.pl
\skip strict
\until Exit
Use \e manfilter.pl in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ perl manfilter.pl @ atool join -d :
\endverbatim
\elseif C
\include manfilter.c
Use \e manfilter.c in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\elseif CC
\include manfilter.cc
Use \e manfilter.cc in a LibMsgque command pipeline:
\verbatim
> echo -e "1:2:3\na:b:c" | atool split -d : @ manfilter @ atool join -d :
\endverbatim
\endif

\section	\NS{also}				SEE ALSO
\lang, C: libmsgque(n), C++: ccmsgque(n), C#: csmsgque(n), JAVA: javamsgque(n), PYTHON: pymsgque(n), 
TCL: tclmsgque(n), PERL: perlmsgque(n), VB.NET: vbmsgque(n)

\section	\NS{keywords}				KEYWORDS
\lang, unix, socket, message, msgque


*/




